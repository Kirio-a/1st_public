

------ типы данных ------
строковые
   CHAR(число в диапазоне [0; 255])
   VARCHAR(число в диапазоне [0; 65535])
     тип	размер (в байтах)	максимальное количество символов
   TINYTEXT	   255	                255
   TEXT		           65535	        2^16 - 1
   MEDIUMTEXT	   16777215	        2^24 - 1
   LONGTEXT	   4294967295	        2^32 - 1

числовые
    тип	размер (в байтах)	диапазон signed	     диапазон unsigned
   TINYINT	   1	        [-128; 127]	     [0; 255]
   SMALLINT	   2	        [-2^15; 2^15 - 1]    [0; 2^16 - 1]
   MEDIUMINT	   3	        [-2^23; 2^23 - 1]    [0; 2^24 - 1]
   INT	           4	        [-2^31; 2^31 - 1]    [0; 2^32 - 1]
   BIGINT    	   8   	        [-2^63; 2^63 - 1]    [0; 2^64 - 1]
   FLOAT & DOUBLE числа с плавающей точкой
   DECIMAL(общее кол-во цифр, дробная часть) и NUMERIC(M, D)

Временные
    Тип	      Формат	           Диапазон значений	    
   DATE	      YYYY-MM-DD           1000-01-01 – 9999-12-31 
   TIME	      HH:MM:SS	           00:00:00 – 23:59:59      
   DATETIME   YYYY-MM-DD HH:MM:SS  1000-01-01 00:00:00 – 9999-12-31 23:59:59	
   TIMESTAMP  YYYY-MM-DD HH:MM:SS  1970-01-01 00:00:00 – 2038-01-19 03:14:07	
   YEAR	      YYYY	           1901 – 2155	


ORDER BY сортировка, обрабатывется в конце, можно по псевдонимам
DESC в обратном порядке
LIMIT ограничение кол-ва выводимых строк
OFFSET с какой строки вывести записи

------ ФИЛЬТРАЦИЯ ДАННЫХ ------

 WHERE обрабатывается до SELECT
    Оператор	    Проверка
      =	            Равенство
      <=>	    Эквивалентность
      != или <>	    Неравенство
      <	            Меньше
      <=  	    Меньше или равно
      >	            Больше
      >=	    Больше или равно
      BETWEEN	    Вхождение в диапазон   WHERE поле BETWEEN знач1 AND знач2
      IS NULL	    Значение NULL
      IS NOT NULL   Не значение NULL
   Можно выводить  \    1 - истина              \    как рез-т проверки
                   \    0 - лож
                   \   NULL - неопределенность
  AND удовлетворение всем условиям
  OR удовлетворение хотябы одному условию (второе условие не рассматривается, если выполн первое)
   сначала обрабатывается AND потом OR - исп скобки
  IN (значения ч-з запятую)
  NOT отрицает условие, следующее за ним.  WHERE NOT id = ...
  NOT IN - несоответствие списку значений
   приоритетность выполнения операторов: IN , NOT IN -> NOT -> AND -> OR
  LIKE  ставится перед шаблоном поиска с учетом метасимволов, не учитывается регистр (затратно!!!)
     % - любое количество любых символов
     _ - любой один символ 
 Когда важен регистр:       LIKE CAST('%поиск%' AS BINARY)
                            LIKE CONVERT('%You%', BINARY)
  Когда нужно найти % или _ :     LIKE '__/%' ESCAPE '/'      -символ после / читается как символ
  в строке типа CHAR используются пробелы т.е. нужно учитывать

CONCAT(..., ..., ...) объединяет значения, если есть NULL, то вернет NULL
CONCAT_WS('разделитель', ..., ...) объединяет значения через разделитель, если есть NULL, то проигнорирует






форматы:
 signed, unsigned





конвертация:
 cast(поле as во что перевести)
 convert(поле, во что перевести)


********* ФУНКЦИИ ***********

ТЕКСТОВЫЕ

CHAR_LENGTH() возвр длину строки (можно с числовыми)
LOWER() используется для перевода строки в нижний регистр
UPPER() используется для перевода строки в верхний регистр
LTRIM() убирает пробелы слева
RTRIM() убирает пробелы справа
REVERSE() переворачивает строку (можно с числовыми)
REPEAT(строка, сколько раз повторить) повторяет (можно с числовыми)
LPAD(исх_строка, желаемая_длина_строки, чем_дополнить) дополняет строку (можно с числовыми)
RPAD() дополняет строку справа
LEFT(исх_строка, сколько_символов) извлекает нужное кол-во символов с начала строки
RIGHT(исх_строка, сколько_символов) извлекает нужное кол-во символов с конца строки (счет справа)
LOCATE(искомая_подстр, исх_строка, откуда_начать(опц)) поиск позиции подстроки в строке
REPLACE(исх_строка, заменяемая, чем_заменить) заменяет подстроку в строке (с учетом регистра)
SUBSTRING(исх_строка, позиция 1го извлекаемого символа, длина излекаемой подстроки) извлечение подстроки из строки
SUBSTRING_INDEX(исх_строка, разделительб кол-во появлений разделителя) извлечение подстроки из строки с помощью разделителя
TRIM(<ключевое слово LEADING, TRAILING или BOTH> <удаляемая подстрока> FROM <исходная строка>) удаление всех вхождений подстроки из начала и/или конца строки
      Если не указаны и ключевое слово, и удаляемая подстрока - удаление всех пробелов из начала и конца строки.




дата и время

 INTERVAL \величина\ \единица измерения\
   единица измерения	ключевое слово
    микросекунда	microsecond
    секунда	        second
    минута	        minute
    час	                hour
    день	        day
    неделя	        week
    месяц	        month
    квартал	        quarter
    год	                year
   составные единицы: от_до : minute_second(минуты:секунды) или day_second(дни часы:минуты:секунды)
   прим: select '2023-01-01' + interval '10-2' year_month;
         select '2023-01-01 14:00:00' - interval '01:30' hour_minute;

  now() возвр. текущую дату и время
  curdate() возвр. текущую дату
  curtime() возвр. текущее время
  utc_timestamp() возвр. текущую дату и время в utc
  utc_time
  utc_date
  makedate(год, номер дня в году) возвр. дату. если к.л. аргумент null, вернет null
  maketime(часы, минуты, секунды) возвр. время. если мин или сек >60, вернет null
  time_to_sec(время) возвр. количество секунд 
  sec_to_time(количество секунд) возвр. время
  to_days(дата) возвр. количество дней
  to_seconds(дата) возвр. количество секунд
  last_day(дата) возвр. последний день этого месяца
  date(дата и время) возвр. дату
  time(дата и время) возвр. время
  hour(время), minute(время), second(время) и microsecond(время)
  year(дата), month(дата) и day(дата)
  dayofyear(дата) возвр. номера дня в году
  week(дата) возвр. номера недели в году
  weekday(дата) возвр. номер дня недели (от 0 до 6)
  quarter(дата) возвр. номер квартала (от 1 до 4)
  dayname(дата) возвр. название дня недели (monday....)
  monthname(дата) возвр. название месяца
       языковая локаль:   set lc_time_names = 'ru_ru' или 'en_us';
  adddate(дата и время(дата), временной интервал\interval 4 day\) прибавляет интервал
  subdate(дата и время(дата), временной интервал\interval 4 hour\) вычитает интервал
  addtime(дата и время(время), время) прибавляет время 
  subtime(дата и время(время), время) отнимает время
  datediff(первая дата и время(дата), вторая дата и время) разница дней м-ду 1и2.
  timediff(первая дата и время(время), вторая дата и время) разница время м-ду 1и2.
  timestampdiff(единица измерения(одиночн), первая дата и время(дата), вторая дата и      время(дата)) разницы м-ду 1и2 в опр. единицах измерения
  timestamp(дата, время) объединяет дату и время

 форматирование
     спецификатор	описание
        %m	полное название месяца (january..december)
        %b      сокращенное название месяца (jan..dec)
        %w	полное название дня недели (sunday..saturday)
        %a	сокращенное название дня недели (sun..sat)
        %y	год (0000..9999)
        %m	номер месяца (00..12)
        %d	день месяца (00..31)
        %w	номер дня недели (0..6)
        %h	часы (00..23)
        %i	минуты (00..59)
        %s	секунды (00..59)
        %f	микросекунды (000000..999999)
        %t	время в формате hh:mm:ss
  date_format(дата и время(дата), строка формата) преобразует в заданный формат
    прим:  select date_format('2023-10-20 07:30:00', '%h:%i, %d.%m.%y')
  time_format(время, строка формата)
  str_to_date(строка с компонентами даты и времени, строка формата) строку преобр. в дату(время)
  get_format(тип объекта, для которого требуется строка формата (date, time или datetime), формат (usa, jis, iso или eur))

-------СОЕДИНЕНИЕ ТАБЛИЦ------

  (INNER) JOIN (ВНУТРЕННИЙ) - возвр записи, кот имеют соотв знач в обеих таблицах
  LEFT (OUTER) JOIN - возвр записи из левой табл и совпавшие из правой
  RIGHT (OUTER) JOIN - возвр записи из правой табл и совпавшие из левой
  FULL (OUTER) JOIN - возвр все записи, когда есть совпадение в левой или правой табл
   Можно возвр все записи одной из таблиц исключив совпадения с другой таблицы:
     LEFT (RIGHT) JOIN  ON Линшняя_табл.поле = null

Самосоединение - раздвоение таблицы с указанием связи с новым полем
     SELECT T1.поле,
            T2.поле AS новое_поле
     FROM Табл AS T1 INNER JOIN Табл AS T2 ON T1.зависимое_поле = T2.первонач_поле;

Объединение результатов запросов:
    select поле as псевдоним, поле as псевдоним
      from таблица

      union    (distinct & all опционально)

    select поле, поле
    from таблица;
    limit & order by --если здесь, то работают на весь результат
     одинаковое количество полей
     псевдонимы в первом селекте
     лимит и ордер можно ставить внутри после таблицы, тогда в скобки
     order by внутри запроса не действует!
     если по одному полю - исключает совпадения, как distinct
     в каждом запросе можно добавить поле с псевдонимом как вспомогательное 
     все в скобки () as псевдоним_общей_таблицы для дальнейшей работы с ней

-------ОБНОВЛЕНИЕ - УДАЛЕНИЕ - ДОБАВЛЕНИЕ ПОЛЕЙ------

   UPDATE Табл
   SET поле = 
       поле2 = ф-ции
       поле3 = CASE
   WHERE
   ORDER BY И LIMIT (если неск таблиц - не работает с JOIN, нужен подзапрос)

   DELETE FROM Табл
   WHERE

  TRUNCATE удаляет все записи таблицы   

  INSERT INTO Табл (поля таблицы ч-з запятую)
  VALUES (значения через запятую  в то же порядке)
         (значения через запятую  для следующего поля, если добавл неск)

  INSERT INTO Табл
  SET поле1 = знач,
      поле2 = 'знач2', и т.д.

  INSERT INTO Табл1 (поля таблицы ч-з запятую)
  SELECT <поля таблицы ч-з запятую> FROM Табл2;
 
  REPLACE вместо INSERT заменяет записи если совпадения по ключам

  IGNORE позволяет игнорировать любые ошибки

------  СОЗДАНИЕ ТАБЛИЦЫ --------

IF NOT EXISTS создаст табл, если имя уникально
NOT NULL запрещает полю хранить значение NULL
UNIQUE запрещает полю хранить неуникальные значения
DEFAULT опр. значение по умолчанию,
CHECK исп. чтобы запретить полю хранить значения, не удовлетворяющие заданному условию (=, >, LIKE и так далее)
PRIMARY KEY опр. первичный ключ (должен быть уникальным, не может быть null)
   составной пошется после перечисления полей:     PRIMARY KEY (поле1, поле2)
AUTO_INCREMENT  автоматическое заполнения поля при заполнении табл, потом не меняется (сброс только TRUNCATE) (теолько одно поле, нельзя с DEFAULT)
FOREIGN KEY опр. поле как внешний ключ (можно указывать неск. полей)
  пишется после перечисления полей:      FOREIGN KEY (поле_внешний_ключ) REFERENCES Табл_родительская (поле)
ON UPDATE действие со связанными данными при обновлении
ON DELETE действие со связанными данными при удалении
   CASCADE действие применяется ко всем связанным данным всех таблиц
   SET NULL при действии в родительской табл - связанные записи дочерних примут знач NULL

CREATE TABLE Songs                                               -- операция создания таблицы
(
    id        INT (PRIMARY KEY AUTO_INCREMENT если нужно),
    trackname VARCHAR(30) UNIQUE NOT NULL,
    artist    VARCHAR(30) DEFAULT 'Unknown',
    fulltitle VARCHAR(40) DEFAULT (CONCAT(title, ' by ', author)),
    album_id  INT,
    CONSTRAINT positive_id CHECK (id > 0),                       -- проверка условия
    FOREIGN KEY (album_id) REFERENCES Albums (id),               -- присвоение внешнего ключа
        ON UPDATE CASCADE                                        -- действие с внешними ключами при изменении данных
        ON DELETE SET NULL                                       -- действие с внешними ключами при удалении данных
);                                                               -- завершение операции

INSERT INTO Songs (trackname, artist)                            -- операция наполнения таблицы
VALUES ('Crazy On You', 'Heart'),
       ('My Lover', 'The Sounds');                               -- завершение операции

SELECT *                                                         -- операция извлечения данных из таблицы
FROM Songs;                                                      -- завершение операции

DESCRIBE Табл;                                                   -- выводит описание полей таблицы

------ УДАЛЕНИЕ. ПЕРЕИМЕНОВАНИЕ. ИЗМЕНЕНИЕ ТАБЛИЦ -------

DROP TABLE IF EXISTS Табл; удаление таблицы
RENAME TABLE <текущее имя таблицы> TO <новое имя таблицы>  переимеование таблицы (COLUMN поля)
ALTER TABLE Табл  первая строка для изменения таблицы
ADD COLUMN добавление поля   (FIRST в начало, AFTER <поле> - в нужное место)
            прим:    ALTER TABLE Books
                     ADD COLUMN release_year INT CHECK (release_year > 0) AFTER title;
MODIFY COLUMN изменение свойств поля (пишется все заново, старое не сохраняется (кроме PRIMARY KEY и UNIQUE)
SET DEFAULT установление значения по умолчанию  (DROP DEFAULT удалить)
            прим: ALTER COLUMN <название поля> SET DEFAULT <значение по умолчанию>
ADD PRIMARY KEY (поле) установить первичный ключ  (DROP PRIMARY KEY убрать)
ADD FOREIGN KEY (поле_внешний_ключ) REFERENCES Табл_родительская (поле)
ADD CONSTRAINT <имя ограничения> CHECK (<проверяющее выражение>) или просто ADD CHECK (<проверяющее выражение>)
CHANGE COLUMN <текущее имя поля> <новое определение поля, включающее имя, тип и набор ограничений> переименование и переопределение

-- ТРИГГЕРЫ --
Привязывется к таблице
  DELIMITER //
  CREATE TRIGGER <имя триггера>
  <время срабатывания триггера> <операция, которая вызывает триггер>
  ON <имя таблицы>
  FOR EACH ROW
  BEGIN
      <тело триггера>;
  END //
  DELIMITER ;
BEFORE и AFTER - время срабатывания триггера
INSERT, DELETE и UPDATE - <операция, которая вызывает триггер>
BEFORE INSERT — имеет доступ к значениям добавляемой записи; может изменять значения добавляемой записи
AFTER INSERT — имеет доступ к значениям добавленной записи
BEFORE UPDATE — имеет доступ к старым и новым значениям обновляемой записи; может изменять новые значения обновляемой записи
AFTER UPDATE — имеет доступ к старым и новым значениям обновленной записи
BEFORE DELETE — имеет доступ к значениям удаляемой записи
AFTER DELETE — имеет доступ к значениям удаленной записи
OLD для обращения к старым записям
NEW к новым
  Упрощенный
    CREATE TRIGGER <имя триггера>
    <время срабатывания триггера> <операция, которая вызывает триггер>
    ON <имя таблицы>
    FOR EACH ROW
    <тело триггера>

-- ПРЕДСТАВЛЕНИЯ --

CREATE VIEW <имя представления> AS
<извлекающий запрос>

CREATE OR REPLACE VIEW если сущ представление с таким же именем, оно будет заменено на текущее

ALTER VIEW <имя представления> AS          -- изменение представлений
<новый извлекающий запрос>;
DROP VIEW IF EXISTS <имя представления>;   -- удаление представлений


-- ОБОБЩЕННЫЕ ТАБЛИЧНЫЕ ВЫРАЖЕНИЯ --
   COMMON TABLE EXPRESSION (CTE)

  WITH <имя CTE> AS (
    <извлекающий запрос, определяющий содержимое CTE>
  )
  основной запрос, который может обращаться к CTE>

-- Рекурсивные CTE --

WITH RECURSIVE <имя CTE> AS (
    <извлекающий запрос, определяющий первую запись CTE>
    <пара ключевых слов UNION ALL или UNION DISTINCT>
    <извлекающий запрос, определяющий правило формирования очередной записи CTE (второй, третьей, и так далее)>
)
<основной запрос, который может обращаться к рекурсивному CTE>

Если идет работа со строковыми значениями то нужно увеличить величину при создании извлекающего запроса:
       WITH RECURSIVE Beegeek AS (
           SELECT CONVERT('bee', CHAR(50)) AS field   -- пятидесяти символьное строковое поле
           UNION ALL  .....

---- ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ ----

DELIMITER //
CREATE FUNCTION <имя функции>(<имя 1 параметра и его тип>, <имя 2 параметра и его тип>, ...)
RETURNS <тип возвращаемого значения>
DETERMINISTIC или NOT DETERMINISTIC <вид функции: детерминированная или недетерминированная>
если NOT то: READS SQL DATA или NO SQL
COMMENT 'название функции'           -- если нужно, для удобства
BEGIN
    <тело функции>;
    RETURN <возвращаемое значение>;
END //
DELIMITER ;

DECLARE <имя переменной> <тип данных значения, хранимого в переменной>;  -- если нужно использовать переменную - сначала нужно ее определить(все)
    прим: ..BEGIN
              DECLARE min_grade INT;
              DECLARE max_grade INT;
              SET min_grade := (SELECT MIN(grade)
                                FROM Math);
              SET max_grade := (SELECT MAX(grade)
                                FROM Math); ........
               
DECLARE variable INT DEFAULT 0   -- если нужно значение по умолчанию
DROP FUNCTION удаление функции

IF-ELSEIF-ELSE проверка нескольких условий и выполнение операции
IF <первое проверяемое условие> THEN
    <одна или несколько операций>;
ELSEIF <второе проверяемое условие> THEN
    <одна или несколько операций>;
...
ELSE <одна или несколько операций>;
END IF;

WHILE повторять выполнение ряда операций до тех пор, пока истинно определенное условие.
WHILE <проверяемое условие> DO
    <тело цикла>;
END WHILE;

--- ХРАНИМЫЕ ПРОЦЕДУРЫ ---

DELIMITER //
CREATE PROCEDURE <имя процедуры>(<1 параметр>, <2 параметр>, ...) параметры - функционально
NOT DETERMINISTIC по умолчанию те нужно указывать, если DETERMINISTIC
COMMENT 'любой комментарий'    -- опционально
    BEGIN
    <тело процедуры>;
END //
DELIMITER ;

CALL <имя процедуры>   -- вызов процедуры
DROP PROCEDURE <имя процедуры>  удаление процедуры
IN входной параметр (по умолчанию)
OUT выходной параметр( начальное значение NULL)

------ ОКОННЫЕ ФУНКЦИИ -----

Результирующий набор - таблица, кот формируется извлекающим запросом в рез-те вып-я след операций (нек. опционально): JOIN, FROM, WHERE, GROUP BY, HAVING.
Результат запроса формируется на основе результирующего набора в рез-те вып-я след операций (нек опц): SELECT, AS, ORDER BY, LIMIT.
Определение окна происх после JOIN, FROM, WHERE, GROUP BY и HAVING

WINDOW <название окна> AS (<спецификация окна>)
       ,<название окна> AS (<спецификация окна>)     --если нужно несколько окон

Внутри окна можно выполнять:
   ORDER BY сортировка тольео внутри окна
   PARTITION BY секционирование по значению поля (без учета регистра)

Упрощенная форма:   
     SELECT full_name, salary,
            ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num  --сначала секционир-е, потом сорт
     FROM Employees;

ROW_NUMBER() вычисляет порядковый номер записи в рамках указанного окна


               

order by locate(поле, "простоперечислитьнужныйпорядокбезпробелов")
