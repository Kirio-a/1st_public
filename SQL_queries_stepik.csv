section,table,task,time_wasted,complexity,query,another_query,additional_query
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     running_time INT );  INSERT INTO Films (title, director, release_year, running_time)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 93),        ('WALL-E', 'Andrew Stanton', 2008, 104),        ('Ratatouille', 'Brad Bird', 2007, 115),        ('Up', 'Pete Docter', 2009, 101),        ('Brave', 'Brenda Chapman', 2012, 102),        ('Monsters University', 'Dan Scanlon', 2013, 110),        ('Cars 2', 'John Lasseter', 2011, 120),        ('Finding Nemo', 'Andrew Stanton', 2003, 107),        ('Toy Story', 'John Lasseter', 1995, 81),        ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, извлекающий из предложенной базы данных всю информацию о фильмах, идентификатор которых принадлежит диапазону [1; 5] и которые длятся более 100 минут.",5,2,SELECT * FROM Films WHERE id BETWEEN 1 AND 5 AND running_time >= 100,SELECT * FROM Films  WHERE id <= 5 AND running_time > 100,
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     running_time INT );  INSERT INTO Films (title, director, release_year, running_time)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 93),        ('WALL-E', 'Andrew Stanton', 2008, 104),        ('Ratatouille', 'Brad Bird', 2007, 115),        ('Up', 'Pete Docter', 2009, 101),        ('Brave', 'Brenda Chapman', 2012, 102),        ('Monsters University', 'Dan Scanlon', 2013, 110),        ('Cars 2', 'John Lasseter', 2011, 120),        ('Finding Nemo', 'Andrew Stanton', 2003, 107),        ('Toy Story', 'John Lasseter', 1995, 81),        ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера, год выпуска), режиссером которых является John Lasseter и которые были выпущены до 2000 года.",5,2,"SELECT title, director, release_year FROM Films WHERE director = 'John Lasseter' AND release_year <= 2000 ORDER BY release_year",,
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     running_time INT );  INSERT INTO Films (title, director, release_year, running_time)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 93),        ('WALL-E', 'Andrew Stanton', 2008, 104),        ('Ratatouille', 'Brad Bird', 2007, 115),        ('Up', 'Pete Docter', 2009, 101),        ('Brave', 'Brenda Chapman', 2012, 102),        ('Monsters University', 'Dan Scanlon', 2013, 110),        ('Cars 2', 'John Lasseter', 2011, 120),        ('Finding Nemo', 'Andrew Stanton', 2003, 107),        ('Toy Story', 'John Lasseter', 1995, 81),        ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, год выпуска), которые были выпущены в 1999 году или в 2009​​​ ​​​​году.",5,1,"SELECT title, release_year FROM Films WHERE release_year IN (1999, 2009) ORDER BY release_year desc",,
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     running_time INT );  INSERT INTO Films (title, director, release_year, running_time)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 93),        ('WALL-E', 'Andrew Stanton', 2008, 104),        ('Ratatouille', 'Brad Bird', 2007, 115),        ('Up', 'Pete Docter', 2009, 101),        ('Brave', 'Brenda Chapman', 2012, 102),        ('Monsters University', 'Dan Scanlon', 2013, 110),        ('Cars 2', 'John Lasseter', 2011, 120),        ('Finding Nemo', 'Andrew Stanton', 2003, 107),        ('Toy Story', 'John Lasseter', 1995, 81),        ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, продолжительность), которые длятся менее 100 минут или более 110 минут.",5,1,"SELECT title, running_time FROM Films WHERE running_time > 110 OR running_time < 100 ORDER BY running_time DESC",,
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(20), director VARCHAR(20), release_year INT, running_time INT ); INSERT INTO Films (title, director, release_year, running_time) VALUES ('Toy Story 2', 'John Lasseter', 1999, 93), ('WALL-E', 'Andrew Stanton', 2008, 104), ('Ratatouille', 'Brad Bird', 2007, 115), ('Up', 'Pete Docter', 2009, 101), ('Brave', 'Brenda Chapman', 2012, 102), ('Monsters University', 'Dan Scanlon', 2013, 110), ('Cars 2', 'John Lasseter', 2011, 120), ('Finding Nemo', 'Andrew Stanton', 2003, 107), ('Toy Story', 'John Lasseter', 1995, 81), ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера, продолжительность), режиссером которых является John Lasseter или Andrew Stanton и которые длятся более 100 минут.",10,1,"SELECT title, director, running_time FROM Films WHERE (director = 'John Lasseter' OR director = 'Andrew Stanton') AND running_time > 100 ORDER BY director, title",,
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     running_time INT );  INSERT INTO Films (title, director, release_year, running_time)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 93),        ('WALL-E', 'Andrew Stanton', 2008, 104),        ('Ratatouille', 'Brad Bird', 2007, 115),        ('Up', 'Pete Docter', 2009, 101),        ('Brave', 'Brenda Chapman', 2012, 102),        ('Monsters University', 'Dan Scanlon', 2013, 110),        ('Cars 2', 'John Lasseter', 2011, 120),        ('Finding Nemo', 'Andrew Stanton', 2003, 107),        ('Toy Story', 'John Lasseter', 1995, 81),        ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, который извлекает из предложенной базы данных всю информацию о фильмах под названиями WALL-E, Up, Brave и Toy Story.",5,1,"SELECT * FROM Films WHERE title IN ('WALL-E', 'Up', 'Brave', 'Toy Story') ORDER BY release_year ",,
3.5. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     running_time INT );  INSERT INTO Films (title, director, release_year, running_time)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 93),        ('WALL-E', 'Andrew Stanton', 2008, 104),        ('Ratatouille', 'Brad Bird', 2007, 115),        ('Up', 'Pete Docter', 2009, 101),        ('Brave', 'Brenda Chapman', 2012, 102),        ('Monsters University', 'Dan Scanlon', 2013, 110),        ('Cars 2', 'John Lasseter', 2011, 120),        ('Finding Nemo', 'Andrew Stanton', 2003, 107),        ('Toy Story', 'John Lasseter', 1995, 81),        ('The Incredibles', 'Brad Bird', 2004, 116);","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера, год выпуска), которые были выпущены не в 2004, 2008 и 2012 годах.",5,1,"SELECT title, director, release_year FROM Films WHERE release_year NOT IN ('2004', '2008', '2012') ORDER BY director, release_year DESC",,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера), которые принадлежат серии Toy Story.",5,1,"SELECT title, director FROM Films WHERE title LIKE 'Toy story%' ORDER BY title",,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных уникальные имена и фамилии режиссеров, имена которых начинаются на букву B.",5,1,select distinct director from Films where director like binary 'B%' order by director,,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных уникальные имена и фамилии режиссеров, фамилии которых заканчиваются на сочетание букв er.",5,1,select distinct director from Films where director like '%er' order by director,,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'),        ('Dug Days', 'Bob Peterson');","Напишите запрос, извлекающий из предложенной базы данных уникальные имена и фамилии режиссеров, фамилии которых начинаются на букву S и заканчиваются на букву n.",5,1,select distinct director from Films where director like '% s%n' order by director,,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных уникальные имена и фамилии режиссеров, имена которых состоят из четырех букв.",5,1,select distinct director from Films where director like '____ %' order by director,,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных уникальные имена и фамилии режиссеров, фамилии которых состоят из семи и более букв.",5,2,select distinct director from Films where director like '% _______%' order by director,,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера), названия которых не содержат строчную букву t.",5,2,"select title, director from Films where title not like binary '%t%' order by title","SELECT title, director FROM Films WHERE NOT title LIKE CAST('%t%' AS BINARY) ORDER BY title;",
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера), названия которых состоят из двух и более слов.",5,2,"select title, director from Films where title like '% %' order by title",,
3.6. Основы. Фильтрация данных,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(40) );  INSERT INTO Films (title, director) VALUES ('Toy Story 3', 'Lee Unkrich'),        ('Monsters University', 'Dan Scanlon'),        ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера), названия которых состоят из одного слова.",5,2,"select title, director from Films where title not like '% %' order by title",,
3.7. Создание вычисляемых полей,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id        INT PRIMARY KEY AUTO_INCREMENT,     title     VARCHAR(20),     director  VARCHAR(20),     composer  VARCHAR(20),     rating    DECIMAL(2, 1),     price     DECIMAL(3, 2),     purchases INT );  INSERT INTO Films (title, director, composer, rating, price, purchases) VALUES ('Venom', 'Ruben Fleischer', 'Ludwig Goransson', 6.9, 4.99, 2143535),        ('Aladdin', 'Guy Ritchie', 'Alan Menken', 7.3, 3.99, 3253263),        ('Encanto', 'Jared Bush', 'Germaine Franco', 7.5, 2.99, 451245),        ('The Witches', 'Robert Zemeckis', 'Alan Silvestri', 5.7, 1.99, 67441),        ('Blade Runner 2049', 'Denis Villeneuve', 'Benjamin Wallfisch', 7.8, 5.99, 2164214),        ('Equilibrium', 'Kurt Wimmer', 'Klaus Badelt', 7.9, 5.99, 54124561),        ('Ready or Not', 'Matthew Bettinelli', 'Brian Tyler', 6.9, 4.99, 541234),        ('Fast X', 'Louis Leterrier', 'Brian Tyler', 6.1, 3.99, 454113),        ('John Wick', 'Chad Stahelski', 'Tyler Bates', 7.0, 4.99, 1247322),        ('Fight Club', 'David Fincher', 'Dust Brothers', 8.7, 5.99, 17641285);","Напишите запрос, который извлекает из предложенной базы данных идентификаторы и названия всех фильмов.  При этом в результирующей таблице идентификатор и название каждого фильма должны быть указаны в одном поле c псевдонимом movie в следующем формате:  <идентификатор фильма>. <название фильма>",5,1,"select concat(id, '. ', title) as movie from Films",,
3.7. Создание вычисляемых полей,"DROP TABLE IF EXISTS Films; CREATE TABLE Films ( id INT PRIMARY KEY AUTO_INCREMENT, title VARCHAR(20), director VARCHAR(20), composer VARCHAR(20), rating DECIMAL(2, 1), price DECIMAL(3, 2), purchases INT ); INSERT INTO Films (title, director, composer, rating, price, purchases) VALUES ('Venom', 'Ruben Fleischer', 'Ludwig Goransson', 6.9, 4.99, 2143535), ('Aladdin', 'Guy Ritchie', 'Alan Menken', 7.3, 3.99, 3253263), ('Encanto', 'Jared Bush', 'Germaine Franco', 7.5, 2.99, 451245), ('The Witches', 'Robert Zemeckis', 'Alan Silvestri', 5.7, 1.99, 67441), ('Blade Runner 2049', 'Denis Villeneuve', 'Benjamin Wallfisch', 7.8, 5.99, 2164214), ('Equilibrium', 'Kurt Wimmer', 'Klaus Badelt', 7.9, 5.99, 54124561), ('Ready or Not', 'Matthew Bettinelli', 'Brian Tyler', 6.9, 4.99, 541234), ('Fast X', 'Louis Leterrier', 'Brian Tyler', 6.1, 3.99, 454113), ('John Wick', 'Chad Stahelski', 'Tyler Bates', 7.0, 4.99, 1247322), ('Fight Club', 'David Fincher', 'Dust Brothers', 8.7, 5.99, 17641285);",При этом в результирующей таблице идентификатор и название каждого фильма должны быть указаны в одном поле c псевдонимом movie в следующем формате:  <идентификатор фильма>. <название фильма> Цена каждого фильма должна быть записана в следующем формате:  €<цена>,5,1,"select concat(id, '. ', title) as movie, concat('€', price) as price from Films",,
3.7. Создание вычисляемых полей,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id        INT PRIMARY KEY AUTO_INCREMENT,     title     VARCHAR(20),     director  VARCHAR(20),     composer  VARCHAR(20),     rating    DECIMAL(2, 1),     price     DECIMAL(3, 2),     purchases INT );  INSERT INTO Films (title, director, composer, rating, price, purchases) VALUES ('Venom', 'Ruben Fleischer', 'Ludwig Goransson', 6.9, 4.99, 2143535),        ('Aladdin', 'Guy Ritchie', 'Alan Menken', 7.3, 3.99, 3253263),        ('Encanto', 'Jared Bush', 'Germaine Franco', 7.5, 2.99, 451245),        ('The Witches', 'Robert Zemeckis', 'Alan Silvestri', 5.7, 1.99, 67441),        ('Blade Runner 2049', 'Denis Villeneuve', 'Benjamin Wallfisch', 7.8, 5.99, 2164214),        ('Equilibrium', 'Kurt Wimmer', 'Klaus Badelt', 7.9, 5.99, 54124561),        ('Ready or Not', 'Matthew Bettinelli', 'Brian Tyler', 6.9, 4.99, 541234),        ('Fast X', 'Louis Leterrier', 'Brian Tyler', 6.1, 3.99, 454113),        ('John Wick', 'Chad Stahelski', 'Tyler Bates', 7.0, 4.99, 1247322),        ('Fight Club', 'David Fincher', 'Dust Brothers', 8.7, 5.99, 17641285); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех фильмах: название, имя и фамилия режиссера, имя и фамилия композитора.  При этом в результирующей таблице информация о каждом фильме должна быть указана в одном поле c псевдонимом movie_info в следующем формате:  <название фильма>: <имя и фамилия режиссера>, <имя и фамилия композитора>",5,1,"select concat(title, ': ', director, ', ', composer) as movie_info from Films",,
3.7. Создание вычисляемых полей,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id        INT PRIMARY KEY AUTO_INCREMENT,     title     VARCHAR(20),     director  VARCHAR(20),     composer  VARCHAR(20),     rating    DECIMAL(2, 1),     price     DECIMAL(3, 2),     purchases INT );  INSERT INTO Films (title, director, composer, rating, price, purchases) VALUES ('Venom', 'Ruben Fleischer', 'Ludwig Goransson', 6.9, 4.99, 2143535),        ('Aladdin', 'Guy Ritchie', 'Alan Menken', 7.3, 3.99, 3253263),        ('Encanto', 'Jared Bush', 'Germaine Franco', 7.5, 2.99, 451245),        ('The Witches', 'Robert Zemeckis', 'Alan Silvestri', 5.7, 1.99, 67441),        ('Blade Runner 2049', 'Denis Villeneuve', 'Benjamin Wallfisch', 7.8, 5.99, 2164214),        ('Equilibrium', 'Kurt Wimmer', 'Klaus Badelt', 7.9, 5.99, 54124561),        ('Ready or Not', 'Matthew Bettinelli', 'Brian Tyler', 6.9, 4.99, 541234),        ('Fast X', 'Louis Leterrier', 'Brian Tyler', 6.1, 3.99, 454113),        ('John Wick', 'Chad Stahelski', 'Tyler Bates', 7.0, 4.99, 1247322),        ('Fight Club', 'David Fincher', 'Dust Brothers', 8.7, 5.99, 17641285); ","Кинотеатр устанавливает определенную цену для каждого фильма, а также ведет подсчет проданных копий. Прибылью фильма кинотеатр называет произведение цены фильма и количества ее проданных копий.  Напишите запрос, который определяет три самых прибыльных фильма и указывает следующую информацию о них: название, прибыль.",5,2,"select title, price*purchases as profit from Films order by profit desc limit 3",,
3.7. Создание вычисляемых полей,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id        INT PRIMARY KEY AUTO_INCREMENT,     title     VARCHAR(20),     director  VARCHAR(20),     composer  VARCHAR(20),     rating    DECIMAL(2, 1),     price     DECIMAL(3, 2),     purchases INT );  INSERT INTO Films (title, director, composer, rating, price, purchases) VALUES ('Venom', 'Ruben Fleischer', 'Ludwig Goransson', 6.9, 4.99, 2143535),        ('Aladdin', 'Guy Ritchie', 'Alan Menken', 7.3, 3.99, 3253263),        ('Encanto', 'Jared Bush', 'Germaine Franco', 7.5, 2.99, 451245),        ('The Witches', 'Robert Zemeckis', 'Alan Silvestri', 5.7, 1.99, 67441),        ('Blade Runner 2049', 'Denis Villeneuve', 'Benjamin Wallfisch', 7.8, 5.99, 2164214),        ('Equilibrium', 'Kurt Wimmer', 'Klaus Badelt', 7.9, 5.99, 54124561),        ('Ready or Not', 'Matthew Bettinelli', 'Brian Tyler', 6.9, 4.99, 541234),        ('Fast X', 'Louis Leterrier', 'Brian Tyler', 6.1, 3.99, 454113),        ('John Wick', 'Chad Stahelski', 'Tyler Bates', 7.0, 4.99, 1247322),        ('Fight Club', 'David Fincher', 'Dust Brothers', 8.7, 5.99, 17641285); ","Напишите запрос, который извлекает из предложенной базы данных названия фильмов и их цены, взятые со скидкой 30%. При этом в результирующую таблицу должны быть добавлены только те фильмы, скидочная цена которых меньше 4 долларов.  Поле со скидочной ценой фильма должно иметь псевдоним discount_price.",10,2,"select title, price*0.7 as discount_price from Films where price*0.7 < 4 order by discount_price",,
3.7. Создание вычисляемых полей,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id        INT PRIMARY KEY AUTO_INCREMENT,     title     VARCHAR(20),     director  VARCHAR(20),     composer  VARCHAR(20),     rating    DECIMAL(3, 1),     price     DECIMAL(3, 2),     purchases INT );  INSERT INTO Films (title, director, composer, rating, price, purchases) VALUES ('Venom', 'Ruben Fleischer', 'Ludwig Goransson', 6.9, 4.99, 2143535),        ('Aladdin', 'Guy Ritchie', 'Alan Menken', 7.3, 3.99, 3253263),        ('Encanto', 'Jared Bush', 'Germaine Franco', 7.5, 2.99, 451245),        ('The Witches', 'Robert Zemeckis', 'Alan Silvestri', 5.7, 1.99, 67441),        ('Blade Runner 2049', 'Denis Villeneuve', 'Benjamin Wallfisch', 7.8, 5.99, 2164214),        ('Equilibrium', 'Kurt Wimmer', 'Klaus Badelt', 7.9, 5.99, 54124561),        ('Ready or Not', 'Matthew Bettinelli', 'Brian Tyler', 6.9, 4.99, 541234),        ('Fast X', 'Louis Leterrier', 'Brian Tyler', 6.1, 3.99, 454113),        ('John Wick', 'Chad Stahelski', 'Tyler Bates', 7.0, 4.99, 1247322),        ('Fight Club', 'David Fincher', 'Dust Brothers', 10.0, 5.99, 17641285); ","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (идентификатор, название, цена, рейтинг), рейтинг которых больше 7.  При этом в результирующей таблице идентификатор и название каждого фильма должны быть указаны в одном поле c псевдонимом movie в следующем формате:  <идентификатор фильма>. <название фильма> Цена каждого фильма должна быть переведена в евро согласно курсу $1 = €1.1 и указана в поле с псевдонимом price_in_eur в следующем формате:",15,3,"select  concat(id, '. ', title) as movie,  concat('€', price*1.1) as price_in_eur,  concat(rating*10, '%') as score  from Films where rating > 7 order by rating desc",,
4.1. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40) );  INSERT INTO Directors (name, surname, country) VALUES ('Christopher', 'Nolan', 'England'),        ('Steven', 'Spielberg', 'USA'),        ('Quentin', 'Tarantino', 'USA'),        ('Martin', 'Scorsese', 'USA'),        ('David', 'Fincher', 'USA'),        ('Ridley', 'Scott', 'England'),        ('Stanley', 'Kubrick', 'USA'),        ('Clint', 'Eastwood', 'USA'),        ('James', 'Cameron', 'Canada'),        ('Tim', 'Burton', 'USA');","Напишите запрос, который извлекает из предложенной базы данных имена всех режиссеров, а также определяет количество символов в имени каждого режиссера.",5,1,"select name, char_length(name) as name_length from Directors order by name_length, name",,
4.1. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40) );  INSERT INTO Directors (name, surname, country) VALUES ('Christopher', 'Nolan', 'England'),        ('Steven', 'Spielberg', 'USA'),        ('Quentin', 'Tarantino', 'USA'),        ('Martin', 'Scorsese', 'USA'),        ('David', 'Fincher', 'USA'),        ('Ridley', 'Scott', 'England'),        ('Stanley', 'Kubrick', 'USA'),        ('Clint', 'Eastwood', 'USA'),        ('James', 'Cameron', 'Canada'),        ('Tim', 'Burton', 'USA');","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии режиссеров, имя которых состоит из 6 и менее символов.",5,1,"select name, surname from Directors where char_length(name) <= 6 order by name",,
4.1. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40) );  INSERT INTO Directors (name, surname, country) VALUES ('christopher', 'nolan', 'England'),        ('Steven', 'Spielberg', 'USA'),        ('Quentin', 'tarantino', 'USA'),        ('Martin', 'Scorsese', 'USA'),        ('David', 'Fincher', 'USA'),        ('ridley', 'Scott', 'England'),        ('stanley', 'Kubrick', 'USA'),        ('Clint', 'Eastwood', 'USA'),        ('James', 'cameron', 'Canada'),        ('tim', 'burton', 'USA');","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии режиссеров, имя или фамилия которых записаны в нижнем регистре.",5,3,"select name, surname from Directors where name like binary lower(name) or surname like binary lower(surname) order by name","SELECT name, surname FROM Directors WHERE name LIKE CAST(LOWER(name) AS BINARY) OR       surname LIKE CAST(LOWER(surname) AS BINARY) ORDER BY name;",
4.1. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40) );  INSERT INTO Directors (name, surname, country) VALUES ('Christopher', 'Nolan', 'England'),        ('Steven', 'Spielberg', 'USA'),        ('Quentin', 'Tarantino', 'USA'),        ('Martin', 'Scorsese', 'USA'),        ('David', 'Fincher', 'USA'),        ('Ridley', 'Scott', 'England'),        ('Stanley', 'Kubrick', 'USA'),        ('Clint', 'Eastwood', 'USA'),        ('James', 'Cameron', 'Canada'),        ('Tim', 'Burton', 'USA');","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: имя, фамилия, страна рождения. При этом в результирующей таблице название страны рождения каждого режиссера должно быть записано в верхнем регистре.",5,1,"select name, surname, upper(country) as country from Directors order by country, name",,
4.1. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40) );  INSERT INTO Directors (name, surname, country) VALUES ('Christopher', 'Nolan', 'England'),        ('Steven', 'Spielberg', 'USA'),        ('Quentin', 'Tarantino', 'USA'),        ('Martin', 'Scorsese', 'USA'),        ('David', 'Fincher', 'USA'),        ('Ridley', 'Scott', 'England'),        ('Stanley', 'Kubrick', 'USA'),        ('Clint', 'Eastwood', 'USA'),        ('James', 'Cameron', 'Canada'),        ('Tim', 'Burton', 'USA');","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех режиссеров. При этом в результирующей таблице все символы в имени каждого режиссера должны быть заменены звездочками (*).",10,3,"select repeat('*', char_length(name)) as name, surname from Directors order by name desc, surname","SELECT     LPAD('', CHAR_LENGTH(name), '*') AS name,     surname FROM Directors ORDER BY CHAR_LENGTH(name) DESC, 2;",
4.1. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40) );  INSERT INTO Directors (name, surname, country) VALUES ('Christopher', 'Nolan', 'England'),        ('Steven', 'Spielberg', 'USA'),        ('Quentin', 'Tarantino', 'USA'),        ('Martin', 'Scorsese', 'USA'),        ('David', 'Fincher', 'USA'),        ('Ridley', 'Scott', 'England'),        ('Stanley', 'Kubrick', 'USA'),        ('Clint', 'Eastwood', 'USA'),        ('James', 'Cameron', 'Canada'),        ('Tim', 'Burton', 'USA');","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: имя, фамилия, рейтинг.  При этом в результирующей таблице рейтинг каждого режиссера должен быть записан в следующем формате:  <рейтинг>% Более того, рейтинги, представленные однозначными числами, должны быть предварены двумя незначащими нулями, а рейтинги, представленные двухзначными числами, — одним незначащим нулем.",5,1,"select name, surname, lpad( concat(rating, '%'), 4, '0') as rating from Directors order by rating","SELECT name, surname, CONCAT(LPAD(rating, 3, 0), '%') AS rating FROM Directors ORDER BY rating ",
4.1. Текстовые функции,"DROP TABLE IF EXISTS Palindromes; CREATE TABLE Palindromes (     id      INT PRIMARY KEY AUTO_INCREMENT,     english VARCHAR(40),     russian VARCHAR(40) );  INSERT INTO Palindromes(english, russian) VALUES ('hut', 'шалаш'),        ('rotor', 'ротор'),        ('tenet', 'принцип'),        ('radar', 'радар'),        ('flood', 'потоп'),        ('level', 'уровень'),        ('madam', 'мадам'),        ('deed', 'поступок'),        ('it', 'оно'),        ('kayak', 'каяк'); ","Напишите запрос, извлекающий из предложенной базы данных слова (в обоих вариантах написания), которые являются палиндромами на английском и русском языках одновременно.",5,1,"select english, russian from Palindromes where reverse(english) = english and reverse(russian) = russian order by english",,
4.1. Текстовые функции,"DROP TABLE IF EXISTS Palindromes; CREATE TABLE Palindromes ( id INT PRIMARY KEY AUTO_INCREMENT, english VARCHAR(40), russian VARCHAR(40) ); INSERT INTO Palindromes(english, russian) VALUES ('hut', 'шалаш'), ('rotor', 'ротор'), ('tenet', 'принцип'), ('radar', 'радар'), ('flood', 'потоп'), ('level', 'уровень'), ('madam', 'мадам'), ('deed', 'поступок'), ('it', 'оно'), ('kayak', 'каяк');","Напишите запрос, извлекающий из предложенной базы данных слова (в английском варианте написания), которые являются палиндромами только на английском языке. При этом в результирующей таблице каждое слово должно быть повторено столько раз, сколько в нем содержится символов.",5,1,"select repeat(english, char_length(english)) as english from Palindromes where reverse(english) = english and reverse(russian) != russian group by english",,
4.2. Текстовые функции,"DROP TABLE IF EXISTS Clients; CREATE TABLE Clients (     id          INT PRIMARY KEY AUTO_INCREMENT,     name        VARCHAR(40),     surname     VARCHAR(40),     card_number VARCHAR(40) );  INSERT INTO Clients (name, surname, card_number) VALUES ('Christopher', 'Nolan', '3409-4719-9958-3769'),        ('Steven', 'Spielberg', '3757-1304-6041-2423'),        ('Quentin', 'Tarantino', '3456-7725-6011-8486'),        ('Martin', 'Scorsese', '3717-9339-7641-9962'),        ('David', 'Fincher', '3789-9065-8560-1250'),        ('Ridley', 'Scott', '3711-7949-7232-0127'),        ('Stanley', 'Kubrick', '3736-9259-2982-7717'),        ('Clint', 'Eastwood', '3484-1457-1207-8953'),        ('James', 'Cameron', '3430-5919-7308-6348'),        ('Tim', 'Burton', '3781-9214-6430-8051');","Напишите запрос, извлекающий из предложенной базы данных информацию о клиентах банка (имя, фамилия, номер банковской карты), фамилии которых начинаются на букву S. При этом в результирующей таблице номер банковской карты каждого клиента должен быть записан без дефисов.",10,2,"select name, surname, replace(card_number, '-', '') card_number from Clients where left(surname, 1) = 's' order by surname","SELECT name, surname, REPLACE(card_number, '-', '') AS card_number  FROM Clients WHERE LOCATE('s', surname) = 1 ORDER BY 2;",
4.2. Текстовые функции,"DROP TABLE IF EXISTS Clients; CREATE TABLE Clients (     id          INT PRIMARY KEY AUTO_INCREMENT,     name        VARCHAR(40),     surname     VARCHAR(40),     card_number VARCHAR(40) );  INSERT INTO Clients (name, surname, card_number) VALUES ('Christopher', 'Nolan', '3409-4719-9958-3769'),        ('Steven', 'Spielberg', '3757-1304-6041-2423'),        ('Quentin', 'Tarantino', '3456-7725-6011-8486'),        ('Martin', 'Scorsese', '3717-9339-7641-9962'),        ('David', 'Fincher', '3789-9065-8560-1250'),        ('Ridley', 'Scott', '3711-7949-7232-0127'),        ('Stanley', 'Kubrick', '3736-9259-2982-7717'),        ('Clint', 'Eastwood', '3484-1457-1207-8953'),        ('James', 'Cameron', '3430-5919-7308-6348'),        ('Tim', 'Burton', '3781-9214-6430-8051'); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию о первых пяти клиентах банка: идентификатор, имя, фамилия, номер банковской карты. При этом в результирующей таблице номер банковской карты каждого клиента должен быть записан без дефисов, а первые 12 цифр номера должны быть заменены звездочками (*).",15,3,"select id, name, surname, lpad(right(replace(card_number, '-', ''),4), 16, '*') as card_number from Clients limit 5","SELECT id, name, surname,        CONCAT(REPEAT('*', 12), RIGHT(card_number, 4)) AS card_number FROM Clients LIMIT 5",
4.2. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех режиссеров.  При этом в результирующей таблице имя и фамилия каждого режиссера должны быть указаны в одном поле c псевдонимом director в следующем формате:  <первая буква в имени режиссера>. <фамилия режиссера>",10,2,"select concat(rpad(name, 1, ''), '. ', surname) as director from Directors order by rpad(name, 1, ''), surname",,
4.2. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех режиссеров. При этом в результирующей таблице все буквы, кроме первой, в имени и фамилии каждого режиссера должны быть заменены звездочками (*).",15,3,"select rpad(left(name, 1), char_length(name), '*') as name,        rpad(left(surname, 1), char_length(surname), '*') as surname from Directors order by left(name, 1), left(surname, 1)","SELECT       CONCAT(lEFT(name, 1), REPEAT('*', CHAR_LENGTH(name) - 1)) AS name,       CONCAT(lEFT(surname, 1), REPEAT('*', CHAR_LENGTH(surname) - 1)) AS surname FROM Directors ORDER BY LEFT(name, 1), surname;",
4.2. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: идентификатор, имя, фамилия, локальная часть адреса электронной почты.",10,3,"select id, name, surname, left(email, locate('@', email)-1) as local_part from Directors order by id desc","SELECT id, name, surname, SUBSTRING_INDEX(email, '@', 1) local_part FROM Directors ORDER BY id DESC;",
4.3. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии режиссеров, имя или фамилия которых записаны в нижнем регистре. При этом в результирующей таблице имя и фамилия каждого режиссера должны быть записаны с заглавной буквы.",25,4,"select concat(upper(substring(name, 1, 1)), '', substring(name, - char_length(name) + 1, char_length(name)-1)) as name, concat(upper(substring(surname, 1, 1)), '', substring(surname, - char_length(surname) + 1, char_length(surname)-1)) as surname    from Directors where binary name = lower(name) or binary surname = lower(surname) order by name","SELECT CONCAT(UPPER(LEFT(name, 1)), SUBSTRING(name, 2)) AS name,        CONCAT(UPPER(LEFT(surname, 1)), SUBSTRING(surname, 2)) AS surname FROM Directors WHERE BINARY LOWER(name) = name       OR BINARY LOWER(surname) = surname ORDER BY name",
4.3. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: имя, фамилия, локальная часть адреса электронной почты, доменная часть адреса электронной почты.",10,2,"select name, surname, substring_index(email, '@', 1) as local_part,                       substring_index(email, '@', -1) as domain from Directors order by name","SELECT name, surname, LEFT(email, LOCATE('@', email) - 1) AS local_part, RIGHT(email, CHAR_LENGTH(email) - LOCATE('@', email)) AS domain FROM Directors ORDER BY name;",
4.3. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о режиссерах (имя, фамилия, адрес электронной почты), в адресах электронной почты которых доменная часть равна outlook.com. При этом в результирующей таблице доменная часть в адресе электронной почты каждого режиссера должна быть заменена на pygen.ru.",10,2,"select name, surname, concat(substring_index(email, '@', 1), '@', 'pygen.ru') as email from Directors where email like '%outlook.com' order by email","SELECT name, surname, REPLACE(email, 'outlook.com', 'pygen.ru') as email FROM Directors WHERE SUBSTRING_INDEX(email, '@', -1) = 'outlook.com' ORDER BY email;",
4.3. Текстовые функции,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: имя, фамилия, адрес электронной почты. При этом в результирующей таблице все символы в локальной части адреса электронной почты каждого режиссера должны быть заменены звездочками (*).",20,4,"select name, surname, concat(repeat('*',char_length(substring_index(email, '@', 1))), '@', substring_index(email, '@', -1)) as email from Directors order by Directors.email ","SELECT name, surname,         LPAD(SUBSTRING(email, LOCATE('@', email)), CHAR_LENGTH(email), '*') AS email FROM Directors ORDER BY SUBSTRING_INDEX(email, '@', 1)",
4.4. Числовые функции,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20) );  INSERT INTO Films (title, director) VALUES ('Toy Story 2', 'John Lasseter'),        ('WALL-E', 'Andrew Stanton'),        ('Ratatouille', 'Brad Bird'),        ('Up', 'Pete Docter'),        ('Brave', 'Brenda Chapman'),        ('Monsters University', 'Dan Scanlon'),        ('Cars 2', 'John Lasseter'),        ('Finding Nemo', 'Andrew Stanton'),        ('Toy Story', 'John Lasseter'),        ('The Incredibles', 'Brad Bird');","Напишите запрос, который извлекает из предложенной базы данных названия пяти случайных фильмов.  ",5,1,select title from Films order by rand() limit 5,,
4.4. Числовые функции,"DROP TABLE IF EXISTS Sizes; CREATE TABLE Sizes (     id              INT PRIMARY KEY AUTO_INCREMENT,     nominal_size    INT,     limit_deviation DECIMAL(3, 2),     actual_size     DECIMAL(4, 2) );  INSERT INTO Sizes (nominal_size, limit_deviation, actual_size) VALUES (18, 0.3, 17.7),        (26, 0.2, 25.6),        (14, 0.4, 14.1),        (42, 0.9, 41),        (36, 0.3, 36),        (24, 0.1, 24.2),        (8, 0.2, 7.9),        (4.3, 0.2, 4.1),        (1, 0.5, 1.5),        (49, 1, 47);","Каждая деталь имеет номинальный размер и действительный. Номинальным размером называют размер, определенный инженером при проектировании детали. Действительным размером называют фактический размер детали, полученный после ее изготовления и измерения. Также для каждой детали определяют допустимую погрешность — величину, на которую действительный размер детали может отличаться от номинального. Завод считает деталь бракованной, если разница между ее действительным и номинальным размерами превышает допустимую погрешность.  Напишите запрос, который извлекает из предложенной базы данных следующую информацию о деталях: действительный размер, допустимая погрешность, разница между действительным и номинальным размерами. При этом в результирующую таблицу должны быть добавлены только те детали, которые не являются бракованными.",15,4,"select actual_size, limit_deviation, ABS(actual_size - nominal_size) as difference from Sizes where ABS(actual_size - nominal_size) <= limit_deviation order by actual_size",,
4.4. Числовые функции,"DROP TABLE IF EXISTS Points; CREATE TABLE Points (     x INT,     y INT );  INSERT INTO Points (x, y) VALUES (5, 7),        (21, 25),        (10, 19),        (19, 29),        (0, 0),        (4, 19),        (23, 1),        (22, 20),        (3, 15),        (6, 18);","Напишите запрос, который извлекает из предложенной базы данных координаты точек, а также определяет, насколько каждая точка удалена от начала координат. При этом в результирующую таблицу должны быть добавлены координаты только тех точек, которые удалены от начала координат на значение больше 20.  Поле с расстоянием от точки до начала координат должно иметь псевдоним distance. Значения в поле distance должны быть округлены до 2 знаков после запятой.",10,2,"select x, y, round(sqrt(pow(x, 2) + pow(y, 2)), 2) as distance from Points where round(sqrt(pow(x, 2) + pow(y, 2)), 2) > 20 order by distance desc","SELECT x, y, ROUND(SQRT(@dist), 2) As distance FROM Points WHERE (@dist := POW(x, 2) + POW(y, 2)) > 400 ORDER BY 3 DESC;",
4.4. Числовые функции,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     running_time INT );  INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 2', 'John Lasseter', 69),        ('WALL-E', 'Andrew Stanton', 104),        ('Ratatouille', 'Brad Bird', 125),        ('Up', 'Pete Docter', 101),        ('Brave', 'Brenda Chapman', 102),        ('Monsters University', 'Dan Scanlon', 110),        ('Cars 2', 'John Lasseter', 120),        ('Finding Nemo', 'Andrew Stanton', 107),        ('Toy Story', 'John Lasseter', 61),        ('The Incredibles', 'Brad Bird', 126);","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех фильмах: название, имя и фамилия режиссера, продолжительность.  При этом в результирующей таблице продолжительность каждого фильма должна быть переведена в часы и минуты и указана в поле с псевдонимом timing в следующем формате:  <часы>:<минуты> Более того, значения часов и минут, представленные однозначными числами, должны быть предварены одним незначащим нулем.",20,4,"select title, director, concat(lpad(running_time div 60, 2, '0'), ':', lpad(running_time mod 60, 2, '0')) as timing from Films order by running_time desc","SELECT title,        director,        CONCAT_WS(            ':',            LPAD(running_time DIV 60, 2, 0),            LPAD(running_time MOD 60, 2, 0)        ) AS timing FROM Films ORDER BY running_time DESC",
4.4. Числовые функции,"DROP TABLE IF EXISTS Ranges; CREATE TABLE Ranges (     id INT PRIMARY KEY AUTO_INCREMENT,     a  INT,     b  INT );  INSERT INTO Ranges (a, b) VALUES (0, 180),        (-1, 1),        (-10, 10),        (-90, 90),        (10, 100);","Напишите запрос, который извлекает из предложенной базы данных границы всех диапазонов, а также для каждого диапазона определяет случайное целое число из этого диапазона (включая граничные значения).  При этом в результирующей таблице границы каждого диапазона должны быть указаны в одном поле с псевдонимом range в следующем формате:  [<левая граница>; <правая граница>]",40,7,"select concat('[', a, ';', b, ']') as 'range', round(a + rand() * (b - a)) as random_value from Ranges order by id",,
4.5. Числовые функции,"DROP TABLE IF EXISTS PrimeNumbers; CREATE TABLE PrimeNumbers (     num INT );  INSERT INTO PrimeNumbers (num) VALUES (2),        (3),        (5),        (7),        (11),        (13),        (17),        (19),        (23),        (29);","Напишите запрос, который извлекает из предложенной базы данных все простые числа, а также представляет каждое из них в двоичной, восьмеричной и шестнадцатеричной системах счисления.",10,1,"select num, conv(num, 10, 2) as bin,             conv(num, 10, 8) as oct,             conv(num, 10, 16) as hex from PrimeNumbers order by num desc",,
4.5. Числовые функции,"DROP TABLE IF EXISTS Angles; CREATE TABLE Angles (     angle INT PRIMARY KEY );  INSERT INTO Angles (angle) VALUES (0),        (30),        (45),        (60),        (90),        (120),        (135),        (150),        (180),        (210),        (225),        (240),        (270),        (300),        (315),        (330),        (360);","Напишите запрос, который извлекает из предложенной базы градусные меры всех углов, а также вычисляет синус и косинус каждого угла.",15,3,"select concat(angle, '°') as x,         round(sin(radians(angle)), 1) as 'sin(x)',        round(cos(radians(angle)), 1) as 'cos(x)' from Angles",,
4.5. Числовые функции,"DROP TABLE IF EXISTS Movies; CREATE TABLE Movies (     id          INT PRIMARY KEY AUTO_INCREMENT,     title       VARCHAR(40),     flickmetrix INT,     metacritic  INT,     imdb        INT,     letterboxd  INT,     kinopoisk   INT );  INSERT INTO Movies (title, flickmetrix, metacritic, imdb, letterboxd, kinopoisk) VALUES ('The Godfather', 95, 100, 92, 92, 87),        ('Parasite', 92, 96, 85, 92, 80),        ('Pulp Fiction', 90, 94, 89, 86, 87),        ('Spirited Away', 90, 96, 86, 90, 85),        ('Alien', 88, 89, 85, 86, 79),        ('The Dark Knight', 88, 84, 90, 89, 85),        ('Spider-Man: Across the Spider-Verse', 87, 86, 87, 90, 85),        ('No Country for Old Men', 87, 92, 82, 86, 72); "," Напишите запрос, который извлекает из предложенной базы данных названия всех фильмов, а также определяет среднюю оценку каждого фильма, при этом не учитывая самую высокую и самую низкую оценки.",20,3,"select title, round((flickmetrix + metacritic + imdb + letterboxd + kinopoisk - least(flickmetrix, metacritic, imdb, letterboxd, kinopoisk) - greatest(flickmetrix, metacritic, imdb, letterboxd, kinopoisk))/3, 2) as average_rating from Movies order by round((flickmetrix + metacritic + imdb + letterboxd + kinopoisk - least(flickmetrix, metacritic, imdb, letterboxd, kinopoisk) - greatest(flickmetrix, metacritic, imdb, letterboxd, kinopoisk))/3, 2) desc, title",,
4.6. Функции даты и времени.,"DROP TABLE IF EXISTS Staff; CREATE TABLE Staff (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     hire_year  YEAR,     hire_day   INT,     salary     INT );  INSERT INTO Staff (name, surname, hire_year, hire_day, salary) VALUES ('Larry', 'Page', 1998, 190, 100000),        ('Sergey', 'Brin', 2019, 319, 110000),        ('Sundar', 'Pichai', 2009, 313, 130000),        ('Ruth', 'Porat', 2005, 330, 90000),        ('Sundar', 'Nadella', 1995, 8, 125000),        ('Jeff', 'Bezos', 2003, 131, 85000),        ('Marissa', 'Mayer', 2007, 267, 95000),        ('Susan', 'Wojcicki', 1988, 124, 120000),        ('Eric', 'Schmidt', 1991, 321, 115000),        ('Sheryl', 'Sandberg', 2012, 201, 90000); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех сотрудниках компании: имя, фамилия, год приема на работу, порядковый номер дня приема на работу.  При этом в результирующей таблице имя и фамилия каждого сотрудника должны быть указаны в одном поле c псевдонимом staffer в следующем формате:  <имя> <фамилия> Год и порядковый номер дня приема на работу каждого сотрудника должны быть преобразованы в дату и указаны в одном поле c псевдонимом hire_date.",10,2,"select concat(name, ' ', surname) as staffer, makedate(hire_year, hire_day) as hire_date from Staff order by hire_date desc",,
4.6. Функции даты и времени.,"DROP TABLE IF EXISTS Staff; CREATE TABLE Staff (     id        INT AUTO_INCREMENT PRIMARY KEY,     name      VARCHAR(20),     surname   VARCHAR(20),     hire_date DATE,     salary    INT );  INSERT INTO Staff (name, surname, hire_date, salary) VALUES ('Larry', 'Page', '1998-07-09', 100000),        ('Sergey', 'Brin', '2019-11-15', 110000),        ('Sundar', 'Pichai', '2009-11-09', 130000),        ('Ruth', 'Porat', '2005-11-26', 90000),        ('Sundar', 'Nadella', '1995-01-08', 125000),        ('Jeff', 'Bezos', '2003-05-11', 85000),        ('Marissa', 'Mayer', '2007-09-24', 95000),        ('Susan', 'Wojcicki', '1988-05-03', 120000),        ('Eric', 'Schmidt', '1991-11-17', 115000),        ('Sheryl', 'Sandberg', '2012-07-19', 90000); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех сотрудниках компании: имя, фамилия, дата приема на работу.  При этом в результирующей таблице имя и фамилия каждого сотрудника должны быть указаны в одном поле c псевдонимом staffer в следующем формате:  <имя> <фамилия> Дата приема на работу каждого сотрудника должна быть увеличена на 1 год и 6 месяцев.",10,2,"select concat(name, ' ', surname) as staffer, hire_date + interval '1 6' year_month as hire_date from Staff order by hire_date desc",,
4.6. Функции даты и времени.,"DROP TABLE IF EXISTS Staff; CREATE TABLE Staff (     id        INT AUTO_INCREMENT PRIMARY KEY,     name      VARCHAR(20),     surname   VARCHAR(20),     hire_date DATE,     salary    INT );  INSERT INTO Staff (name, surname, hire_date, salary) VALUES ('Larry', 'Page', '1998-07-09', 100000),        ('Sergey', 'Brin', '2019-11-15', 110000),        ('Sundar', 'Pichai', '2009-11-09', 130000),        ('Ruth', 'Porat', '2005-11-26', 90000),        ('Sundar', 'Nadella', '1995-01-08', 125000),        ('Jeff', 'Bezos', '2003-05-11', 85000),        ('Marissa', 'Mayer', '2007-09-24', 95000),        ('Susan', 'Wojcicki', '1988-05-03', 120000),        ('Eric', 'Schmidt', '1991-11-17', 115000),        ('Sheryl', 'Sandberg', '2012-07-19', 90000); ","Согласно правилам компании Google, первую заработную плату сотрудники компании получают в последний день первого месяца работы. Например, сотрудник, который устроился на работу 2007-09-24, первую заработную плату получит 2007-09-30.  Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех сотрудников компании, а также для каждого сотрудника указывает дату получения им первой заработной платы.",10,2,"select concat(name, ' ', surname) as staffer, last_day(hire_date) as first_salary from Staff order by salary desc",,
4.6. Функции даты и времени.,"DROP TABLE IF EXISTS Staff; CREATE TABLE Staff (     id        INT AUTO_INCREMENT PRIMARY KEY,     name      VARCHAR(20),     surname   VARCHAR(20),     hire_date DATE,     salary    INT );  INSERT INTO Staff (name, surname, hire_date, salary) VALUES ('Larry', 'Page', '1998-07-09', 100000),        ('Sergey', 'Brin', '2019-11-16', 110000),        ('Sundar', 'Pichai', '2009-11-09', 130000),        ('Ruth', 'Porat', '2005-11-26', 90000),        ('Sundar', 'Nadella', '1995-01-08', 125000),        ('Jeff', 'Bezos', '2003-05-11', 85000),        ('Marissa', 'Mayer', '2007-09-24', 95000),        ('Susan', 'Wojcicki', '1988-05-03', 120000),        ('Eric', 'Schmidt', '1991-11-17', 115000),        ('Sheryl', 'Sandberg', '2012-07-19', 90000); ","Согласно правилам компании Google, первую заработную плату сотрудники компании получают в последний день первого месяца работы. Например, сотрудник, который устроился на работу 2007-09-24, первую заработную плату получит 2007-09-30.  Напишите запрос, извлекающий из предложенной базы данных имена и фамилии сотрудников, которые на момент получения своей первой заработной платы проработали в компании меньше 15 дней.",15,3,"select concat(name, ' ', surname) as staffer from Staff where (to_days(last_day(hire_date)) - to_days(hire_date) + 1) < 15  order by staffer","SELECT CONCAT_WS(' ', name, surname) AS staffer FROM Staff WHERE LAST_DAY(hire_date) - INTERVAL 14 DAY < hire_date ORDER BY staffer",
4.6. Функции даты и времени.,"DROP TABLE IF EXISTS Staff; CREATE TABLE Staff (     id        INT AUTO_INCREMENT PRIMARY KEY,     name      VARCHAR(20),     surname   VARCHAR(20),     hire_date DATE,     salary    INT );  INSERT INTO Staff (name, surname, hire_date, salary) VALUES ('Larry', 'Page', '1998-09-04', 100000),        ('Sergey', 'Brin', '1998-09-04', 110000),        ('Sundar', 'Pichai', '2009-11-09', 130000),        ('Ruth', 'Porat', '2005-11-26', 90000),        ('Sundar', 'Nadella', '1998-11-24', 125000),        ('Jeff', 'Bezos', '1998-11-22', 85000),        ('Marissa', 'Mayer', '2007-09-24', 95000),        ('Susan', 'Wojcicki', '1998-11-23', 120000),        ('Eric', 'Schmidt', '2019-11-15', 115000),        ('Sheryl', 'Sandberg', '2012-07-19', 90000); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии сотрудников, которые на 2023-07-15 проработали в компании больше 9000 дней.",10,3,"select concat(name, ' ', surname) as staffer from Staff where (to_days('2023-07-15') - to_days(hire_date)) > 9000 order by hire_date","SELECT CONCAT(name, ' ', surname) AS staffer FROM Staff WHERE ('2023-07-15' - INTERVAL 9000 DAY) > hire_date ORDER BY hire_date",
4.7. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     actor      VARCHAR(50),     birth_date DATETIME );  INSERT INTO Actors (actor, birth_date) VALUES ('Johnny Depp', '1963-06-09 19:10:00'),        ('Natalie Portman', '1981-06-09 06:15:00'),        ('Scarlett Johansson', '1984-11-22 18:30:00'),        ('Angelina Jolie', '1975-06-04 05:55:00'),        ('Brad Pitt', '1963-12-18 10:10:00'),        ('Meryl Streep', '1949-06-22 08:05:00'),        ('Leonardo DiCaprio', '1974-11-11 02:47:00'),        ('Tom Hanks', '1956-07-09 15:20:00'),        ('Jennifer Aniston', '1969-02-11 14:25:00'),        ('Denzel Washington', '1954-12-28 01:40:00'); ","Напишите запрос, который извлекает из предложенной базы данных всю информацию о каждом актере, а также разбивает все составные данные (имя и фамилия, дата и время рождения) по отдельным полям.",10,1,"select id, left(actor, locate(' ', actor) - 1) as name, substring_index(actor, ' ', -1) as surname, date(birth_date) as 'birth_date', time(birth_date) as birth_time from Actors","SELECT id,        SUBSTRING_INDEX(actor, ' ', 1)  AS name,        SUBSTRING_INDEX(actor, ' ', -1) AS surname,        DATE(birth_date)                AS birth_date,        TIME(birth_date)                AS birth_time FROM Actors",
4.7. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     birth_date DATE,     birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES   ('Johnny', 'Depp', '1963-06-09', '19:10:00'),   ('Natalie', 'Portman', '1981-06-09', '18:00:00'),   ('Scarlett', 'Johansson', '1984-11-22', '18:30:00'),   ('Angelina', 'Jolie', '1975-06-04', '05:55:00'),   ('Brad', 'Pitt', '1963-12-18', '10:00:00'),   ('Meryl', 'Streep', '1949-06-22', '08:05:00'),   ('Leonardo', 'DiCaprio', '1974-11-11', '09:55:00'),   ('Tom', 'Hanks', '1956-07-09', '15:20:00'),   ('Jennifer', 'Aniston', '1969-02-11', '14:25:00'),   ('Denzel', 'Washington', '1954-12-28', '10:40:00'); ","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, время рождения), которые родились в 8, 10 или 18 часов.",10,1,"select name, surname, birth_time from Actors where hour(birth_time) = 8 or hour(birth_time) = 10 or hour(birth_time) = 18 order by birth_time","SELECT name, surname, birth_time FROM Actors WHERE HOUR(birth_time) IN (8, 10, 18) ORDER BY birth_time",
4.7. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     birth_date DATE,     birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Paul', 'Walker', '1973-09-12', '19:10:00'),        ('Emma', 'Wiklund', '1968-09-13', '06:15:00'),        ('Scarlett', 'Johansson', '1984-11-22', '18:30:00'),        ('Angelina', 'Jolie', '1975-06-04', '05:55:00'),        ('Trevor', 'Duke-Moretz', '1986-09-13', '10:10:00'),        ('Meryl', 'Streep', '1949-06-22', '08:05:00'),        ('Tyler', 'Hoechlin', '1987-09-11', '02:47:00'),        ('Tom', 'Hanks', '1956-07-09', '15:20:00'),        ('Jennifer', 'Aniston', '1969-02-11', '14:25:00'),        ('Andrew', 'Lincoln', '1973-09-14', '01:40:00'); ","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения), которые родились раньше Дня программиста.",5,1,"select name, surname, birth_date from Actors where dayofyear(birth_date) < 256 order by birth_date",,
4.7. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     birth_date DATE,     birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Johnny', 'Depp', '1963-06-09', '19:10:00'),        ('Natalie', 'Portman', '1981-06-09', '06:15:00'),        ('Scarlett', 'Johansson', '1984-11-22', '18:30:00'),        ('Angelina', 'Jolie', '1975-06-04', '05:55:00'),        ('Brad', 'Pitt', '1963-12-18', '10:10:00'),        ('Meryl', 'Streep', '1949-06-22', '08:05:00'),        ('Leonardo', 'DiCaprio', '1974-11-11', '02:47:00'),        ('Tom', 'Hanks', '1956-07-09', '15:20:00'),        ('Jennifer', 'Aniston', '1969-02-11', '14:25:00'),        ('Denzel', 'Washington', '1954-12-28', '01:40:00'); ","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения), которые родились в среду.",5,1,"select name, surname, birth_date from Actors where weekday(birth_date) = 2 order by birth_date",,
4.7. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     birth_date DATE,     birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Kristen', 'Stewart', '1990-04-09', '02:47:00'),        ('Chris', 'Hemsworth', '1983-08-11', '08:05:00'),        ('Zac', 'Efron', '1974-10-18', '02:47:00'),        ('Tom', 'Hanks', '1956-07-09', '15:20:00'),        ('Jennifer', 'Aniston', '1969-02-11', '14:25:00'),        ('Natalie', 'Portman', '1981-06-09', '06:15:00'),        ('Scarlett', 'Johansson', '1984-11-22', '18:30:00'),        ('Angelina', 'Jolie', '1975-06-04', '05:55:00'),        ('Charlize', 'Theron', '1975-08-07', '19:10:00'),        ('Denzel', 'Washington', '1954-12-28', '01:40:00'),        ('Kate', 'Winslet', '1975-09-05', '10:10:00'),        ('Elizabeth', 'Olsen', '1989-02-16', '02:47:00'); ","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения), которые родились позже 1975 года во 2 или 4 квартале.",10,3,"select name, surname, birth_date from Actors where year(birth_date) > 1975 and (quarter(birth_date) = 2  or quarter(birth_date) = 4) order by birth_time desc","SELECT name, surname, birth_date FROM Actors WHERE YEAR(birth_date) > 1975 AND QUARTER(birth_date) IN (2, 4) ORDER BY birth_time DESC",
4.7. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     birth_date DATE,     birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Robbie', 'Williams', '1974-02-13', '12:10:00'),        ('Tom', 'Cruise', '1990-10-11', '08:25:00'),        ('Christian', 'Bale', '1990-12-11', '15:40:00'),        ('Chris', 'Hemsworth', '1983-08-11', '22:00:00'),        ('Meryl', 'Streep', '1949-07-20', '14:30:00'),        ('Naomi', 'Campbell', '1970-05-22', '09:30:00'),        ('Cate', 'Blanchett', '1969-03-21', '13:45:00'),        ('Joaquin', 'Phoenix', '1990-05-14', '13:30:00'),        ('Johnny', 'Depp', '1963-06-09', '11:15:00'),        ('Brad', 'Pitt', '1963-07-18', '09:30:00'),        ('Leonardo', 'DiCaprio', '1974-11-11', '10:45:00'),        ('Will', 'Smith', '1968-09-25', '08:50:00'),        ('Penelope', 'Cruz', '1956-06-14', '12:00:00'),        ('Tom', 'Hanks', '1956-07-10', '12:00:00'),        ('Julianne', 'Moore', '1960-01-11', '14:20:00'),        ('Emma', 'Watson', '1990-04-15', '10:10:00');","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения), которые родились с мая по июль включительно.  При этом в результирующей таблице дата рождения каждого актера должна быть записана в следующем формате:  <день месяца> <полное название месяца> <год>",10,2,"select name, surname, concat(day(birth_date), ' ', monthname(birth_date), ' ', year(birth_date)) as birth_date from Actors where month(birth_date) in(5, 6, 7)","SELECT name, surname,        CONCAT_WS(' ',                  DAY(birth_date),                  MONTHNAME(birth_date),                  YEAR(birth_date)                 ) AS birth_date FROM Actors WHERE MONTH(birth_date) BETWEEN 5 AND 7",
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (    id                INT AUTO_INCREMENT PRIMARY KEY,    customer_name     VARCHAR(50),    order_time        DATETIME,    spent_on_delivery TIME );  INSERT INTO Orders (customer_name, order_time, spent_on_delivery) VALUES ('John', '2023-10-23 12:00:00', '01:35:00'),        ('Alice', '2023-10-23 14:30:00', '03:20:00'),        ('Bob', '2023-10-23 08:45:00', '04:50:00'),        ('Eve', '2023-10-24 15:30:00', '02:15:00'),        ('Charlie', '2023-10-24 09:00:00', '03:30:00'),        ('Grace', '2023-10-24 10:30:00', '05:45:00'),        ('Daniel', '2023-10-24 14:15:00', '04:10:00'),        ('Fiona', '2023-10-25 11:00:00', '02:55:00'),        ('George', '2023-10-25 09:30:00', '03:40:00'),        ('Helen', '2023-10-26 07:45:00', '04:20:00'),        ('Ivan', '2023-10-26 11:30:00', '03:25:00'),        ('Ahti', '2023-11-24 10:00:00', '01:15:00'),        ('Julia', '2023-10-27 12:00:00', '05:30:00'),        ('Kevin', '2023-10-30 10:15:00', '03:55:00'),        ('Linda', '2023-11-01 10:30:00', '05:10:00'),        ('Michael', '2023-11-01 12:45:00', '02:15:00'); "," Напишите запрос, извлекающий из предложенной базы данных информацию о заказе (имя заказчика, время доставки), который 24 октября 2023 года был доставлен позже всех.",10,2,"select customer_name, addtime(order_time, spent_on_delivery) as delivery_datetime from Orders where date(addtime(order_time, spent_on_delivery)) = '2023-10-24' order by delivery_datetime desc limit 1","SELECT customer_name, ADDTIME(order_time, spent_on_delivery) as delivery_datetime FROM Orders WHERE ADDTIME(order_time, spent_on_delivery) = (SELECT MAX(ADDTIME(order_time, spent_on_delivery)) FROM Orders WHERE DATE(order_time) = '2023-10-24');",
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Tasks; CREATE TABLE Tasks (    id         INT AUTO_INCREMENT PRIMARY KEY,    executor   VARCHAR(20),    task       VARCHAR(100),    task_start DATE,    task_end   DATE );  INSERT INTO Tasks (executor, task, task_start, task_end) VALUES ('Larry Page', 'Develop new search algorithm', '2023-10-23', '2023-10-25'),        ('Sergey Brin', 'Analyze user data', '2023-10-23', '2023-10-28'),        ('Sundar Pichai', 'Launch new product', '2023-10-24', '2023-11-03'),        ('Ruth Porat', 'Financial analysis', '2023-10-24', '2023-10-26'),        ('Eric Schmidt', 'Meet with investors', '2023-10-25', '2023-10-31'),        ('Susan Wojcicki', 'Content strategy', '2023-10-25', '2023-10-31'),        ('Hiroshi Lockheimer', 'Mobile platform development', '2023-10-26', '2023-11-03'),        ('Thomas Kurian', 'Cloud services expansion', '2023-10-26', '2023-10-28'),        ('Jeff Dean', 'Machine learning research', '2023-10-27', '2023-11-01'),        ('Aparna Chennapragada', 'User experience design', '2023-10-28', '2023-11-03'); ","Согласно статистике компании Google, на выполнение каждой задачи уходит минимум один день. В день начала выполнения задачи, а также в день окончания ее выполнения задача считается активной. Например, задача, выполнение которой началось 2023-11-15 и закончилось 2023-11-18, считается выполненной за 4 дня.  Напишите запрос, извлекающий из предложенной базы данных информацию о задаче (описание, имя и фамилия выполняющего, количество потраченных на выполнение дней), которая была выполнена за наибольшее количество дней.",10,2,"select task, executor, (timestampdiff(day, task_start, task_end) + 1) as days_spent from Tasks order by days_spent desc limit 1","SELECT task, executor,        DATEDIFF(task_end, task_start) + 1 AS days_spent FROM Tasks ORDER BY days_spent DESC LIMIT 1",
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Users; CREATE TABLE Users (     id                 INT AUTO_INCREMENT PRIMARY KEY,     username           VARCHAR(50),     subscription_start DATE,     subscription_end   DATE );  INSERT INTO Users (username, subscription_start, subscription_end) VALUES ('s1mple', '2023-10-23', '2023-11-24'),        ('NiKo', '2023-10-25', '2023-11-03'),        ('device', '2023-10-27', '2023-12-20'),        ('EliGE', '2023-10-29', '2023-11-30'),        ('ZywOo', '2023-11-01', '2024-11-01'),        ('Magisk', '2023-11-03', '2024-12-04'),        ('stewie2k', '2023-11-05', '2023-12-26'),        ('coldzera', '2023-11-10', '2023-11-18'),        ('dupreeh', '2023-10-19', '2023-12-10'),        ('olofmeister', '2023-09-11', '2023-12-12'),        ('scream', '2023-12-13', '2023-12-14'),        ('kennyS', '2023-11-15', '2023-12-16'),        ('f0rest', '2023-10-17', '2023-12-18'),        ('GuardiaN', '2023-12-19', '2024-01-02'),        ('freakazoid', '2023-11-21', '2023-12-22'); "," Напишите запрос, который извлекает из предложенной базы данных псевдонимы пользователей платформы, а также определяет, на сколько дней оформил подписку каждый пользователь. При этом в результирующую таблицу должны быть добавлены только те пользователи, которые оформили подписку минимум на 15 дней.",15,2,"select username, (timestampdiff(day, subscription_start, subscription_end) + 1) as days from Users where (timestampdiff(day, subscription_start, subscription_end) + 1) >= 15 order by days desc, username",,
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Tasks; CREATE TABLE Tasks (    id         INT AUTO_INCREMENT PRIMARY KEY,    executor   VARCHAR(20),    task       VARCHAR(100),    task_start DATETIME,    task_end   DATETIME );  INSERT INTO Tasks (executor, task, task_start, task_end) VALUES ('Larry Page', 'Develop new search algorithm', '2023-10-23 12:00:00', '2023-10-25 18:00:00'),        ('Sergey Brin', 'Analyze user data', '2023-10-23 12:00:00', '2023-10-28 18:00:00'),        ('Sundar Pichai', 'Launch new product', '2023-10-24 15:00:00', '2023-10-24 16:00:00'),        ('Ruth Porat', 'Financial analysis', '2023-10-24 14:30:00', '2023-10-26 20:00:00'),        ('Eric Schmidt', 'Meet with investors', '2023-10-24 15:00:00', '2023-10-24 15:05:00'),        ('Susan Wojcicki', 'Content strategy', '2023-10-25 07:0:00', '2023-10-25 17:15:00'),        ('Hiroshi Lockheimer', 'Mobile platform development', '2023-10-26', '2023-11-03'),        ('Thomas Kurian', 'Cloud services expansion', '2023-10-27 09:30:00', '2023-10-27 15:45:00'),        ('Jeff Dean', 'Machine learning research', '2023-10-30 10:15:00', '2023-10-30 16:45:00'),        ('Aparna Chennapragada', 'User experience design', '2023-10-29 12:00:00', '2023-11-04 18:00:00'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о задаче (описание, имя и фамилия выполняющего, потраченное на выполнение время), которая была выполнена за наименьшее количество времени.",10,2,"select task, executor, timediff(task_end, task_start) as time_spent from Tasks order by time_spent limit 1",,
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Staff; CREATE TABLE Staff (   id          INT AUTO_INCREMENT PRIMARY KEY,   name        VARCHAR(20),   surname     VARCHAR(20),   work_start  TIME,   work_end    TIME,   break_start TIME,   break_end   TIME );  INSERT INTO Staff (name, surname, work_start, work_end, break_start, break_end) VALUES ('Sundar', 'Pichai', '7:00:00', '17:00:00', '12:00:00', '13:00:00'),        ('Sergey', 'Brin', '8:00:00', '16:30:00', '11:30:00', '12:30:00'),        ('Larry', 'Page', '6:30:00', '15:45:00', '12:15:00', '12:45:00'),        ('Ruth', 'Porat', '8:15:00', '17:15:00', '12:30:00', '13:30:00'),        ('Eric', 'Schmidt', '7:30:00', '17:45:00', '12:00:00', '13:00:00'),        ('Susan', 'Wojcicki', '8:30:00', '16:30:00', '12:45:00', '13:45:00'),        ('Hiroshi', 'Lockheimer', '7:45:00', '17:15:00', '12:15:00', '13:15:00'),        ('Thomas', 'Kurian', '7:00:00', '16:30:00', '12:30:00', '13:30:00'),        ('Jeff', 'Dean', '8:15:00', '17:00:00', '12:45:00', '13:45:00'),        ('Aparna', 'Chennapragada', '7:30:00', '17:15:00', '12:00:00', '13:00:00'); "," Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех сотрудников компании, а также определяет, сколько времени каждый сотрудник проводит за работой.",15,3,"select concat_ws(' ', name, surname) as staffer,  addtime(timediff(break_start, work_start), timediff(work_end, break_end)) as work_time from Staff order by work_time desc, staffer","SELECT CONCAT_WS(' ', name, surname) AS staffer,        SUBTIME(            TIMEDIFF(work_end, work_start),            TIMEDIFF(break_end, break_start)        ) AS work_time FROM Staff ORDER BY work_time DESC, staffer",
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (     id         INT AUTO_INCREMENT PRIMARY KEY,     name       VARCHAR(20),     surname    VARCHAR(20),     birth_date DATE );  INSERT INTO Actors (name, surname, birth_date) VALUES ('Paul', 'Walker', '1973-09-12'),        ('Emma', 'Wiklund', '1968-09-13'),        ('Scarlett', 'Johansson', '1984-11-22'),        ('Angelina', 'Jolie', '1975-06-04'),        ('Trevor', 'Duke-Moretz', '1986-09-13'),        ('Meryl', 'Streep', '1949-06-22'),        ('Tyler', 'Hoechlin', '1987-09-11'),        ('Tom', 'Hanks', '1956-07-09'),        ('Jennifer', 'Aniston', '1969-02-11'),        ('Andrew', 'Lincoln', '1973-09-14'); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии актеров, а также определяет текущий возраст каждого актера. При этом вычисление текущего возраста должно выполняться без учета каких-либо часовых поясов.  ",10,2,"select name, surname, timestampdiff(year, birth_date, curdate()) as age from Actors order by age desc","SELECT name, surname,        DATEDIFF(UTC_DATE(),birth_date) div 365 as age FROM Actors ORDER BY age DESC;",
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (    id         INT AUTO_INCREMENT PRIMARY KEY,    name       VARCHAR(20),    surname    VARCHAR(20),    birth_date DATE );  INSERT INTO Actors (name, surname, birth_date) VALUES ('Paul', 'Walker', '1973-09-12'),        ('Emma', 'Wiklund', '1968-09-13'),        ('Scarlett', 'Johansson', '1984-11-22'),        ('Angelina', 'Jolie', '1975-06-04'),        ('Trevor', 'Duke-Moretz', '1986-09-13'),        ('Gwyneth', 'Paltrow', '1972-09-27'),        ('Meryl', 'Streep', '1949-06-22'),        ('Leonardo', 'DiCaprio', '1972-09-13'),        ('Tyler', 'Hoechlin', '1987-09-11'),        ('Tom', 'Hanks', '1956-07-09'),        ('Jennifer', 'Aniston', '1969-02-11'),        ('Andrew', 'Lincoln', '1973-09-14'); ","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения), которым на 12 сентября 2023 года больше 50 полных лет.",10,2,"select name, surname, birth_date from Actors where timestampdiff(year, birth_date, '2022-09-15') > 50 order by birth_date desc","SELECT     name,     surname,     birth_date FROM     Actors WHERE     '2023-09-12' > ADDDATE(birth_date, INTERVAL 51 YEAR) ORDER BY     birth_date DESC;",
4.8. Функции даты и времени.,"DROP TABLE IF EXISTS Rental; CREATE TABLE Rental (    id         INT PRIMARY KEY,    name       VARCHAR(255),    car_brand  VARCHAR(255),    rent_start DATETIME,    rent_end   DATETIME );  INSERT INTO Rental (id, name, car_brand, rent_start, rent_end) VALUES (1, 'John', 'BMW', '2023-10-23 12:30:00', '2023-10-23 18:00:00'),        (2, 'Alice', 'Honda', '2023-10-23 10:00:00', '2023-10-23 14:30:00'),        (3, 'Bob', 'Audi', '2023-10-24 14:30:00', '2023-10-24 17:00:00'),        (4, 'Charlie', 'BMW', '2023-10-25 08:45:00', '2023-10-25 12:30:00'),        (5, 'Dave', 'Honda', '2023-10-26 15:30:00', '2023-10-26 20:15:00'),        (6, 'Emily', 'Audi', '2023-10-26 09:00:00', '2023-10-26 15:45:00'),        (7, 'Frank', 'Mercedes', '2023-10-27 11:15:00', '2023-11-27 17:00:00'),        (8, 'Grace', 'Honda', '2023-10-28 08:00:00', '2023-10-28 13:45:00'),        (9, 'Hank', 'Audi', '2023-10-28 13:30:00', '2023-10-28 18:45:00'),        (10, 'Irene', 'BMW', '2023-10-29 14:00:00', '2023-10-29 19:30:00'),        (11, 'Jack', 'Honda', '2023-10-30 07:45:00', '2023-10-30 12:15:00'),        (12, 'Kate', 'BMW', '2023-10-31 16:30:00', '2023-10-31 21:00:00'),        (13, 'Lucas', 'Audi', '2023-11-01 10:15:00', '2023-11-01 14:45:00'),        (14, 'Mary', 'Mercedes', '2023-11-02 13:00:00', '2023-11-02 17:30:00'),        (15, 'Nina', 'BMW', '2023-11-03 09:30:00', '2023-11-03 14:00:00'); ","Сервис Sixt предлагает в аренду автомобили различных марок по цене 10 евро в час, причем количество минут и секунд во время выставления счета за аренду не учитывается. Например, если автомобиль был арендован на время 05:50:10, за него будет выставлен счет в 50 евро.  Напишите запрос, который извлекает из предложенной базы данных имена арендаторов, а также определяет, на какое время каждый арендатор взял автомобиль в аренду и какую сумму он за это заплатил. При этом в результирующую таблицу должны быть добавлены только те арендаторы, которые взяли в аренду автомобиль марки BMW.",20,4,"select name, timediff(rent_end, rent_start) as rent_time, concat(timestampdiff(hour, rent_start, rent_end)*10, '€') as rent_amount from Rental where car_brand = 'BMW' order by rent_time, name","SELECT     name,     SUBTIME(         TIME(rent_end),          TIME(rent_start)     ) AS rent_time,     CONCAT(         HOUR(SUBTIME(             TIME(rent_end),              TIME(rent_start))) * 10,          '€'     ) AS rent_amount FROM     Rental WHERE     car_brand = 'BMW' ORDER BY     rent_time,     name",
4.9. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (    id         INT AUTO_INCREMENT PRIMARY KEY,    name       VARCHAR(20),    surname    VARCHAR(20),    birth_date DATE,    birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Paul', 'Walker', '1973-09-12', '19:10:00'),        ('Emma', 'Wiklund', '1968-09-13', '06:15:00'),        ('Scarlett', 'Johansson', '1984-11-22', '18:30:00'),        ('Angelina', 'Jolie', '1975-06-04', '05:55:00'),        ('Trevor', 'Duke-Moretz', '1986-09-13', '10:10:00'),        ('Meryl', 'Streep', '1949-06-22', '08:05:00'),        ('Tyler', 'Hoechlin', '1987-09-11', '02:47:00'),        ('Tom', 'Hanks', '1956-07-09', '15:20:00'),        ('Jennifer', 'Aniston', '1969-02-11', '14:25:00'),        ('Andrew', 'Lincoln', '1973-09-14', '01:40:00');","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения, время рождения), которые родились в первые 14 дней месяца.  При этом в результирующей таблице дата рождения каждого актера должна быть записана в следующем формате:  <день месяца>.<номер месяца>.<год> Время рождения каждого актера должно быть записано в следующем формате:  <часы>:<минуты>",10,1,"select name, surname, date_format(birth_date, '%d.%m.%Y') as birth_date, date_format(birth_time, '%H:%i') as birth_time from Actors where day(birth_date) <= 14","SELECT name, surname,         DATE_FORMAT(birth_date, '%d.%m.%Y') AS birth_date,         TIME_FORMAT(birth_time, '%H:%i') AS birth_time FROM Actors WHERE DAY(birth_date) < 15",
4.9. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (    id         INT AUTO_INCREMENT PRIMARY KEY,    name       VARCHAR(20),    surname    VARCHAR(20),    birth_date DATE,    birth_time TIME );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Paul', 'Walker', '1973-09-12', '19:10:00'),        ('Emma', 'Wiklund', '1968-09-13', '06:15:00'),        ('Scarlett', 'Johansson', '1984-11-22', '18:30:00'),        ('Angelina', 'Jolie', '1975-06-04', '05:55:00'),        ('Trevor', 'Duke-Moretz', '1986-09-13', '10:10:00'),        ('Meryl', 'Streep', '1949-06-22', '08:05:00'),        ('Tyler', 'Hoechlin', '1987-09-11', '02:47:00'),        ('Tom', 'Hanks', '1956-07-09', '15:20:00'),        ('Jennifer', 'Aniston', '1969-02-11', '14:25:00'),        ('Andrew', 'Lincoln', '1973-09-14', '01:40:00');","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения, время рождения), которые родились с 1969 по 1975 год включительно.  При этом дата и время рождения каждого актера должны быть указаны в одном поле с псевдонимом birth_datetime в следующем формате:  <день месяца> <полное название месяца> <год>, <часы>:<минуты>",10,2,"select name, surname, date_format(timestamp(birth_date, birth_time), '%d %M %Y, %H:%i') as birth_datetime from Actors where year(birth_date) between 1969 and 1975","SELECT name, surname,         CONCAT_WS(            ', ',             DATE_FORMAT(birth_date, '%d %M %Y'),             TIME_FORMAT(birth_time, '%H:%i')        )         AS birth_datetime FROM Actors WHERE YEAR(birth_date) BETWEEN 1969 AND 1975",
4.9. Функции даты и времени.,"DROP TABLE IF EXISTS Actors; CREATE TABLE Actors (    id         INT AUTO_INCREMENT PRIMARY KEY,    name       VARCHAR(20),    surname    VARCHAR(20),    birth_date VARCHAR(20),    birth_time VARCHAR(30) );  INSERT INTO Actors (name, surname, birth_date, birth_time) VALUES ('Paul', 'Walker', '12 Sep 1973', 'Hours: 19, Minutes: 10'),        ('Emma', 'Wiklund', '13 Sep 1968', 'Hours: 6, Minutes: 15'),        ('Scarlett', 'Johansson', '22 Nov 1984', 'Hours: 18, Minutes: 30'),        ('Angelina', 'Jolie', '04 Jun 1975', 'Hours: 5, Minutes: 55'),        ('Trevor', 'Duke-Moretz', '13 Sep 1986', 'Hours: 10, Minutes: 10'),        ('Meryl', 'Streep', '22 Jun 1949', 'Hours: 8, Minutes: 5'),        ('Tyler', 'Hoechlin', '11 Sep 1987', 'Hours: 2, Minutes: 47'),        ('Tom', 'Hanks', '09 Jul 1956', 'Hours: 15, Minutes: 20'),        ('Jennifer', 'Aniston', '11 Feb 1969', 'Hours: 14, Minutes: 25'),        ('Andrew', 'Lincoln', '14 Sep 1973', 'Hours: 1, Minutes: 40'); ","Напишите запрос, извлекающий из предложенной базы данных информацию об актерах (имя, фамилия, дата рождения, время рождения), которые родились в сентябре. При этом дата и время рождения каждого актера должны быть записаны в формате ISO.",20,4,"select name, surname, str_to_date(birth_date, '%d %b %Y') as birth_date, str_to_date(birth_time, 'Hours: %H, Minutes: %i') as birth_time from Actors  where month(str_to_date(birth_date, '%d %b %Y')) = 09","SELECT name,         surname,        DATE_FORMAT(STR_TO_DATE(birth_date, '%d %b %Y'), GET_FORMAT(DATE, 'ISO')) as birth_date,        TIME_FORMAT(STR_TO_DATE(birth_time, 'Hours: %H, Minutes: %i'), GET_FORMAT(TIME, 'ISO')) as birth_time FROM Actors WHERE MONTH(STR_TO_DATE(birth_date, '%d %b %Y')) = 9",
4.10 Дополнительные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41);","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: имя, фамилия, страна рождения. При этом если страной рождения режиссера является England, то в результирующей таблице она должна остаться без изменений, если какая-либо другая страна — заменена на строку Other country.",5,1,"select name, surname, if(country = 'England', 'England', 'Other country') as country from Directors order by name","SELECT name, surname,        IF(country = 'England', country, 'Other country') AS country FROM Directors ORDER BY name",
4.10 Дополнительные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', NULL),        ('Martin', 'Scorsese', 'USA', NULL),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', NULL),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', NULL);","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех режиссерах: имя, фамилия, рейтинг. При этом если рейтинг режиссера не определен, в результирующей таблице он должен быть заменен на значение 0. ",10,2,"select name, surname, ifnull(rating, '0') as rating from Directors order by Directors.rating, name","SELECT name, surname,        COALESCE(rating , 0) AS rating  FROM Directors ORDER BY rating, name ",
4.10 Дополнительные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  INSERT INTO Directors (name, surname, country, rating) VALUES (NULL, 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', NULL, 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        (NULL, NULL, 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        (NULL, NULL, 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        (NULL, 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который извлекает из предложенной базы данных имена и рейтинги всех режиссеров. При этом если имя режиссера не определено, то в результирующей таблице оно должно быть заменено на его фамилию. Однако если фамилия режиссера также не определена, то в качестве его имени должна быть использована строка Unknown.",15,3,"SELECT COALESCE(name, surname, 'Unknown') AS director,        rating        FROM Directors ORDER BY rating DESC","select ifnull(name, ifnull(surname, 'Unknown')) as director, rating from Directors  order by rating desc",
4.10 Дополнительные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","При этом если страной рождения режиссера является USA, то в результирующей таблице его рейтинг должен быть увеличен на 10, если какая-либо другая страна — остаться без изменений. Более того, увеличенный рейтинг не должен быть больше 100. Например, если рейтинг режиссера равен 96, то после увеличения на 10 он должен стать равным 100.",30,5,"select name, surname, country, if(if(country = 'USA', rating + 10, rating) > 100, 100, if(country = 'USA', rating + 10, rating)) as rating from Directors order by rating desc, name","SELECT name, surname, country,        IF(country = 'USA', IF(rating + 10 > 100, 100, rating + 10), rating) AS rating FROM Directors ORDER BY rating DESC, name",
4.11 Условные конструкции ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   VARCHAR(20) );  INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 'D'),        ('Peter', 'Parker', 'A'),        ('Mary', 'Jane', 'D'),        ('Gwen', 'Stacy', 'B'),        ('Harry', 'Osborn', 'A'),        ('Ben', 'Reilly', 'E'),        ('Miles', 'Morales', 'A'),        ('John', 'Jameson', 'E'),        ('Curtis', 'Connors', 'B'),        ('Edward', 'Brock', 'C');","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех учениках: имя, фамилия, оценка за экзамен.  При этом в результирующей таблице оценка каждого ученика должна быть записана в виде ее числового эквивалента:  Буквенная оценка Числовая оценка A 5 B 4 C 3 D 2 E 1",15,1,"select name, surname,   case grade    when 'a' then 5    when 'b' then 4    when 'c' then 3    when 'd' then 2      when 'e' then 1   end as grade  from Math order by grade desc, name","SELECT   name,   surname,   LOCATE(grade, 'EDCBA') AS grade FROM   Math ORDER BY   grade DESC,   name ASC;",
4.11 Условные конструкции ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   VARCHAR(20) );  INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 'D'),        ('Peter', 'Parker', 'A'),        ('Mary', 'Jane', 'D'),        ('Gwen', 'Stacy', 'B'),        ('Harry', 'Osborn', 'A'),        ('Ben', 'Reilly', 'E'),        ('Miles', 'Morales', 'A'),        ('John', 'Jameson', 'E'),        ('Curtis', 'Connors', 'B'),        ('Edward', 'Brock', 'C');","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех учениках: имя, фамилия, оценка за экзамен.  При этом в результирующей таблице оценка каждого ученика должна быть указана в поле с псевдонимом result в виде ее текстового эквивалента:  Оценка Описание A Great B Great C Well D Bad E Bad",15,2,"select name, surname,   case grade    when 'A' then 'Great'    when 'b' then 'Great'    when 'c' then 'Well'    else 'Bad'   end as result from Math order by grade, name","SELECT   name,   surname,   CASE     WHEN grade < 'C' THEN 'Great'     WHEN grade < 'D' THEN 'Well'     ELSE 'Bad'   END AS result FROM   Math ORDER BY    grade,   name;",
4.11 Условные конструкции ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   INT );  INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 99),        ('Peter', 'Parker', 84),        ('Mary', 'Jane', 9),        ('Gwen', 'Stacy', 23),        ('Harry', 'Osborn', 39),        ('Ben', 'Reilly', 77),        ('Miles', 'Morales', 59),        ('John', 'Jameson', 0),        ('Curtis', 'Connors', 100),        ('Edward', 'Brock', 59); ","Таблица Math Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех учениках: имя, фамилия, оценка за экзамен.  При этом в результирующей таблице оценка каждого ученика должна быть переведена из стобалльной шкалы в пятибалльную и записана в соответствующем виде:  Стобалльная шкала Пятибалльная шкала [80; 100] 5 [60; 79] 4 [30; 59] 3 [10; 29] 2 [0; 9] 1",20,3,"select name, surname,  case    when grade between 80 and 100 then 5   when grade between 60 and 79 then 4   when grade between 30 and 59 then 3   when grade between 10 and 29 then 2   else 1  end as grade from Math order by grade desc, name",,
4.11 Условные конструкции ,"DROP TABLE IF EXISTS Students; CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     email   VARCHAR(40) );  INSERT INTO Students (name, surname, email) VALUES ('Flash', 'Thompson', '99power@midtown.com'),        ('Peter', 'Parker', 'FriendlyNeighborhood@midtown.com'),        ('Mary', 'Jane', 'redhead@gmail.com'),        ('Gwen', 'Stacy', '7@yahoo.com'),        ('Harry', 'Osborn', '1justharry@outlook.com'),        ('Ben', 'Reilly', 'R@midtown.com'),        ('Miles', 'Morales', 'yourspidey2@midtown.com'),        ('John', 'Jameson', 'boss@bugle.com'),        ('Curtis', 'Connors', '5@midtown.com'),        ('Edward', 'Brock', 'WeAreVenom@midtown.com'); ","Каждый ученик средней школы Мидтауна должен иметь корректный адрес электронной почты, однако не все учащиеся соблюдают данное правило. Адрес электронный почты считается корректным, если выполняется ряд следующих условий:  доменная часть адреса равна midtown.com локальная часть адреса состоит как минимум из двух символов первый символ в локальной части адреса не является цифрой Напишите запрос, который извлекает из этой предложенной базы данных имена и фамилии всех учеников школы, а также проверяет на корректность адреса их электронных почт.  Поле с информацией о корректности адреса электронной почты должно иметь псевдоним email_status и содержать строку Correct, если адрес электронной почты ученика является корректным, или Incorrect в противном случае.",20,4,"select name, surname,  case   when email like '%__@midtown.com' and left(email, 1) not between '0' and '9'  then 'Correct'   else 'Incorrect'  end as email_status from Students order by name","SELECT name, surname,        CASE            WHEN SUBSTRING_INDEX(email, '@', -1) != 'midtown.com' THEN 'Incorrect'            WHEN LOCATE('@', email) < 3 THEN 'Incorrect'            WHEN LEFT(email, 1) IN ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9') THEN 'Incorrect'            ELSE 'Correct'        END as email_status FROM Students ORDER BY name",
4.11 Условные конструкции ,"DROP TABLE IF EXISTS Clients; CREATE TABLE Clients (     id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20),     surname VARCHAR(20),     status VARCHAR(40) );  INSERT INTO Clients (name, surname, status) VALUES ('Flash', 'Thompson', 'Gold'),        ('Peter', 'Parker', 'Basic'),        ('Mary', 'Jane', 'Bronze'),        ('Gwen', 'Stacy', 'Silver'),        ('Harry', 'Osborn', 'Gold'),        ('Ben', 'Reilly', 'Basic'),        ('Miles', 'Morales', 'Basic'),        ('John', 'Jameson', 'Silver'),        ('Curtis', 'Connors', 'Bronze'),        ('Edward', 'Brock', 'Silver');","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех клиентах авиакомпании: имя, фамилия, статус в программе лояльности.  Записи в результирующей таблице должны быть расположены в порядке убывания статуса клиента, при совпадении — в лексикографическом порядке имени клиента.",15,3,"select name, surname, status from Clients  order by   case status   when 'Gold' then 1   when 'Silver' then 2   when 'bronze' then 3   when 'basic' then 4  end, name","SELECT name, surname, status FROM Clients ORDER BY FIELD(status, 'Basic', 'Bronze', 'Silver', 'Gold') DESC, name",
4.11 Условные конструкции ,"DROP TABLE IF EXISTS Results; CREATE TABLE Results (     id      INT AUTO_INCREMENT PRIMARY KEY,     name    VARCHAR(50),     surname VARCHAR(50),     time    TIME );  INSERT INTO Results (name, surname, time) VALUES ('Joel', 'Miller', '02:21:00'),        ('Arthur', 'Morgan', '00:10:00'),        ('Leonhard', 'Euler', '00:59:00'),        ('Alan', 'Wake', '00:32:00'),        ('Alyx', 'Vance', '00:16:00'),        ('Jill', 'Valentine', '00:44:00'),        ('Isaac', 'Clarke', '01:01:00'),        ('Gordon', 'Freeman', '00:17:00'),        ('Alan', 'Turing', '00:31:00'),        ('Stephen', 'Hawking', '00:23:00'),        ('Ryu', 'Hayabusa', '00:41:00'),        ('Johnny', 'Silverhand', '00:11:00'),        ('Samus', 'Aran', '00:29:00'),        ('Nathan', 'Drake', '00:54:00'),        ('Erwin', 'Schrodinger', '00:30:00'),        ('Max', 'Payne', '01:00:00'),        ('Tom', 'Nook', '00:12:00'); ","Организация начисляет участникам олимпиады баллы в зависимости от того, сколько времени они затратили на решение. Если участник справился с олимпиадой за 30 и меньше минут, он получит 100 баллов. За каждую лишнюю затраченную минуту участник теряет 1 балл. Таким образом, участник, завершивший олимпиаду за 31 минуту, получит 99 баллов, за 32 минуты — 98 баллов, и так далее. Если же участник затратил на решение олимпиады больше 60 минут, он получит 0 баллов.  Напишите запрос, который извлекает из предложенной базы данных имена и фамилии участников олимпиады, а также определяет количество баллов, набранное каждым из участников.",30,5,"select name, surname,  case   when time_to_sec(time) < 30*60 then 100   when time_to_sec(time) between 1800 and 3600 then 100 - (time_to_sec(time) div 60 - 30)   when time_to_sec(time) > 60*60 then 0  end as score from Results order by score desc, name, surname","SELECT name, surname,        CASE            WHEN time > '01:00:00' THEN 0            WHEN time < '00:30:00' THEN 100            ELSE 100 - MINUTE(TIMEDIFF(time, '00:30:00'))        END AS score FROM Results ORDER BY score DESC, name, surname",
5.1 Агрегатные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который определяет средний рейтинг режиссеров из USA и указывает полученное значение в поле с псевдонимом avg_usa_rating.",10,1,select avg(rating) as avg_usa_rating from Directors where country = 'usa',,
5.1 Агрегатные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', NULL),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', NULL),        ('Tim', 'Burton', 'USA', NULL);"," Напишите запрос, который определяет количество режиссеров с известным рейтингом и указывает полученное значение в поле с псевдонимом num_of_rated_directors.",5,1,select count(*) as num_of_rated_directors from Directors where rating is not NULL,,
5.1 Агрегатные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); "," Напишите запрос, который определяет количество режиссеров из USA с рейтингом больше 50 и указывает полученное значение в поле с псевдонимом num_of_rated_usa_directors.",10,2,select count(*) as num_of_rated_usa_directors from Directors where country = 'usa' and rating > 50 ,,
5.1 Агрегатные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, определяющий количество уникальных стран, в которых родились режиссеры, и указывающий полученное значение в поле с псевдонимом num_of_countries.",10,2,select  count(distinct country) as num_of_countries from Directors ,,
5.1 Агрегатные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 100),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 99),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41);","Напишите запрос, который определяет минимальный и максимальный рейтинги среди режиссеров из USA и указывает полученные значения в полях с псевдонимами min_rating и max_rating соответственно.",10,2,"select min(rating) as min_rating, max(rating) as max_rating from Directors where country = 'usa'",,
5.1 Агрегатные функции ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, извлекающий из предложенной базы данных названия всех уникальных стран, в которых родились режиссеры.  При этом в результирующей таблице названия всех стран должны быть указаны в одном поле с псевдонимом countries в следующем формате:  <название 1-й страны>, <название 2-й страны>, ... Более того, названия стран должны быть расположены в лексикографическом порядке.",15,3,"select group_concat(distinct country order by country separator ', ') as countries from Directors",,
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); "," Напишите запрос, который разбивает режиссеров на группы в зависимости от их страны рождения, определяет средний рейтинг режиссеров каждой группы и отображает полученный результат в виде таблицы из двух полей:",10,1,"select country, avg(rating) as avg_rating from Directors group by country order by avg_rating",,
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от их страны рождения, определяет минимальный и максимальный рейтинги среди режиссеров каждой группы и отображает полученный результат в виде таблицы из трех полей:  country — название страны min_rating — минимальный рейтинг среди режиссеров этой страны max_rating — максимальный рейтинг среди режиссеров этой страны",10,2,"select country, min(rating) as min_rating, max(rating) as max_rating from Directors group by country order by country",,
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 79),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 79),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 74); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от их страны рождения и рейтинга, определяет количество режиссеров в каждой группе и отображает полученный результат в виде таблицы из трех полей:  country — название страны rating — рейтинг num_of_directors — количество режиссеров, родившихся в этой стране и имеющих этот рейтинг",15,3,"select country, rating, count(*) as num_of_directors from Directors group by country, rating order by num_of_directors, country, rating",,
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от первой буквы в их имени, определяет количество режиссеров в каждой группе и отображает полученный результат в виде таблицы из двух полей:  letter — буква num_of_names — количество режиссеров, в имени которых эта буква является первой",10,2,"select left(name, 1) as letter, count(*) as num_of_names from Directors group by letter order by num_of_names, letter",,
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  TRUNCATE Directors; INSERT INTO Directors (name, surname, email) VALUES ('Christopher', 'Nolan', 'chris@gmail.com'),        ('Steven', 'Spielberg', 'sspil@outlook.com'),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', 'martins@outlook.com'),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', 'jamesava@yahoo.com'),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от доменной части в адресе их электронной почты, перечисляет локальные части адресов электронных почт режиссеров каждой группы и отображает полученный результат в виде таблицы из двух полей:  domain — доменная часть адреса электронной почты users — локальные имена адресов электронных почт режиссеров с этой доменной частью, перечисленные через запятую и пробел, а также расположенные в лексикографическом порядке",20,4,"select substring_index(email, '@', -1) as domain,        group_concat(substring_index(email, '@', 1) order by email separator ', ') as users from Directors group by domain order by domain","SELECT SUBSTRING(email, LOCATE('@', email) + 1) as domain,    GROUP_CONCAT(SUBSTRING_INDEX(email, '@', 1) ORDER BY email SEPARATOR ', ') as users FROM Directors GROUP BY SUBSTRING(email, LOCATE('@', email) + 1) ORDER BY domain",
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 11),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от их страны рождения, определяет средний рейтинг режиссеров каждой группы, учитывая только значения больше 10 и меньше 90, и отображает полученный результат в виде таблицы из двух полей:  country — название страны avg_rating — средний рейтинг режиссеров, родившихся в этой стране",10,2,"select country, avg(rating) as avg_rating from Directors where rating between 11 and 89 group by country order by avg_rating","SELECT  country,     AVG(rating) AS avg_rating FROM Directors WHERE rating>10 AND rating<90 GROUP BY country ORDER BY avg_rating",
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Michael', 'Fox', 'Canada', 60),        ('Martin', 'Scorsese', 'USA', 68),        ('Salma', 'Hayek', 'Mexico', 100),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Mike', 'Myers', 'Canada', 65),        ('Clint', 'Eastwood', 'USA', 74),        ('Ryan', 'Reynolds', 'Canada', 55),        ('James', 'Cameron', 'Canada', 22),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от их страны рождения, определяет средний рейтинг режиссеров каждой группы, учитывая только значения больше 30 и меньше 70, и отображает полученный результат в виде таблицы из двух полей:  country — название страны avg_rating — средний рейтинг режиссеров, родившихся в этой стране При этом в результирующую таблицу должна быть добавлена информация только о тех группах режиссеров, средний рейтинг которых меньше 60.  ",15,2,"select country, avg(rating) as avg_rating from Directors where rating between 31 and 69 group by country having avg_rating < 60 order by avg_rating","SELECT     country,     AVG(rating) AS avg_rating FROM     Directors WHERE     30 < rating AND rating < 70 GROUP BY     country HAVING     avg_rating < 60 ORDER BY     avg_rating;",
5.2 Группировка данных ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (   id         INT PRIMARY KEY AUTO_INCREMENT,   name       VARCHAR(20),   surname    VARCHAR(20),   birth_date DATE );  TRUNCATE Directors; INSERT INTO Directors (name, surname, birth_date) VALUES ('Christopher', 'Nolan', '1970-07-30'),        ('Steven', 'Spielberg', '1946-12-18'),        ('Quentin', 'Tarantino', '1963-03-27'),        ('Martin', 'Scorsese', '1942-11-17'),        ('David', 'Fincher', '1962-08-28'),        ('Ridley', 'Scott', '1937-11-30'),        ('Stanley', 'Kubrick', '1928-07-26'),        ('Clint', 'Eastwood', '1930-05-31'),        ('James', 'Cameron', '1954-08-16'),        ('Tim', 'Burton', '1958-08-25'); ","Напишите запрос, который разбивает режиссеров на группы в зависимости от квартала, в котором они родились, перечисляет имена и фамилии режиссеров каждой группы и отображает полученный результат в виде таблицы из двух полей:  quarter — квартал directors — имена и фамилии режиссеров, которые родились в этом квартале, перечисленные через запятую и пробел, а также расположенные в лексикографическом порядке При этом в результирующую таблицу должна быть добавлена информация только о тех группах режиссеров, количество которых больше одного.",25,4,"select quarter(birth_date) as quarter,  group_concat(concat(name, ' ', surname) order by name, surname separator ', ') as directors from Directors group by quarter having count(*) > 1","SELECT QUARTER(birth_date) AS quarter,        GROUP_CONCAT(name, ' ', surname ORDER BY name SEPARATOR ', ') AS directors  FROM Directors GROUP BY quarter HAVING COUNT(*) > 1",
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Bills; CREATE TABLE Bills (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     amount      DECIMAL(10, 2) );  TRUNCATE Bills; INSERT INTO Bills (customer_id, amount) VALUES (4, 123.45),        (10, 678.90),        (2, 456.78),        (10, 789.12),        (4, 234.56),        (4, 987.65),        (9, 345.67),        (10, 567.89),        (11, 123.45),        (2, 456.78),        (13, 789.12),        (10, 234.56),        (15, 987.65),        (16, 345.67),        (16, 500),        (2, 567.89),        (18, 123.45),        (2, 456.78),        (20, 789.12),        (2, 234.56),        (22, 987.65); ","Напишите запрос, определяющий количество клиентов банка, у которых хотя бы на одном счете находится больше 500 долларов, и указывающий полученное значение в поле с псевдонимом customers_count.",10,1,select count(distinct customer_id) as customers_count from Bills where amount > 500,,
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Rides; CREATE TABLE Rides (     id          INT PRIMARY KEY AUTO_INCREMENT,     bike_number VARCHAR(10),     start_time  DATETIME,     end_time    DATETIME );  TRUNCATE Rides; INSERT INTO Rides (bike_number, start_time, end_time) VALUES ('W00678', '2023-03-25 09:15:00', '2023-03-25 10:30:00'),        ('W00399', '2023-03-26 14:20:00', '2023-03-26 15:40:00'),        ('W00433', '2023-03-27 16:45:00', '2023-03-27 17:15:00'),        ('W00455', '2023-03-28 11:30:00', '2023-03-28 12:40:00'),        ('W00576', '2023-03-28 13:10:00', '2023-03-28 13:40:00'),        ('W00300', '2023-03-29 08:45:00', '2023-03-29 09:05:00'),        ('W00455', '2023-03-29 11:20:00', '2023-03-29 12:30:00'),        ('W00576', '2023-03-30 14:00:00', '2023-03-30 14:45:00'),        ('W00300', '2023-03-31 17:10:00', '2023-03-31 17:30:00'),        ('W00678', '2023-04-01 09:30:00', '2023-04-01 10:20:00'),        ('W00399', '2023-04-01 11:40:00', '2023-04-01 12:20:00'),        ('W00455', '2023-04-02 13:15:00', '2023-04-02 13:45:00'),        ('W00576', '2023-04-03 15:25:00', '2023-04-03 15:50:00'),        ('W00300', '2023-04-03 16:10:00', '2023-04-03 16:35:00'),        ('W00455', '2023-04-04 10:55:00', '2023-04-04 11:15:00'),        ('W00399', '2023-04-04 14:30:00', '2023-04-04 14:50:00'),        ('W00576', '2023-04-05 08:20:00', '2023-04-05 08:45:00'),        ('W00300', '2023-04-06 12:00:00', '2023-04-06 12:30:00'),        ('W00433', '2023-04-06 15:10:00', '2023-04-06 15:35:00'),        ('W00678', '2023-04-07 17:45:00', '2023-04-07 18:05:00'); "," Напишите запрос, который извлекает из предложенной базы данных идентификаторы велосипедов, а также определяет дату и время окончания самой последней поездки, совершенной на каждом велосипеде.  Поле с датой и временем окончания самой последней совершенной на велосипеде поездки должно иметь псевдоним last_ride_end.",10,2,"select bike_number, max(end_time) as last_ride_end from Rides group by bike_number order by last_ride_end desc",,
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Actions; CREATE TABLE Actions (     user_id     INT,     post_id     INT,     action_date DATE,     action      VARCHAR(10),     extra       VARCHAR(50) );  TRUNCATE Actions; INSERT INTO Actions (user_id, post_id, action_date, action, extra) VALUES (1, 1, '2023-07-01', 'view', 'NULL'),        (1, 1, '2023-07-01', 'like', 'love'),        (1, 1, '2023-07-01', 'share', 'NULL'),        (2, 4, '2023-07-04', 'view', 'NULL'),        (2, 4, '2023-07-04', 'report', 'spam'),        (3, 4, '2023-07-04', 'like', 'cry'),        (3, 4, '2023-07-04', 'report', 'spam'),        (4, 3, '2023-07-02', 'view', 'NULL'),        (4, 3, '2023-07-02', 'report', 'spam'),        (5, 2, '2023-07-04', 'view', 'NULL'),        (5, 2, '2023-07-04', 'report', 'racism'),        (5, 5, '2023-07-04', 'view', 'NULL'),        (5, 5, '2023-07-04', 'report', 'racism'),        (6, 1, '2023-07-05', 'view', 'NULL'),        (6, 1, '2023-07-05', 'report', 'spam'),        (7, 3, '2023-07-05', 'like', 'laugh'),        (7, 3, '2023-07-05', 'report', 'spam'),        (8, 4, '2023-07-05', 'view', 'NULL'),        (8, 4, '2023-07-05', 'report', 'spam'),        (9, 5, '2023-07-05', 'view', 'NULL'),        (9, 5, '2023-07-05', 'report', 'racism'); ","Напишите запрос, извлекающий из предложенной базы данных все причины жалоб на посты, а также определяющий количество постов, на которые пожаловались по каждой из этих причин. При этом учитываться должны только те посты, жалоба на которые была подана 2023-07-05.",15,3,"select extra as report_reason, count(distinct post_id) as report_count from Actions where action_date = '2023-07-05' and action = 'report' group by report_reason","SELECT extra AS report_reason, COUNT(*) AS report_count FROM Actions WHERE action = 'report' AND action_date = '2023-07-05' GROUP BY extra",
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Salary; CREATE TABLE Salary (     id            INT,     name          VARCHAR(50),     surname       VARCHAR(50),     salary        INT,     department_id VARCHAR(10) );  TRUNCATE Salary; INSERT INTO Salary (id, name, surname, salary, department_id) VALUES (1, 'Adam', 'Bosworth', 120000, 'D1001'),        (2, 'Ben', 'Laurie', 135000, 'D1003'),        (1, 'Adam', 'Bosworth', 98000, 'D1002'),        (3, 'Craig', 'Martek', 110000, 'D1001'),        (3, 'Craig', 'Martek', 125000, 'D1004'),        (4, 'Alon', 'Halevy', 105000, 'D1005'),        (1, 'Adam', 'Bosworth', 140000, 'D1004'),        (4, 'Alon', 'Halevy', 95000, 'D1004'),        (4, 'Alon', 'Halevy', 115000, 'D1004'),        (3, 'Craig', 'Martek', 130000, 'D1004'),        (4, 'Alon', 'Halevy', 90000, 'D1002'),        (3, 'Craig', 'Martek', 100000, 'D1002'),        (2, 'Ben', 'Laurie', 145000, 'D1002'),        (3, 'Craig', 'Martek', 105000, 'D1003'),        (5, 'Joshua', 'Bloch', 120000, 'D1003'),        (6, 'Chris', 'DiBona', 110000, 'D1001'),        (3, 'Craig', 'Martek', 135000, 'D1005'),        (7, 'Brent', 'Callinicos', 95000, 'D1005'),        (4, 'Alon', 'Halevy', 125000, 'D1005'),        (2, 'Ben', 'Laurie', 130000, 'D1001'); ","Известно, что таблица Salary содержит как актуальную информацию, так и устаревшую, поэтому каждый сотрудник может встречаться в ней несколько раз. Также известно, что зарплата сотрудников растет каждый год.  Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех сотрудниках компании: идентификатор, имя, фамилия, актуальная годовая зарплата.  ",10,2,"select id, name, surname, max(salary) as salary from Salary group by id, name, surname",,
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Actions; CREATE TABLE Actions (     task_id     INT PRIMARY KEY AUTO_INCREMENT,     user_id     INT,     submit_date DATE );  TRUNCATE Actions; INSERT INTO Actions (user_id, submit_date) VALUES (7, '2023-01-10'),        (2, '2023-01-11'),        (3, '2023-01-15'),        (4, '2023-01-17'),        (5, '2023-01-20'),        (4, '2023-01-22'),        (7, '2023-01-23'),        (6, '2023-01-25'),        (9, '2023-01-28'),        (2, '2023-01-30'),        (4, '2023-02-02'),        (4, '2023-02-05'),        (1, '2023-02-08'),        (5, '2023-02-10'),        (3, '2023-02-13'),        (4, '2023-02-15'),        (5, '2023-02-18'),        (1, '2023-02-20'),        (3, '2023-02-23'),        (4, '2023-02-25'); "," Напишите запрос, определяющий количество задач, которые были решены в выходные дни, а также количество задач, которые были решены в будние дни. Полученные значения должны быть указаны в полях с псевдонимами weekend_count и working_count соответственно.  ",30,5,"select  count(  case     when weekday(submit_date) between 5 and 6 then 1 end) as weekend_count, count(  case     when weekday(submit_date) between 0 and 4 then 1 end) as working_count from Actions","SELECT SUM(IF(WEEKDAY(submit_date) IN (5, 6), 1, 0)) AS weekend_count,        SUM(IF(WEEKDAY(submit_date) BETWEEN 0 AND 4, 1, 0)) AS working_count FROM Actions","SELECT SUM(WEEKDAY(submit_date) IN (5, 6)) AS weekend_count,         SUM(WEEKDAY(submit_date) NOT IN (5, 6)) AS working_count   FROM Actions"
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Actions; CREATE TABLE Actions (     ad_id   INT,     user_id INT,     action  VARCHAR(10) );  TRUNCATE Actions; INSERT INTO Actions (ad_id, user_id, action) VALUES (1, 1, 'clicked'),        (2, 2, 'clicked'),        (3, 3, 'viewed'),        (5, 5, 'ignored'),        (1, 7, 'ignored'),        (2, 7, 'viewed'),        (3, 5, 'clicked'),        (1, 4, 'viewed'),        (2, 11, 'viewed'),        (1, 2, 'clicked'),        (4, 6, 'viewed'),        (5, 8, 'ignored'),        (4, 9, 'viewed'),        (3, 10, 'viewed'),        (2, 12, 'clicked'),        (1, 13, 'clicked'),        (5, 14, 'ignored'),        (4, 15, 'clicked'),        (3, 16, 'viewed'),        (2, 17, 'clicked'); ","Каждая рекламная интеграция имеет рейтинг эффективности, который вычисляется следующим образом: количество переходов количество переходов + количество просмотров ⋅ 100 количествопереходов+количествопросмотров количествопереходов ​  ⋅100  Если количество переходов и количество просмотров равны нулю, рейтинг эффективности считается равным нулю.  Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех рекламных интеграций, а также определяет рейтинг эффективности каждой рекламной интеграции.  Поле с рейтингом эффективности рекламной интеграции должно иметь псевдоним rating. Значения в поле rating должны быть округлены до 2 знаков после запятой.  ",40,7,"select ad_id,  ifnull(round(sum(if(action = 'clicked', 1, 0)) / (sum(if(action = 'clicked', 1, 0)) + sum(if(action = 'viewed', 1, 0))) * 100, 2), 0.00) as rating from Actions group by ad_id order by rating desc","SELECT ad_id, IFNULL(ROUND(AVG(CASE                                    WHEN action = 'clicked' THEN 1                                    WHEN action = 'viewed' THEN 0                                END) * 100, 2), 0) AS rating FROM Actions GROUP BY ad_id ORDER BY rating DESC","select      ad_id,      coalesce(         round(             sum(action = 'clicked') / (sum(action = 'clicked') + sum(action = 'viewed')) * 100, 2         ),         0.00) as rating from Actions group by ad_id order by rating desc"
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     order_date  DATE,     customer_id INT,     invoice     DECIMAL(10, 2) );  TRUNCATE Orders; INSERT INTO Orders (order_date, customer_id, invoice) VALUES ('2023-02-05', 5, 25.50),        ('2023-02-05', 5, 23.75),        ('2023-02-12', 6, 3.20),        ('2023-02-15', 8, 20.00),        ('2023-02-20', 9, 19.99),        ('2023-02-20', 10, 19.99),        ('2023-02-21', 9, 0.02),        ('2023-03-01', 11, 15.60),        ('2023-03-01', 12, 18.75),        ('2023-03-01', 11, 12.90),        ('2023-03-06', 13, 30.60),        ('2023-03-08', 14, 42.75),        ('2023-03-08', 17, 27.40),        ('2023-03-15', 18, 8.99),        ('2023-03-22', 19, 60.00),        ('2023-04-05', 20, 17.50),        ('2023-04-11', 22, 23.80),        ('2023-04-15', 22, 55.30),        ('2023-04-17', 21, 13.75),        ('2023-04-22', 22, 45.90); ","Напишите запрос, который группирует заказы в зависимости от того, в каком месяце они были сделаны, а также в каждой группе определяет количество заказов на сумму больше 20 долларов и количество уникальных покупателей, совершивших хотя бы один заказ на сумму больше 20 долларов. Полученный результат должен быть отображен в виде таблицы из трех полей:  month — полное название месяца order_count — количество заказов на сумму больше 20 долларов в этом месяце customer_count — количество уникальных покупателей, совершивших хотя бы один заказ на сумму больше 20 долларов в этом месяце",15,3,"select monthname(order_date) as month,        count(invoice) as order_count,        count(distinct customer_id) as customer_count from Orders where invoice > 20  group by month","SELECT MONTHNAME(order_date) AS month,        SUM(invoice > 20) AS order_count,        COUNT(DISTINCT IF(invoice > 20, customer_id, NULL)) AS customer_count FROM Orders GROUP BY month",
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Views; CREATE TABLE Views (     article_id INT,     author_id  INT,     viewer_id  INT,     view_date  DATE );  TRUNCATE Views; INSERT INTO Views (article_id, author_id, viewer_id, view_date) VALUES (7, 5, 17, '2023-08-04'),        (2, 6, 6, '2023-08-01'),        (2, 10, 5, '2023-08-01'),        (10, 2, 22, '2023-08-05'),        (1, 2, 3, '2023-08-01'),        (6, 7, 17, '2023-08-04'),        (3, 6, 9, '2023-08-02'),        (1, 2, 5, '2023-08-01'),        (3, 10, 13, '2023-08-03'),        (1, 2, 2, '2023-08-01'),        (6, 7, 13, '2023-08-02'),        (3, 10, 5, '2023-08-02'),        (6, 7, 5, '2023-08-03'),        (2, 6, 8, '2023-08-02'),        (3, 10, 12, '2023-08-02'),        (9, 10, 20, '2023-08-05'),        (3, 6, 5, '2023-08-02'),        (8, 8, 18, '2023-08-04'),        (4, 13, 5, '2023-08-03'),        (8, 8, 18, '2023-08-04'); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы пользователей, которые за день просмотрели больше одной статьи.",15,3,"select distinct viewer_id from Views  group by viewer_id, view_date having count(distinct article_id) > 1",SELECT viewer_id FROM Views GROUP BY viewer_id HAVING COUNT(DISTINCT article_id) > COUNT(DISTINCT view_date) ORDER BY viewer_id;,
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     id           INT PRIMARY KEY AUTO_INCREMENT,     product_name VARCHAR(255),     sale_date    DATE );  TRUNCATE Sales; INSERT INTO Sales (product_name, sale_date) VALUES     ('   Apple iPhone 13 Pro  ', '2023-01-16'),     ('  Sony WH-1000XM4 Headphones  ', '2023-01-16'),     ('  Apple iPhone 13 Pro', '2023-01-17'),     ('  PlayStation 5   ', '2023-01-19'),     ('  PlayStation 5', '2023-01-22'),     ('  Sony WH-1000XM4 Headphones', '2023-02-11'),     ('Apple iPhOne 13 Pro  ', '2023-10-10'),     ('Sony wH-1000XM4 HeadPhones   ', '2023-01-17'),     ('PlAyStaTion 5   ', '2023-04-20'),     ('ApPle iPhOne 13 PRo', '2023-01-16'),     ('   playstation 5', '2023-04-20'),     ('apple Iphone 13 pRo            ', '2023-04-10'),     ('    Sony WH-1000XM4 Headphones', '2023-03-31'),     ('ApPle iPhoNe 13 Pro           ', '2023-04-10'),     ('      SONY WH-1000xm4 HeadPhones', '2023-03-31'),     ('APPLE IPHONE 13 PRO', '2023-04-10'),     ('PLAYSTATION 5', '2023-03-10'),     ('SONY WH-1000XM4 HEADPHONES', '2023-03-31'),     (' apple iphone 13 pro ', '2023-04-20'),     ('playstation 5', '2023-04-10'); ","Напишите запрос, который извлекает из предложенной базы данных названия всех товаров, а также определяет, в какие месяцы и в каком количестве был продан каждый из этих товаров.  При этом название товара в результирующей таблице должно быть записано в нижнем регистре без ведущих и замыкающих пробелов. Дата продажи товара должна быть записана в следующем формате:  <год>-<месяц> Поле с месяцем продажи товара должно иметь псевдоним sale_date, поле с количеством проданного товара — total.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля product_name, при совпадении — в порядке возрастания значения поля sale_date.  ",25,4,"select lower(ltrim(rtrim(product_name))) as product_name,        date_format(sale_date, '%Y-%m') as sale_date,        count(*) as total from Sales group by lower(ltrim(rtrim(product_name))), date_format(sale_date, '%Y-%m') order by product_name, sale_date","SELECT TRIM(LOWER(product_name)) AS product_name,         DATE_FORMAT(sale_date, '%Y-%m') AS sale_date,         COUNT(*) AS total FROM Sales GROUP BY TRIM(LOWER(product_name)), DATE_FORMAT(sale_date, '%Y-%m') ORDER BY product_name, sale_date",
5.3 Группировка данных. Решение задач ,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     user_id     INT,     action      VARCHAR(10),     question_id INT,     answer_id   INT );  TRUNCATE Activity; INSERT INTO Activity (user_id, action, question_id, answer_id) VALUES (1, 'show', 102, null),        (1, 'skip', 102, null),        (2, 'show', 101, null),        (2, 'answer', 101, 56775),        (2, 'show', 102, null),        (2, 'answer', 102, 56781),        (2, 'show', 103, null),        (2, 'skip', 103, null),        (3, 'show', 103, null),        (3, 'answer', 103, 56777),        (3, 'show', 104, null),        (2, 'show', 104, null),        (2, 'skip', 104, null),        (1, 'show', 101, null),        (1, 'answer', 101, 56774),        (4, 'show', 103, null),        (4, 'answer', 104, 56776),        (4, 'show', 102, null),        (4, 'answer', 103, 56780),        (4, 'show', 105, null),        (5, 'show', 105, null),        (5, 'skip', 105, null),        (5, 'show', 105, null),        (5, 'answer', 105, 56782),        (5, 'show', 101, null),        (5, 'answer', 105, 56783),        (6, 'show', 102, null),        (6, 'answer', 102, 56779); ","Каждая задача имеет коэффициент решения, который равняется следующему отношению: количество раз , когда пользователи отправили решение задачи количество раз , когда пользователи посмотрели задачу количествораз,когдапользователипосмотрелизадачу количествораз,когдапользователиотправилирешениезадачи ​    Напишите запрос, который определяет идентификатор задачи с наибольшим коэффициентом решения и указывает полученное значение в поле с псевдонимом question_id. Если таких задач несколько, в результирующую таблицу должна быть добавлена та задача, чей идентификатор меньше.",40,6,"select question_id from Activity  group by question_id order by sum(if(action = 'answer', 1, 0)) / sum(if(action = 'show', 1, 0)) desc, question_id limit 1",,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 103),        ('Monsters University', 'Dan Scanlon', 104),        ('Toy Story 2', 'John Lasseter', 92),        ('WALL-E', 'Andrew Stanton', 97),        ('Ratatouille', 'Brad Bird', 111),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 92),        ('Finding Nemo', 'Andrew Stanton', 100),        ('Toy Story', 'John Lasseter', 92),        ('The Incredibles', 'Brad Bird', 115); "," Напишите запрос, извлекающий из предложенной базы данных названия фильмов, продолжительность которых больше продолжительности самого короткого фильма.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля title.",5,1,select title from Films where running_time > (select min(running_time) from Films) order by title,,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 103),        ('Monsters University', 'Dan Scanlon', 104),        ('Toy Story 2', 'John Lasseter', 92),        ('WALL-E', 'Andrew Stanton', 97),        ('Ratatouille', 'Brad Bird', 111),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 93),        ('Finding Nemo', 'Andrew Stanton', 100),        ('Toy Story', 'John Lasseter', 81),        ('The Incredibles', 'Brad Bird', 115); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии режиссеров, средняя продолжительность фильмов которых больше средней продолжительности всех фильмов.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля director.",10,3,select director from Films group by director having avg(running_time) > (select avg(running_time) from Films) order by director,,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 103),        ('Monsters University', 'Dan Scanlon', 92),        ('Toy Story 2', 'John Lasseter', 92),        ('WALL-E', 'Andrew Stanton', 101),        ('Ratatouille', 'Brad Bird', 102),        ('Up', 'Pete Docter', 92),        ('Brave', 'Brenda Chapman', 109),        ('Finding Nemo', 'Andrew Stanton', 92),        ('Toy Story', 'John Lasseter', 92),        ('The Incredibles', 'Brad Bird', 115);","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии режиссеров, снявших хотя бы один фильм, продолжительность которого равна продолжительности самого короткого фильма.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля director.",15,2,select distinct director from Films where running_time = (select min(running_time) from Films) order by director,,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 103),        ('Monsters University', 'Dan Scanlon', 92),        ('Toy Story 2', 'John Lasseter', 101),        ('WALL-E', 'Andrew Stanton', 92),        ('Ratatouille', 'Brad Bird', 111),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 92),        ('Finding Nemo', 'Andrew Stanton', 92),        ('Toy Story', 'John Lasseter', 92),        ('The Incredibles', 'Brad Bird', 115); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии режиссеров, снявших хотя бы один фильм, продолжительность которого больше продолжительности самого короткого фильма.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля director.",10,3,select director from Films where running_time > (select min(running_time) from Films) group by director order by director,,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 105),        ('Monsters University', 'Dan Scanlon', 104),        ('Toy Story 2', 'John Lasseter', 97),        ('WALL-E', 'Andrew Stanton', 97),        ('Ratatouille', 'Brad Bird', 111),        ('Up', 'Pete Docter', 97),        ('Brave', 'Brenda Chapman', 92),        ('Finding Nemo', 'Andrew Stanton', 113),        ('Toy Story', 'John Lasseter', 96),        ('The Incredibles', 'Brad Bird', 115); ","Напишите запрос, извлекающий из предложенной базы данных названия фильмов, продолжительность которых равна продолжительности фильма WALL-E. При этом сам фильм WALL-E не должен быть включен в результирующую таблицу.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля title.",10,3,select title from Films where running_time = (select running_time from Films                       where title = 'wall-e') and title != 'wall-e' order by title,SELECT title FROM Films where running_time = (SELECT running_time FROM Films where title like 'WALL-E') and title not like 'WALL-E' ORDER BY director;,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 103),        ('Monsters University', 'Dan Scanlon', 104),        ('Toy Story 2', 'John Lasseter', 92),        ('WALL-E', 'Andrew Stanton', 97),        ('Ratatouille', 'Brad Bird', 111),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 93),        ('Finding Nemo', 'Andrew Stanton', 100),        ('Toy Story', 'John Lasseter', 81),        ('The Incredibles', 'Brad Bird', 115); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии режиссеров, а также определяет, сколько фильмов снял каждый режиссер с продолжительностью больше средней продолжительности всех фильмов. При этом в результирующую таблицу должны быть добавлены только те режиссеры, которые сняли хотя бы один фильм с требуемой продолжительностью.  Поле с количеством фильмов, снятых режиссером, должно иметь псевдоним num_of_films.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля num_of_films, при совпадении — в порядке возрастания значения поля director.",15,3,"select director, count(*) as num_of_films from Films where running_time > (select avg(running_time) from Films) group by director order by num_of_films desc, director","select director, sum(running_time > (select avg(running_time) from Films)) as num_of_films from Films group by director having num_of_films != 0 order by num_of_films desc, director ",
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 101),        ('Monsters University', 'Dan Scanlon', 104),        ('Toy Story 2', 'John Lasseter', 110),        ('WALL-E', 'Andrew Stanton', 97),        ('Ratatouille', 'Brad Bird', 101),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 93),        ('Finding Nemo', 'Andrew Stanton', 95),        ('Toy Story', 'John Lasseter', 81),        ('The Incredibles', 'Brad Bird', 95); "," Напишите запрос, извлекающий из предложенной базы данных названия фильмов, продолжительность которых больше продолжительности хотя бы одного фильма, снятого режиссером Brad Bird.",15,3,select title from Films where running_time > (select min(running_time) from Films                                                     group by director                           having director = 'brad bird') order by title,SELECT title FROM Films WHERE running_time > ANY (SELECT running_time                           FROM Films                           WHERE director = 'Brad Bird') ORDER BY title,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 103),        ('Monsters University', 'Dan Scanlon', 100),        ('Toy Story 2', 'John Lasseter', 105),        ('WALL-E', 'Andrew Stanton', 112),        ('Ratatouille', 'Brad Bird', 92),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 93),        ('Finding Nemo', 'Andrew Stanton', 110),        ('Toy Story', 'John Lasseter', 100),        ('The Incredibles', 'Brad Bird', 91);"," Напишите запрос, извлекающий из предложенной базы данных названия фильмов, продолжительность которых меньше продолжительности каждого фильма, снятого режиссером John Lasseter.",15,3,select title from Films  where running_time < (select min(running_time) from Films                       group by director                       having director = 'john lasseter') order by title,SELECT title FROM Films WHERE running_time < ALL (SELECT running_time                           FROM Films                           WHERE director = 'John Lasseter') ORDER BY title,
6.1 Подзапросы. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (title, director, running_time) VALUES ('Toy Story 3', 'Lee Unkrich', 115),        ('Monsters University', 'Dan Scanlon', 104),        ('Toy Story 2', 'John Lasseter', 92),        ('WALL-E', 'Andrew Stanton', 97),        ('Ratatouille', 'Brad Bird', 111),        ('Up', 'Pete Docter', 96),        ('Brave', 'Brenda Chapman', 92),        ('Finding Nemo', 'Andrew Stanton', 100),        ('Toy Story', 'John Lasseter', 92),        ('The Incredibles', 'Brad Bird', 115); "," Напишите запрос, который определяет количество фильмов с минимальной и максимальной продолжительностью среди всех фильмов и указывает полученные значения в полях с псевдонимами shortest_films и longest_films соответственно.",40,6,"select (select count(*) from Films         group by running_time         order by running_time         limit 1) as shortest_films,         (select count(*) from Films         group by running_time         order by running_time desc         limit 1) as longest_films","SELECT (SELECT COUNT(*)         FROM Films         WHERE running_time = (SELECT MIN(running_time)                               FROM Films)) AS shortest_films,        (SELECT COUNT(*)         FROM Films         WHERE running_time = (SELECT MAX(running_time)                               FROM Films)) AS longest_films",
6.2 Подзапросы. Часть 2 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     show_date    DATE,     title        VARCHAR(40),     director     VARCHAR(20),     running_time INT );  TRUNCATE Films; INSERT INTO Films (show_date, title, director, running_time) VALUES ('2023-07-13', 'Toy Story 3', 'Lee Unkrich', 115),        ('2023-07-18', 'Monsters University', 'Dan Scanlon', 104),        ('2023-07-15', 'Toy Story 2', 'John Lasseter', 92),        ('2023-07-01', 'WALL-E', 'Andrew Stanton', 97),        ('2023-07-17', 'Ratatouille', 'Brad Bird', 111),        ('2023-07-16', 'Up', 'Pete Docter', 96),        ('2023-07-22', 'Brave', 'Brenda Chapman', 92),        ('2023-07-14', 'Finding Nemo', 'Andrew Stanton', 100),        ('2023-06-30', 'Toy Story', 'John Lasseter', 92),        ('2023-07-19', 'The Incredibles', 'Brad Bird', 115); ","Напишите запрос, который извлекает из предложенной базы данных названия фильмов, продолжительность которых больше, чем продолжительность фильма, показанного в предыдущий день.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля title.",15,3,select title from Films where running_time > (select running_time from Films as InnerFilms                       where show_date = Films.show_date - interval '1' day) order by title ,"SELECT title From Films WHERE running_time > (SELECT running_time                       FROM Films AS InnerFilms                       WHERE show_date = SUBDATE(Films.show_date, INTERVAL 1 DAY)) ORDER BY title;",
6.2 Подзапросы. Часть 2 ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   INT );  TRUNCATE Math; INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 2),        ('Peter', 'Parker', 2),        ('Mary', 'Jane', 3),        ('Gwen', 'Stacy', 2),        ('Harry', 'Osborn', 3),        ('May', 'Parker', 4),        ('Miles', 'Morales', 2),        ('John', 'Jameson', 1),        ('Norman', 'Osborn', 5),        ('Ben', 'Parker', 3); ","Напишите запрос, извлекающий из предложенной базы данных информацию о студентах (имя, фамилия, оценка), оценка которых больше средней оценки всех предыдущих студентов.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля grade, при совпадении — порядке возрастания значения поля name.",15,3,"select name, surname, grade from Math as M where grade > (select avg(grade) from Math                where id < M.id) order by grade, name",,
6.2 Подзапросы. Часть 2 ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   INT );  TRUNCATE Math; INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 4),        ('Peter', 'Parker', 5),        ('Mary', 'Jane', 5),        ('Gwen', 'Stacy', 2),        ('Harry', 'Osborn', 3),        ('May', 'Parker', 3),        ('Miles', 'Morales', 2),        ('John', 'Jameson', 1),        ('Norman', 'Osborn', 2),        ('Ben', 'Parker', 2); "," Напишите запрос, извлекающий из предложенной базы данных информацию о студентах (имя, фамилия, оценка), оценка которых совпадает с оценкой предыдущего или следующего студентов.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля name.",20,3,"select name, surname, grade from Math as M where grade = any (select grade from Math                where id = M.id - 1 or id = M.id + 1) order by name","SELECT name, surname, grade FROM Math WHERE grade IN (SELECT grade                 FROM Math AS M                 WHERE (M.id = Math.id - 1) OR (M.id = Math.id + 1)) ORDER BY name",
6.2 Подзапросы. Часть 2 ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   INT );  TRUNCATE Math; INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 4),        ('Peter', 'Parker', 5),        ('Mary', 'Jane', 5),        ('Gwen', 'Stacy', 2),        ('Harry', 'Osborn', 3),        ('May', 'Parker', 4),        ('Miles', 'Morales', 2),        ('John', 'Jameson', 5),        ('Norman', 'Osborn', 2),        ('Ben', 'Parker', 5); ","Напишите запрос, извлекающий из предложенной базы данных информацию о студентах (имя, фамилия, оценка), оценка которых совпадает с наиболее часто встречающейся оценкой.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля name.",20,4,"select name, surname, grade from Math as M where grade = (select grade from Math                group by grade                 order by count(*) desc                limit 1) order by name ","SELECT name, surname, grade FROM Math WHERE grade = (SELECT grade                FROM Math                GROUP BY grade                HAVING COUNT(*) > ALL (SELECT COUNT(*)                                       FROM Math AS MathCopy                                       WHERE id != Math.id                                       GROUP BY grade)) ORDER BY name;",
6.2 Подзапросы. Часть 2 ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   INT );  TRUNCATE Math; INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 4),        ('Peter', 'Parker', 5),        ('Mary', 'Jane', 5),        ('Gwen', 'Stacy', 2),        ('Harry', 'Osborn', 3),        ('May', 'Parker', 4),        ('Miles', 'Morales', 2),        ('John', 'Jameson', 1),        ('Norman', 'Osborn', 2),        ('Ben', 'Parker', 3);","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии студентов, фамилии которых совпадают с фамилией какого-либо другого студента.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля surname, при совпадении — порядке возрастания значения поля name.",30,5,"select name, surname from Math as M where surname = any (select surname from Math                  where id != M.id) order by surname, name","SELECT name, surname FROM Math WHERE surname IN (SELECT surname                   FROM Math                   GROUP BY surname                   HAVING COUNT(*) > 1) ORDER BY surname, name",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии пользователей, которые не приобрели ни одного фильма.",10,2,"select name, surname from Users where id != all (select user_id from Purchases)","SELECT name, surname FROM Users WHERE NOT EXISTS (SELECT *                   FROM Purchases                   WHERE user_id = Users.id);",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) ); INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, извлекающий из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера), которые были куплены хотя бы раз.",10,2,"select title, director from Films where id in (select film_id from Purchases) order by title","SELECT title, director FROM Films WHERE EXISTS (SELECT *               FROM Purchases               WHERE film_id = Films.id) ORDER BY title;",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, определяющий количество пользователей, которые приобрели фильм под названием Toy Story 2, и указывающий полученное значение в поле с псевдонимом num_of_users.",10,2,select count(*) as num_of_users from Purchases where film_id = (select id from Films                   where title = 'toy story 2'),"SELECT COUNT(*) AS num_of_users FROM Purchases GROUP BY film_id HAVING film_id = (     SELECT id     FROM Films     WHERE title = ""Toy Story 2""   );",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии пользователей, которые приобрели фильм под названием Toy Story 2.",20,4,"select name, surname from Users where id in (select user_id from Purchases            where film_id = (select id from Films                             where title = 'toy story 2')) order by name ","SELECT name, surname FROM Users WHERE EXISTS (SELECT *               FROM Purchases               WHERE user_id = Users.id                 AND film_id = (SELECT id                                FROM Films                                WHERE title = 'Toy Story 2')) ORDER BY name;",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id INT PRIMARY KEY AUTO_INCREMENT,     title VARCHAR(20),     director VARCHAR(20),     price FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех пользователей, а также определяет количество фильмов, купленное каждым пользователем.  Поле с количеством купленных пользователем фильмов должно иметь псевдоним num_of_films.",25,4,"select name, surname, (select count(*) from Purchases                        where user_id = Users.id) as num_of_films from Users order by num_of_films desc, name",,
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); "," Напишите запрос, который извлекает из предложенной базы данных имена и фамилии пользователей, которые приобрели ровно два фильма.",30,5,"SELECT name, surname FROM Users WHERE 2 = (SELECT COUNT(*)            FROM Purchases            WHERE user_id = Users.id) ORDER BY name","select name, surname from Users where id = (select user_id from Purchases             where user_id = Users.id             group by user_id             having count(user_id) = 2) order by name",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который извлекает из предложенной базы данных имя и фамилию пользователя, который приобрел наибольшее количество фильмов.",30,6,"select name, surname from Users where id =  (select user_id from Purchases group by user_id  order by count(*) desc limit 1)","SELECT     u.name,     u.surname FROM Users AS u WHERE (SELECT COUNT(*) FROM Purchases GROUP BY user_id HAVING user_id = u.id) =             (SELECT MAX(amount) FROM (SELECT COUNT(*) AS amount FROM Purchases GROUP BY user_id) AS Temp) ORDER BY u.name;",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (6, 3),        (2, 4),        (7, 2),        (9, 4),        (6, 1),        (1, 2),        (1, 3),        (5, 1),        (10, 1); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии пользователей, а также определяет название первого купленного каждым пользователем фильма. При этом в результирующую таблицу должны быть добавлены только те пользователи, которые приобрели хотя бы один фильм.",30,5,"select name, surname,                      (select title from Films                       where id =                                 (select film_id from Purchases                                             where user_id = Users.id                                  order by id                                  limit 1)) as first_film from Users where id in (select user_id from Purchases) order by name","SELECT name, surname,        (SELECT title         FROM Films         WHERE id = (SELECT film_id                     FROM Purchases                     WHERE user_id = Users.id                     ORDER BY id                     LIMIT 1)) AS first_film FROM Users WHERE EXISTS (SELECT *               FROM Purchases               WHERE user_id = Users.id) ORDER BY name;",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    DECIMAL(10, 2) );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех пользователей, а также определяет количество денег, потраченное каждым пользователем на покупку фильмов.  Поле с количеством денег, потраченных пользователем на покупку фильмов, должно иметь псевдонимtotal_spending.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля total_spending, при совпадении — в порядке возрастания значения поля name.",50,7,"select name, surname,                       ifnull((select sum(price) from Films                       where id = any (select film_id from Purchases                                       where user_id = Users.id)), 0.00) as total_spending from Users order by total_spending desc, name","SELECT name, surname,        IFNULL((SELECT SUM(price)                FROM Films                WHERE EXISTS (SELECT *                              FROM Purchases                              WHERE film_id = Films.id                                AND user_id = Users.id)), 0.00) AS total_spending FROM Users ORDER BY total_spending DESC, name;",
6.3 Подзапросы. Часть 3 ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40) );  INSERT INTO Users (name, surname) VALUES ('Matt', 'Damon'),        ('Edward', 'Norton'),        ('Nicolas', 'Cage'),        ('Ben', 'Affleck'),        ('John', 'Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (5, 2),        (6, 3),        (7, 1),        (10, 1); "," Напишите запрос, который извлекает из предложенной базы данных имена и фамилии пользователей, а также определяет название самого дорогого купленного каждым пользователем фильма. При этом в результирующую таблицу должны быть добавлены только те пользователи, которые приобрели хотя бы один фильм. Если пользователем куплено несколько самых дорогих фильмов, в результирующую таблицу должен быть добавлен тот фильм, чье название меньше в лексикографическом сравнении.  Поле с названием самого дорогого купленного пользователем фильма должно иметь псевдоним most_expensive_film.  Записи в результирующей таблице должны быть расположены в порядке убывания цен самых дорогих купленных пользователями фильмов, при совпадении — в лексикографическом порядке названий этих фильмов, при совпадении — в лексикографическом порядке имен пользователей.  ",100,9,"select name, surname,                      (select title from Films                       where id in (select film_id from Purchases                                   where user_id = Users.id)                              and price = (select max(price) from Films                                           where id in (select film_id from Purchases                                                        where user_id = Users.id))                       order by title                       limit 1)           as most_expensive_film from Users                       where id in (select user_id from Purchases) order by (select max(price) from Films           where id in (select film_id from Purchases                       where user_id = Users.id)) desc, most_expensive_film, name","SELECT name, surname,       (SELECT title        FROM Films        WHERE EXISTS (SELECT *                      FROM Purchases                      WHERE user_id = Users.id AND film_id = Films.id)        ORDER BY price DESC, title        LIMIT 1) AS most_expensive_film FROM Users WHERE EXISTS (SELECT *               FROM Purchases               WHERE user_id = Users.id) ORDER BY (SELECT price           FROM Films           WHERE title = most_expensive_film) DESC,           most_expensive_film, name;",
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS RequestsAccepted; DROP TABLE IF EXISTS FriendRequests;  -- Создание таблицы FriendRequests CREATE TABLE FriendRequests (     sender_id    INT,     send_to_id   INT,     request_date DATE );  INSERT INTO FriendRequests (sender_id, send_to_id, request_date) VALUES (1, 2, '2023-06-01'),        (1, 2, '2023-06-02'),        (1, 3, '2023-06-01'),        (1, 3, '2023-06-21'),        (2, 1, '2023-06-12'),        (2, 1, '2023-06-23'),        (2, 3, '2023-06-02'),        (3, 1, '2023-06-12'),        (3, 2, '2023-06-13'),        (3, 4, '2023-06-09'),        (4, 1, '2023-06-25'),        (4, 2, '2023-06-29'),        (4, 3, '2023-06-15'),        (4, 5, '2023-06-10'),        (5, 3, '2023-06-21'),        (5, 3, '2023-06-28'),        (5, 4, '2023-06-16'),        (5, 6, '2023-06-11'),        (5, 6, '2023-06-11'),        (6, 5, '2023-06-20');  -- Создание таблицы RequestsAccepted CREATE TABLE RequestsAccepted (     requester_id INT,     accepter_id  INT,     accept_date  DATE );  TRUNCATE RequestsAccepted; INSERT INTO RequestsAccepted (requester_id, accepter_id, accept_date) VALUES (1, 2, '2023-06-02'),        (1, 2, '2023-06-02'),        (1, 3, '2023-06-23'),        (2, 3, '2023-06-02'),        (3, 1, '2023-06-15'),        (3, 2, '2023-06-14'),        (3, 4, '2023-06-19'),        (4, 1, '2023-06-25'),        (4, 1, '2023-06-25'),        (4, 2, '2023-06-30'),        (5, 3, '2023-06-21'),        (5, 3, '2023-06-28'),        (5, 4, '2023-06-17'),        (5, 6, '2023-06-15'),        (6, 5, '2023-06-20'); ","Коэффициентом принятия заявок в друзья называется следующее отношение: количество принятых заявок в друзья количество отправленных заявок в друзья количествоотправленныхзаявоквдрузья количествопринятыхзаявоквдрузья ​    Пользователь может отправлять несколько заявок в друзья одному и тому же пользователю, также пользователь может принимать заявку в друзья от одного и того же пользователя несколько раз, однако при вычислении коэффициента принятия заявок в друзья дублированные заявки не учитываются.  Напишите запрос, который определяет коэффициент принятия заявок в друзья и указывает полученное значение в поле с псевдонимом accept_rate. Значение в поле accept_rate должно быть округлено до 2 знаков после запятой.  ",30,5,"SELECT ROUND(IFNULL(       (SELECT COUNT(DISTINCT requester_id, accepter_id)        FROM RequestsAccepted)        /       (SELECT COUNT(DISTINCT sender_id, send_to_id)        FROM FriendRequests), 0), 2) AS accept_rate","select round((select count(distinct concat(requester_id, accepter_id)) from RequestsAccepted) /        (select count(distinct concat(sender_id, send_to_id)) from FriendRequests), 2) as accept_rate",
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS Scores; CREATE TABLE Scores (     id    INT PRIMARY KEY AUTO_INCREMENT,     score DECIMAL(4, 2) );  TRUNCATE Scores; INSERT INTO Scores (score) VALUES (3.50),        (3.50),        (4.00),        (3.50),        (4.20),        (3.65),        (4.20),        (3.65),        (4.20),        (3.95),        (4.05),        (3.65),        (4.05),        (3.70),        (3.80),        (4.25),        (3.55),        (4.40),        (4.30),        (4.40); ","Напишите запрос, который оценивает игровые сессии в зависимости от количества набранных очков. Сессия, в которой набрано наибольшее количество очков, должна иметь оценку 1, следующая по количеству очков сессия — оценку 2, и так далее. Если какие-либо две сессии имеют равное количество очков, они должны иметь равную оценку.  Поле с оценкой игровой сессии должно иметь псевдоним gamer_rank.",50,7,"select score, (select count(distinct score) from Scores                     where score >= InnerS.score) as gamer_rank from Scores as InnerS","SELECT      score,     (SELECT CONVERT(LOCATE(SC.score, GROUP_CONCAT(DISTINCT score ORDER BY score DESC)), SIGNED) DIV (CHAR_LENGTH(SC.score) + 1) + 1      FROM Scores) AS gamer_rank FROM Scores AS SC ORDER BY gamer_rank DESC",
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS Follow; CREATE TABLE Follow (     followee VARCHAR(50),     follower VARCHAR(50) );  TRUNCATE Follow; INSERT INTO Follow (followee, follower) VALUES ('John', 'Alice'),        ('Alice', 'Bob'),        ('Bob', 'Edward'),        ('Bob', 'George'),        ('Donald', 'Edward'),        ('Edward', 'Frank'),        ('Edward', 'George'),        ('George', 'Helen'),        ('Helen', 'Isabel'),        ('Isabel', 'John'),        ('Cena', 'John'),        ('David', 'Alice'),        ('Eva', 'John'),        ('Cena', 'Isabel'),        ('Eva', 'John'),        ('Alice', 'David'),        ('Helen', 'Alice'),        ('David', 'Helen'),        ('Isabel', 'David'),        ('Eva', 'George'); ","Пользователь называется пользователем второго уровня, если он имеет хотя бы одного подписчика, а также если он сам подписан хотя бы на одного пользователя.  Напишите запрос, который извлекает из предложенной базы данных имена пользователей второго уровня, а также определяет количество подписчиков у каждого пользователя.  Поле с именем пользователя второго уровня должно иметь псевдоним user, поле с количеством его подписчиков — followers.  ",40,6,"SELECT     followee AS user,     COUNT(*) AS followers FROM     Follow WHERE     followee IN (SELECT DISTINCT follower FROM Follow) GROUP BY     followee ORDER BY     user","SELECT followee AS user, COUNT(follower) AS followers  FROM Follow GROUP BY user HAVING (SELECT COUNT(followee)          FROM Follow AS F         GROUP BY follower         HAVING user = F.follower) >= 1 ORDER BY user","select distinct followee as user, (select count(distinct follower) from Follow                                    where followee = F1.followee                                    ) as followers                                    from Follow as F1 where followee = any(select follower from Follow as F2) order by user"
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id         INT,     product_id INT,     quantity   INT );  TRUNCATE Orders; INSERT INTO Orders (id, product_id, quantity) VALUES (1, 1, 12),        (1, 2, 8),        (1, 3, 10),        (2, 1, 9),        (2, 4, 5),        (2, 5, 6),        (3, 3, 8),        (3, 4, 18),        (4, 5, 4),        (4, 6, 8),        (5, 7, 9),        (5, 8, 9),        (6, 2, 12),        (6, 5, 3),        (7, 3, 10),        (7, 4, 13),        (8, 1, 7),        (8, 6, 6),        (9, 7, 8),        (9, 8, 18); ","Среднее количество товаров в одном заказе представляет следующее отношение: суммарное количество товаров в заказе количество различных товаров в заказе количестворазличныхтовароввзаказе суммарноеколичествотовароввзаказе ​    Заказ называется несбалансированным, если в нем количество хотя бы одного товара больше, чем среднее количество товаров в каждом другом заказе (включая сам заказ).  Напишите запрос, который извлекает из предложенной базы данных идентификаторы несбалансированных заказов.  ",30,5,select id from Orders as O1 where quantity > all(                              select sum(quantity)/count(product_id) from Orders                                                           group by id),SELECT DISTINCT id FROM Orders WHERE quantity > ALL (SELECT SUM(quantity) / COUNT(DISTINCT product_id)                       FROM Orders                       GROUP BY id),SELECT id FROM Orders GROUP BY id HAVING MAX(quantity) > ALL(SELECT AVG(quantity)                        FROM Orders                        GROUP BY id)
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS Rounds; DROP TABLE IF EXISTS Candidates;  -- Создание таблицы Candidates CREATE TABLE Candidates (     id           INT PRIMARY KEY AUTO_INCREMENT,     name         VARCHAR(255),     years_of_exp INT,     interview_id INT );  INSERT INTO Candidates (name, years_of_exp, interview_id) VALUES ('Emily', 4, 301),        ('Oliver', 2, 302),        ('Ava', 6, 303),        ('Liam', 1, 304),        ('Sophia', 7, 305),        ('Noah', 1, 306),        ('Emma', 5, 307),        ('Mason', 2, 308),        ('Isabella', 2, 309),        ('William', 2, 310);  -- Создание таблицы Rounds CREATE TABLE Rounds (     interview_id INT,     round_id     INT,     score        INT );  TRUNCATE Rounds; INSERT INTO Rounds (interview_id, round_id, score) VALUES (301, 1, 8),        (301, 2, 8),        (302, 1, 9),        (302, 2, 8),        (302, 3, 6),        (303, 1, 3),        (303, 2, 2),        (304, 1, 5),        (304, 2, 6),        (304, 3, 6),        (304, 4, 6),        (305, 1, 9),        (306, 1, 4),        (306, 2, 5),        (307, 1, 7),        (307, 2, 6),        (308, 1, 2),        (309, 1, 5),        (309, 2, 6),        (309, 3, 4),        (310, 1, 8),        (310, 2, 9); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы кандидатов, которые:  имеют опыт работы не меньше 2 лет во время собеседования суммарно набрали больше 15 баллов",20,4,select id from Candidates where years_of_exp >= 2 and interview_id = (select interview_id from Rounds                                              where interview_id = Candidates.interview_id                                                                       group by interview_id                                            having sum(score) > 15),SELECT id FROM Candidates WHERE years_of_exp >= 2       AND (SELECT SUM(score)            FROM Rounds            WHERE interview_id = Candidates.interview_id) > 15,
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     order_type  INT );  TRUNCATE Orders; INSERT INTO Orders (customer_id, order_type) VALUES (5, 0),        (5, 1),        (6, 1),        (7, 0),        (8, 1),        (8, 0),        (9, 1),        (10, 1),        (11, 0),        (12, 0),        (13, 1),        (13, 1),        (20, 1),        (14, 1),        (14, 1),        (14, 1),        (17, 0),        (19, 0),        (19, 1),        (20, 1),        (14, 1),        (12, 0); ","Напишите запрос, который извлекает из предложенной базы данных всю информацию о заказах покупателей по следующему правилу:  если у покупателя есть хотя бы один заказ типа 0, в результирующую таблицу должны быть добавлены только заказы типа 0 этого покупателя если у покупателя нет ни одного заказа типа 0, в результирующую таблицу должны быть добавлены все заказы этого покупателя",70,8,select *  from Orders as O1 where ((select min(order_type) as mm from Orders as O2        where O2.customer_id = O1.customer_id       ) = O1.order_type),SELECT * FROM Orders WHERE order_type = 0 OR       customer_id NOT IN (SELECT DISTINCT customer_id                           FROM Orders                           WHERE order_type = 0);,
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS SaintPetersburg; DROP TABLE IF EXISTS Moscow;  -- Создание таблицы Moscow CREATE TABLE Moscow (     student_id INT PRIMARY KEY AUTO_INCREMENT,     score      INT );  TRUNCATE Moscow; INSERT INTO Moscow (score) VALUES (90),        (87),        (88),        (91),        (89),        (92),        (86),        (93),        (85),        (94),        (84),        (95),        (83),        (96),        (82),        (97),        (81),        (98),        (80),        (99);  -- Создание таблицы SaintPetersburg CREATE TABLE SaintPetersburg (     student_id INT PRIMARY KEY AUTO_INCREMENT,     score      INT );  TRUNCATE SaintPetersburg ; INSERT INTO SaintPetersburg (score) VALUES (89),        (88),        (90),        (87),        (91),        (86),        (92),        (85),        (93),        (84),        (94),        (83),        (95),        (82),        (96),        (81),        (97),        (80),        (98),        (79); ","В олимпиаде от каждого университета выступает одинаковое количество студентов. Студенты, набравшие на олимпиаде 90 или больше баллов, называются отличниками. Победителем олимпиады становится тот университет, у которого больше отличников. Если оба вуза имеют одинаковое количество отличников, олимпиада завершается ничьей.  Напишите запрос, который определяет результат олимпиады путем извлечения одного из следующих значений:  Moscow University, если победителем является Московский университет Saint Petersburg University, если победителем является Санкт-Петербургский университет No winner, если олимпиада завершилась ничьей ",20,3,select         case           when (select count(*) from Moscow                where score >= 90) > (select count(*) from SaintPetersburg                                      where score >= 90) then 'Moscow University'         when (select count(*) from Moscow                where score >= 90) < (select count(*) from SaintPetersburg                                      where score >= 90) then 'Saint Petersburg University'           else 'No winner'          end as winner,select   case sign(   (select count(*) from Moscow where score >= 90) -    (select count(*) from SaintPetersburg where score >= 90)    )    when 1 then 'Moscow University'    when -1 then 'Saint Petersburg University'    else 'No winner'   end as winner,"SELECT   CASE     WHEN moscow > peterburg THEN 'Moscow University'     WHEN moscow < peterburg THEN 'Saint Petersburg University'     ELSE 'No winner'   END AS winner FROM   (     SELECT COUNT(*) AS moscow     FROM Moscow     WHERE Score >= 90   ) AS moscow,   (     SELECT COUNT(*) AS peterburg     FROM SaintPetersburg     WHERE Score >= 90   ) AS peterburg;"
6.4 Подзапросы. Решение задач  ,"DROP TABLE IF EXISTS Scores; CREATE TABLE Scores (     player_name  VARCHAR(50),     team         CHAR(1),     day          DATE,     score_points INT );  TRUNCATE Scores; INSERT INTO Scores (player_name, team, day, score_points) VALUES ('David', 'M', '2023-09-05', 14),        ('Felicia', 'F', '2023-09-05', 20),        ('Eva', 'F', '2023-02-07', 20),        ('Michael', 'M', '2023-02-07', 9),        ('Sophia', 'F', '2023-06-10', 26),        ('Matthew', 'M', '2023-06-10', 11),        ('Olivia', 'F', '2023-02-15', 29),        ('Jacob', 'M', '2023-02-15', 17),        ('Ava', 'F', '2023-08-21', 24),        ('Liam', 'M', '2023-08-21', 12),        ('Chloe', 'F', '2023-06-29', 23),        ('John', 'M', '2023-02-03', 23); ","Напишите запрос, который определяет общее количество очков, набранное каждой командой на момент участия каждого ее участника.  Поле с общим количеством очков команды должно иметь псевдоним total.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля team, при совпадении — в порядке возрастания значения поля day.  ",40,6,"select team, day, score_points + ifnull((select sum(score_points) from Scores                                   where team = S1.team and to_days(day) < to_days(S1.day)), 0) as total from Scores as S1  order by team, day","SELECT team, day,        (SELECT SUM(score_points)         FROM Scores         WHERE team = S.team AND day <= S.day) AS total FROM Scores AS S ORDER BY team, day",
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, извлекающий из предложенной базы данных названия товаров, которые были проданы хотя бы раз.  Поле с названием товара должно иметь псевдоним product.",10,1,select distinct name as product from Products join Sales on Products.id = Sales.product_id  ,,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, извлекающий из предложенной базы данных уникальные названия товаров, которые были проданы 12 сентября 2023 года.  Поле с названием товара должно иметь псевдоним product.",15,2,select distinct name as product from Products inner join Sales on Products.id=Sales.product_id where sale_date = '2023-09-12',,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); ","Напишите запрос, который извлекает из предложенной базы данных названия товаров, а также определяет, на какую общую сумму был продан каждый товар. При этом в результирующую таблицу должны быть добавлены только те товары, которые были проданы хотя бы один раз.  В результирующей таблице общая сумма, на которую был продан каждый товар, должна быть указана в поле с псевдонимом amount в следующем формате:  <общая сумма>€ Поле с названием товара должно иметь псевдоним product.",20,3,"select distinct name as product, concat(price*count(*),'€') as amount from Products join Sales on Products.id=Sales.product_id group by product_id",,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, извлекающий из предложенной базы данных название товара, который 12 сентября 2023 года был продан наибольшее количество раз.  Поле с названием товара должно иметь псевдоним bestseller.",25,4,select name as bestseller from Products join Sales on Products.id=Sales.product_id where sale_date = '2023-09-12' group by product_id order by count(product_id) desc limit 1,,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); ","Напишите запрос, извлекающий из предложенной базы данных информацию о названиях товаров, которые 12 сентября 2023 года были куплены ровно один раз.  Поле с названием товара должно иметь псевдоним product.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля product.  ",20,4,select name as product from Products join Sales on Products.id=Sales.product_id where sale_date = '2023-09-12'  group by product_id having count(product_id) = 1   order by product,,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products; DROP TABLE IF EXISTS Categories;  -- Создание таблицы Categories CREATE TABLE Categories (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50) );  INSERT INTO Categories (name) VALUES ('Laptops'),        ('Smartphones'),        ('Cameras');  -- Создание таблицы Products CREATE TABLE Products (     id          INT PRIMARY KEY AUTO_INCREMENT,     category_id INT,     name        VARCHAR(50),     price       INT );  INSERT INTO Products (name, category_id, price) VALUES ('Apple iPhone 13 Pro', 2, 900),        ('Samsung Galaxy S21', 2, 600),        ('Lenovo ThinkPad X1 Carbon', 1, 1400),        ('Dell XPS 13', 1, 600),        ('Canon EOS R6', 3, 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); ","Напишите запрос, извлекающий из предложенной базы данных следующую информацию обо всех продажах магазина: идентификатор продажи, дату продажи, название проданного товара и название категории, которой принадлежит проданный товар.  Поле с идентификатором продажи должно иметь псевдоним sale_id, поле с названием товара — product, поле с названием категории — category.",20,4,"select Sales.id as sale_id, sale_date, Products.name as product, Categories.name as category from Sales join Products on Sales.product_id = Products.id            join Categories on Products.category_id = Categories.id;",,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products; DROP TABLE IF EXISTS Categories;  -- Создание таблицы Categories CREATE TABLE Categories (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50) );  INSERT INTO Categories (name) VALUES ('Laptops'),        ('Smartphones'),        ('Cameras');  -- Создание таблицы Products CREATE TABLE Products (     id          INT PRIMARY KEY AUTO_INCREMENT,     category_id INT,     name        VARCHAR(50),     price       INT );  INSERT INTO Products (name, category_id, price) VALUES ('Apple iPhone 13 Pro', 2, 900),        ('Samsung Galaxy S21', 2, 600),        ('Lenovo ThinkPad X1 Carbon', 1, 1400),        ('Dell XPS 13', 1, 600),        ('Canon EOS R6', 3, 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (3, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (3, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, извлекающий из предложенной базы данных название категории, товары которой были проданы на наибольшую общую сумму.  Поле с названием категории должно иметь псевдоним category.",20,4,select Categories.name as category  from Sales join Products on Sales.product_id = Products.id            join Categories on Products.category_id = Categories.id group by category_id order by sum(price) desc limit 1,,
7.2 Внутреннее соединение ,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id         INT PRIMARY KEY AUTO_INCREMENT,     name       VARCHAR(50),     salary     DECIMAL(10, 2),     manager_id INT );  TRUNCATE Employees; INSERT INTO Employees (name, salary, manager_id) VALUES ('John', 50000.00, null),        ('Jane', 21000.00, 1),        ('Michael', 48000.00, 1),        ('Emily', 15000.00, null),        ('Sophia', 49000.00, null),        ('Oliver', 48000.00, 4),        ('Emma', 15000.00, null),        ('Liam', 30000.00, null),        ('Ava', 11000.00, 5),        ('Lucas', 45000.00, 6),        ('Mila', 47000.00, null),        ('Ethan', 46000.00, 8),        ('Isabella', 49000.00, 9),        ('Noah', 48000.00, 12),        ('Sophia', 15000.00, null),        ('Logan', 30000.00, null),        ('Olivia', 44000.00, 16),        ('Aiden', 45000.00, 17),        ('Chloe', 46000.00, 5); ","Напишите запрос, извлекающий из предложенной базы данных имена сотрудников, которые зарабатывают больше, чем их руководители.",10,3,select E1.name from Employees E1 join Employees E2 on E1.manager_id = E2.id where E1.salary > E2.salary,,
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (2, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (4, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, извлекающий из предложенной базы данных названия товаров, которые не были проданы ни разу.  Поле с названием товара должно иметь псевдоним product.",15,2,select name as product from Products left join Sales on Products.id = Sales.product_id where product_id is NULL,,
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (2, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (4, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, который извлекает из предложенной базы данных названия всех товаров, а также определяет, в какую дату впервые был продан каждый товар. Если товар не был продан ни разу, вместо даты первой продажи должна быть указана строка Not sold.  Поле с названием товара должно иметь псевдоним product, поле с датой первой продажи — first_sale.",20,4,"select name as product, ifnull(min(sale_date), 'Not sold') as first_sale from Products left join Sales on Products.id = Sales.product_id group by name","SELECT DISTINCT Products.name AS product, IFNULL((SELECT sale_date                                         FROM Sales                                         WHERE Products.id = product_id                                         ORDER BY sale_date                                         LIMIT 1), 'Not sold') AS first_sale  FROM Products LEFT JOIN Sales ON Products.id = product_id",
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 900),        ('Samsung Galaxy S21', 600),        ('Lenovo ThinkPad X1 Carbon', 1400),        ('Dell XPS 13', 600),        ('Canon EOS R6', 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (2, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (4, '2023-09-13'),        (1, '2023-09-14'); "," Напишите запрос, который извлекает из предложенной базы данных названия всех товаров, а также определяет, на какую общую сумму был продан каждый товар.  В результирующей таблице общая сумма, на которую был продан каждый товар, должна быть указана в поле с псевдонимом amount в следующем формате:  <общая сумма>€ Поле с названием товара должно иметь псевдоним product.",25,4,"SELECT DISTINCT Products.name AS product, IFNULL((SELECT sale_date                                         FROM Sales                                         WHERE Products.id = product_id                                         ORDER BY sale_date                                         LIMIT 1), 'Not sold') AS first_sale  FROM Products LEFT JOIN Sales ON Products.id = product_id","SELECT name AS product, CONCAT((COUNT(sale_date) * price), '€') AS amount FROM Products     LEFT JOIN Sales ON Products.id = Sales.product_id GROUP BY product, price",
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products; DROP TABLE IF EXISTS Categories;  -- Создание таблицы Categories CREATE TABLE Categories (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50) );  INSERT INTO Categories (name) VALUES ('Laptops'),        ('Smartphones'),        ('Cameras');  -- Создание таблицы Products CREATE TABLE Products (     id          INT PRIMARY KEY AUTO_INCREMENT,     category_id INT,     name        VARCHAR(50),     price       INT );  INSERT INTO Products (name, category_id, price) VALUES ('Apple iPhone 13 Pro', 2, 900),        ('Samsung Galaxy S21', 2, 600),        ('Lenovo ThinkPad X1 Carbon', 1, 1400),        ('Dell XPS 13', 1, 600),        ('Canon EOS R6', 3, 1900);  -- Создание таблицы Sales CREATE TABLE Sales (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     sale_date  DATE );  TRUNCATE Sales; INSERT INTO Sales (product_id, sale_date) VALUES (1, '2023-09-11'),        (2, '2023-09-11'),        (1, '2023-09-11'),        (2, '2023-09-12'),        (4, '2023-09-12'),        (1, '2023-09-12'),        (4, '2023-09-12'),        (4, '2023-09-13'),        (4, '2023-09-13'),        (1, '2023-09-14'); ","Напишите запрос, который извлекает из предложенной базы данных названия всех категорий, а также определяет, на какую среднюю сумму были проданы товары каждой категории.  В результирующей таблице средняя сумма, на которую были проданы товары каждой категории, должна быть округлена до целого числа и указана в поле с псевдонимом avg_amount в следующем формате:  <средняя сумма>€ Поле с названием категории должно иметь псевдоним category.",30,5,"select Categories.name as category, concat(ifnull(round(avg(price), 0), 0), '€') as avg_amount from Products right join Sales on Products.id = Sales.product_id               right join Categories on Products.category_id = Categories.id group by Categories.name",,
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS FemaleStaff; DROP TABLE IF EXISTS MaleStaff;  -- Создание таблицы MaleStaff CREATE TABLE MaleStaff (   id      INT PRIMARY KEY AUTO_INCREMENT,   staffer VARCHAR(50),   age     INT );  INSERT INTO MaleStaff (staffer, age) VALUES   ('Larry Page', 48),   ('Sundar Pichai', 49),   ('Eric Schmidt', 66),   ('Jeff Dean', 49),   ('Hiroshi Lockheimer', 43);  -- Создание таблицы FemaleStaff CREATE TABLE FemaleStaff (   id      INT PRIMARY KEY AUTO_INCREMENT,   staffer VARCHAR(50),   age     INT );  INSERT INTO FemaleStaff (staffer, age) VALUES   ('Susan Wojcicki', 53),   ('Ruth Porat', 63),   ('Aparna Chennapragada', 48); ","Напишите запрос, который определяет все возможные пары сотрудников мужчина-женщина, разница в возрасте между которыми меньше 5 лет, и отображает полученный результат в виде таблицы из двух полей:  male_staffer — имя и фамилия сотрудника мужского пола female_staffer — имя и фамилия сотрудника женского пола Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля male_staffer, при совпадении — в порядке возрастания значения поля female_staffer.",15,3,"select MaleStaff.staffer as male_staffer, FemaleStaff.staffer as female_staffer from MaleStaff cross join FemaleStaff where abs(FemaleStaff.age - MaleStaff.age) < abs(5) order by male_staffer, female_staffer",,
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS Drinks; DROP TABLE IF EXISTS Meals;  -- Создание таблицы Meals CREATE TABLE Meals (   id    INT PRIMARY KEY AUTO_INCREMENT,   name  VARCHAR(50),   price INT );  INSERT INTO Meals (name, price) VALUES ('Omlet', 2),        ('Waffles', 4),        ('Pizza', 10),        ('Cheeseburger', 5);  -- Создание таблицы Drinks CREATE TABLE Drinks (   id    INT PRIMARY KEY AUTO_INCREMENT,   name  VARCHAR(50),   price INT );  INSERT INTO Drinks (name, price) VALUES ('Orange Juice', 3),        ('Green Tea', 2),        ('Coffee', 2),        ('Water', 0); ","Напишите запрос, который определяет все возможные пары блюдо-напиток, вычисляет стоимость каждой пары и отображает полученный результат в виде таблицы из двух полей:  combo — названия блюда и напитка в следующем формате: <название блюда>, <название напитка> price — общая стоимость блюда и напитка в следующем формате: <общая стоимость блюда и напитка>€ Записи в результирующей таблице должны быть расположены в порядке возрастания общей стоимости блюда и напитка, при совпадении — в лексикографическом порядке названия блюда, при совпадении — в лексикографическом порядке названия напитка.",25,3,"select concat(Meals.name, ', ', Drinks.name) as combo, concat((Meals.price + Drinks.price),'€') as price from Meals cross join Drinks order by Meals.price + Drinks.price, Meals.name, Drinks.name",,
7.3 Внешнее и перекрестное соединения ,"DROP TABLE IF EXISTS Ranks; DROP TABLE IF EXISTS Suits;  -- Создание таблицы Suits CREATE TABLE Suits (   suit VARCHAR(10) );  INSERT INTO Suits (suit) VALUES ('Hearts'),        ('Diamonds'),        ('Clubs'),        ('Spades');  -- Создание таблицы Ranks CREATE TABLE Ranks (   rankvalue VARCHAR(10) );  INSERT INTO Ranks (rankvalue) VALUES ('2'),        ('3'),        ('4'),        ('5'),        ('6'),        ('7'),        ('8'),        ('9'),        ('10'),        ('Jack'),        ('Queen'),        ('King'),        ('Ace'); ","Напишите запрос, который создает стандартную карточную колоду из 52 карт и отображает полученный результат в виде таблицы из двух полей:  suit — масть карты rankvalue — ранг карты Записи в результирующей таблице должны быть расположены в порядке возрастания старшинства карточной масти, при совпадении — в порядке возрастания старшинства карточного ранга.  Результат запроса Скрипт для создания таблиц Suits и Ranks Примечание. Расположение карточных рангов в порядке возрастания старшинства: 2, ..., 10, Jack, Queen, King и Ace. Расположение карточных мастей в порядке возрастания старшинства: Spades, Clubs, Diamonds и Hearts.  ",40,6,"select Suits.suit as suit, Ranks.rankvalue as rankvalue from Suits cross join Ranks order by  case suit   when 'Spades' then 1   when 'Clubs' then 2   when 'Diamonds' then 3   when 'Hearts' then 4   end,           case rankvalue                when 'Jack' then 11         when 'Clabs' then 12         when 'Queen' then 13         when 'King' then 14         when 'Ace' then 15         end,     cast(rankvalue as SIGNED)","  select suit        , rankvalue     from Suits, Ranks order by locate(suit, ""SpadesClubsDiamondsHearts"")        , locate(rankvalue, ""2345678910JackQueenKingAce"");",
7.3 Внешнее и перекрестное соединения ," EXISTS Points; CREATE TABLE Points (     id INT AUTO_INCREMENT PRIMARY KEY,     x  INT,     y  INT );  INSERT INTO Points (x, y) VALUES (2, 7),        (4, 8),        (2, 10),        (1, 1),        (3, 2),        (1, 4),        (5, 3),        (6, 6),        (9, 5);","Напишите запрос, который определяет все возможные пары точек, расстояние между которыми больше 5, и отображает полученный результат в виде таблицы из трех полей:  p1 — координаты первой точки в следующем формате: (<координата x>; <координата y>) p2 — координаты второй точки в следующем формате: (<координата x>; <координата y>) distance — расстояние между точками, округленное до одного знака после запятой При этом в результирующую таблицу должны быть добавлены только уникальные пары точек. Например, пара точек с идентификаторами 1 и 2, а также пара точек с идентификаторами 2 и 1 считаются одинаковыми. Из них должна быть выбрана только та пара, в которой идентификатор первой точки меньше второй.",40,6,"select concat('(', P1.x, '; ', P1.y, ')') as p1, concat('(', P2.x, '; ', P2.y, ')') as p2,        round(sqrt(pow((P1.x - P2.x),2) + pow((P1.y - P2.y), 2)), 1) as distance                                     from Points P1 cross join Points P2 where P1.id < P2.id and round(sqrt(pow((P1.x - P2.x),2) + pow((P1.y - P2.y), 2)), 1) > 5",,
7.4 Объединение результатов запросов ,"DROP TABLE IF EXISTS Programmers; DROP TABLE IF EXISTS Physicists; DROP TABLE IF EXISTS Mathematicians;  -- Создание таблицы Mathematicians CREATE TABLE Mathematicians (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(30),     surname VARCHAR(30) );  TRUNCATE Mathematicians; INSERT INTO Mathematicians (name, surname) VALUES     ('Leonhard', 'Euler'),     ('Carl', 'Gauss'),     ('Isaac', 'Newton'),     ('Euclid', 'Alexandria'),     ('Albert', 'Einstein'),     ('John', 'Milnor'),     ('Blaise', 'Pascal'),     ('Rene', 'Descartes'),     ('Andrew', 'Wiles'),     ('Srinivasa', 'Ramanujan'),     ('John', 'Nash'),     ('Kurt', 'Godel');  -- Создание таблицы Physicists CREATE TABLE Physicists (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(30),     surname VARCHAR(30) );  TRUNCATE Physicists; INSERT INTO Physicists (name, surname) VALUES     ('Richard', 'Muller'),     ('Isaac', 'Newton'),     ('Galileo', 'Galilei'),     ('Niels', 'Bohr'),     ('Richard', 'Feynman');  -- Создание таблицы Programmers CREATE TABLE Programmers (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(30),     surname VARCHAR(30) );  TRUNCATE Programmers; INSERT INTO Programmers (name, surname) VALUES     ('Alan', 'Turing'),     ('Grace', 'Hopper'),     ('Linus', 'Torvalds'),     ('Tim', 'Berners'),     ('Ada', 'Lovelace'),     ('John', 'Neumann'),     ('Dennis', 'Ritchie'),     ('Tim', 'Peters'),     ('Donald', 'Knuth'),     ( 'Larry', 'Page'); ","Напишите запрос, который определяет общее количество математиков, физиков и программистов и отображает полученный результат в виде таблицы из двух полей:  profession — название профессии (Mathematician — математик, Physicist — физик, Programmer — программист) total — количество людей этой профессии",20,4,"select prof as profession, count(*) as total from (select *, 'Mathematician' as prof from Mathematicians union all select *, 'Physicist' from Physicists union all select *, 'Programmer' from Programmers) as TableAll group by profession","SELECT 'Mathematician' AS profession, COUNT(*) AS total FROM Mathematicians  UNION  SELECT 'Physicist' AS profession, COUNT(*) FROM Physicists  UNION  SELECT 'Programmer' AS profession, COUNT(*) FROM Programmers",
7.4 Объединение результатов запросов ,"DROP TABLE IF EXISTS Sessions; CREATE TABLE Sessions (     id         INT AUTO_INCREMENT PRIMARY KEY,     duration   INT );  TRUNCATE Sessions; INSERT INTO Sessions(duration) VALUES (264),        (2968),        (600),        (1328),        (499),        (1511),        (57),        (1754),        (2596),        (1716),        (794),        (1822),        (727),        (1170),        (668),        (300),        (138),        (1204),        (2607),        (421),        (283),        (153),        (599),        (2111),        (899),        (2736),        (2239),        (299),        (2200),        (900);","Напишите запрос, который определяет количество сессий продолжительностью:  [0-5) — от 0 (включительно) до 5 минут (не включительно) [5-10) — от 5 (включительно) до 10 минут (не включительно) [10-15) — от 10 (включительно) до 15 минут (не включительно) 15 or more — от 15 минут (включительно) и более Поле с продолжительностью сессии должно иметь псевдоним session_duration, поле с количеством сессий — total.",25,3,"select '[0-5)' as session_duration, count(*) as total from Sessions where duration/60 < 5 union select  '[5-10)' as session_duration, count(*) as total from Sessions where   duration/60 < 10 and duration/60 >= 5 union select  '[10-15)' as session_duration, count(*) as total from Sessions where   duration/60 < 15 and duration/60 >= 10 union select  '15 or more' as session_duration, count(*) as total from Sessions where    duration/60 >= 15","SELECT '[0-5)' AS session_duration, COUNT(*) AS total FROM Sessions WHERE duration < 300  UNION  SELECT '[5-10)', COUNT(*) FROM Sessions WHERE duration BETWEEN 300 AND 599  UNION  SELECT '[10-15)', COUNT(*) FROM Sessions WHERE duration BETWEEN 600 AND 899  UNION  SELECT '15 or more', COUNT(*) FROM Sessions WHERE duration >= 900",
7.4 Объединение результатов запросов ,"DROP TABLE IF EXISTS Files; CREATE TABLE Files (     file_name VARCHAR(30),     content   TEXT );  TRUNCATE Files; INSERT INTO Files (file_name, content) VALUES ('file312.txt', 'Geeks know how to put into practice the acquired knowledge'),        ('file52.txt', 'The first images of bee are in the rock paintings of ancient people'),        ('file132.txt', 'If talk to this geek for 30 minutes, it begins to seem that he has the hearing of a bat'),        ('file1.txt', 'All worker bees are females'),        ('file5.txt', 'The bee has two huge beautiful eyes on the sides of its head'),        ('file18.txt', 'Otaku: geek of anime'),        ('file289.txt', 'A bee has six legs'),        ('file192.txt', 'They know something that many people don’t know. Geeks constantly study'),        ('file107.txt', 'Whovian: Doctor Who Maniac Fan'),        ('file10.txt', 'Large amounts of smoke can anger a bee'),        ('file130.txt', 'bee'),        ('file59.txt', 'A person is not stung by a swarming bees'),        ('file33.txt', 'Bee were highly revered in ancient Egypt'),        ('file66.txt', 'Bees can dance'),        ('file67.txt', 'Geek are a specific layer of society’s culture'),        ('file45.txt', 'Queen bee are almost 2 times larger than workers'),        ('file141.txt', 'developed by the BEEGEEK team'),        ('file230.txt', 'Yes, sometimes listening to an hour-long speech by a geek'),        ('file180.txt', 'Geek'),        ('file162.txt', 'A geek who knows Vulcan greetings'),        ('file114.txt', 'Gamer: a type of geek with amazing coordination of movements'),        ('file115.txt', 'Roleplayer: chameleon and actor of the world of the geeks'),        ('file7.txt', 'Bee distinguishes colors'); ","Напишите запрос, определяющий количество текстовых файлов, в которых встречается:  слово bee без учета регистра слово geek без учета регистра Поле со словом должно иметь псевдоним word, поле с количеством файлов, содержащих слово, — count.",40,5,"select 'bee' as word, count(*) as count from Files where content like ('bee %') or content like ('bee') or content like ('% bee %') or content like ('% bee') union select 'geek', count(*) from Files where content like ('geek %') or content like ('geek') or content like ('% geek %') or content like ('% geek')","select  'bee' as word , count(*) as count from Files where locate(' bee ', concat(' ', content, ' ')) > 0  union  select  'geek' as word , count(*) as count from Files where locate(' geek ', concat(' ', content, ' ')) > 0 ;",
7.4 Объединение результатов запросов ,"DROP TABLE IF EXISTS Programmers; DROP TABLE IF EXISTS Physicists; DROP TABLE IF EXISTS Mathematicians;  -- Создание таблицы Mathematicians CREATE TABLE Mathematicians (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(30),     surname VARCHAR(30) );  TRUNCATE Mathematicians; INSERT INTO Mathematicians (name, surname) VALUES ('Leonhard', 'Euler'),        ('Carl', 'Gauss'),        ('Isaac', 'Newton'),        ('Euclid', 'Alexandria'),        ('Albert', 'Einstein'),        ('John', 'Milnor'),        ('Blaise', 'Pascal'),        ('Rene', 'Descartes'),        ('Andrew', 'Wiles'),        ('Srinivasa', 'Ramanujan'),        ('John', 'Nash'),        ('Kurt', 'Godel');  -- Создание таблицы Physicists CREATE TABLE Physicists (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(30),     surname VARCHAR(30) );  TRUNCATE Physicists; INSERT INTO Physicists (name, surname) VALUES ('Richard', 'Muller'),        ('Isaac', 'Newton'),        ('Galileo', 'Galilei'),        ('Niels', 'Bohr'),        ('Richard', 'Feynman');  -- Создание таблицы Programmers CREATE TABLE Programmers (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(30),     surname VARCHAR(30) );  TRUNCATE Programmers; INSERT INTO Programmers (name, surname) VALUES ('Alan', 'Turing'),        ('Grace', 'Hopper'),        ('Linus', 'Torvalds'),        ('Tim', 'Berners'),        ('Ada', 'Lovelace'),        ('John', 'Neumann'),        ('Dennis', 'Ritchie'),        ('Tim', 'Peters'),        ('Donald', 'Knuth'),        ('Larry', 'Page'); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех математиков, физиков и программистов.  При этом в результирующей таблице сначала должны быть расположены все математики, затем все физики, а после все программисты. Математики относительно друг друга должны быть расположены в обратном лексикографическом порядке имени, при совпадении — в обратном лексикографическом порядке фамилии. Аналогичным образом относительно друг друга должны быть расположены физики и программисты.",30,4,"select name, surname from (select name, surname, 1 as f1 from Mathematicians  union select name, surname, 2 from Physicists  union select name, surname, 3 from Programmers) as Allover order by f1, name desc, surname desc",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Teams; CREATE TABLE Teams (     name VARCHAR(50) );  INSERT INTO Teams (name) VALUES ('Manchester United'),        ('Liverpool FC'),        ('Chelsea FC'),        ('Arsenal FC'),        ('Manchester City'),        ('Tottenham Hotspur'),        ('Everton FC'),        ('Leicester City'),        ('West Ham United'),        ('Aston Villa FC'); ","У каждой футбольной команды имеется собственный стадион, поэтому любые две команды могут сыграть между собой два матча: сперва на стадионе одной команды, затем на стадионе другой команды.  Напишите запрос, определяющий все возможные матчи, которые могут сыграть между собой предложенные футбольные команды, и отображающий полученный результат в виде таблицы из двух полей:  home_team — название домашней команды away_team — название гостевой команды",20,3,"select H.name as home_team, A.name as away_team    from Teams as H cross join Teams as A where H.name != A.name",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Elements; CREATE TABLE Elements (     symbol VARCHAR(2),     type   VARCHAR(10) );  INSERT INTO Elements (symbol, type) VALUES ('H', 'nonmetal'),        ('Li', 'metal'),        ('Be', 'metal'),        ('C', 'nonmetal'),        ('Ne', 'noble'),        ('F', 'nonmetal'),        ('Na', 'metal'),        ('Mg', 'metal'),        ('O', 'nonmetal'),        ('N', 'nonmetal'),        ('Al', 'metal'),        ('P', 'nonmetal'),        ('Ar', 'noble'),        ('K', 'metal'),        ('S', 'nonmetal'),        ('Ca', 'metal'),        ('Cl', 'nonmetal'),        ('Kr', 'noble'),        ('Rb', 'metal'),        ('Br', 'nonmetal'); ","Два химических элемента могут образовывать связь, если один из них является металлом, а другой — неметаллом.  Напишите запрос, определяющий все пары элементов, которые могут образовывать связь, и отображающий полученный результат в виде таблицы из двух полей:  metal — название элемента, являющегося металлом nonmetal — название элемента, являющегося неметаллом",15,3,"select  M.symbol as metal, N.symbol as nonmetal from Elements as M  cross join Elements as N where M.type = 'metal' and N.type = 'nonmetal'","SELECT E1.symbol AS metal,        E2.symbol AS nonmetal FROM Elements AS E1, Elements AS E2 WHERE (E1.type, E2.type) = ('metal', 'nonmetal')","SELECT * FROM     (SELECT symbol AS metal FROM Elements WHERE type = 'metal') AS Metals,     (SELECT symbol AS nonmetal FROM Elements WHERE type = 'nonmetal') AS Nonmetals"
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     price DECIMAL(10, 2) );  INSERT INTO Products (price) VALUES (10.00),        (25.50),        (15.75),        (30.25),        (12.99),        (5.99),        (40.00),        (18.50),        (8.75),        (22.00),        (14.50),        (9.99),        (35.75),        (20.00),        (7.25),        (13.75),        (27.50),        (11.99),        (32.00),        (17.25);  -- Создание таблицы Orders CREATE TABLE Orders (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     user_id    INT,     quantity   INT );  TRUNCATE Orders; INSERT INTO Orders (product_id, user_id, quantity) VALUES (1, 101, 10),        (2, 101, 2),        (3, 102, 5),        (4, 102, 3),        (5, 103, 4),        (6, 104, 7),        (7, 104, 1),        (8, 105, 3),        (9, 105, 6),        (10, 106, 2),        (11, 106, 2),        (12, 107, 9),        (13, 107, 4),        (14, 108, 8),        (15, 108, 2),        (16, 109, 5),        (17, 109, 3),        (18, 110, 6),        (19, 110, 4),        (20, 111, 2); ","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех покупателей, а также определяет суммарное количество денег, потраченное каждым покупателем.  Поле с количеством потраченных покупателем денег должно иметь псевдоним spending.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля spending.",20,2,"select user_id, sum(quantity*price) as spending from Products join Orders on Products.id = Orders.product_id group by user_id order by spending desc",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Invoices; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50) );  INSERT INTO Products (name) VALUES ('Apple iPhone 13 Pro'),        ('Samsung Galaxy S21'),        ('Sony WH-1000XM4 Headphones'),        ('Nike Air Zoom Pegasus 38'),        ('Adidas Ultraboost 21'),        ('Lenovo ThinkPad X1 Carbon'),        ('Dell XPS 13 Laptop'),        ('Canon EOS R6 Camera'),        ('Bose QuietComfort 35 II'),        ('Samsung 65-inch QLED TV'),        ('LG OLED55CXPUA TV'),        ('Apple AirPods Pro'),        ('Fitbit Versa 3'),        ('PlayStation 5'),        ('Xbox Series X'),        ('Amazon Echo Dot (4th Gen)'),        ('GoPro HERO9 Black'),        ('Samsung Galaxy Tab S7'),        ('Dyson V11 Animal Vacuum'),        ('Instant Pot Duo 7-in-1');  -- Создание таблицы Invoices CREATE TABLE Invoices (     id         INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     rest       INT,     paid       INT,     cancelled  INT,     refunded   INT );  INSERT INTO Invoices (id, product_id, rest, paid, cancelled, refunded) VALUES (1, 13, 211, 130, 16, 692),        (2, 6, 428, 284, 138, 839),        (3, 4, 973, 273, 449, 427),        (4, 19, 690, 619, 26, 274),        (5, 4, 730, 192, 771, 278),        (6, 9, 176, 553, 235, 520),        (7, 3, 520, 265, 764, 28),        (8, 1, 116, 486, 85, 966),        (9, 9, 103, 225, 819, 418),        (10, 15, 457, 180, 532, 119),        (11, 1, 147, 616, 638, 345),        (12, 9, 121, 274, 7, 212),        (13, 6, 306, 690, 532, 591),        (14, 11, 468, 794, 565, 446),        (15, 10, 361, 321, 525, 660),        (16, 17, 95, 944, 435, 346),        (17, 12, 742, 989, 719, 630),        (18, 16, 749, 411, 810, 818),        (19, 13, 949, 893, 619, 414),        (20, 12, 826, 351, 275, 325),        (21, 20, 734, 743, 515, 346),        (22, 3, 402, 679, 190, 914),        (23, 20, 668, 441, 204, 696),        (24, 7, 347, 830, 107, 48),        (25, 17, 849, 822, 565, 360),        (26, 10, 210, 608, 412, 235),        (27, 15, 529, 405, 441, 990),        (28, 14, 99, 512, 265, 790),        (29, 5, 928, 957, 0, 131),        (30, 12, 712, 802, 873, 962); ","Напишите запрос, который извлекает из предложенной базы данных названия всех товаров, а также для каждого товара определяет общую сумму к оплате, общую оплаченную сумму, общую аннулированную сумму и общую возвращенную сумму по всем счет-фактурам.  Поле с названием товара должно иметь псевдоним product.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля product.   ",20,3,"select name as product, ifnull(sum(rest), 0) as rest, ifnull(sum(paid), 0) as paid, ifnull(sum(cancelled), 0) as cancelled, ifnull(sum(refunded), 0) as refunded  from Products left join Invoices on Products.id = Invoices.product_id group by name order by name",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Confirmations; CREATE TABLE Confirmations (     user_id    INT,     time_stamp DATETIME,     action     VARCHAR(10) );  TRUNCATE Confirmations; INSERT INTO Confirmations (user_id, time_stamp, action) VALUES (1, '2023-09-25 08:50:39', 'timeout'),        (1, '2023-09-26 09:02:20', 'timeout'),        (1, '2023-09-25 09:20:11', 'confirmed'),        (2, '2023-08-03 11:04:16', 'confirmed'),        (3, '2023-09-16 12:00:11', 'timeout'),        (3, '2023-09-17 12:00:11', 'timeout'),        (4, '2023-08-05 14:02:39', 'confirmed'),        (4, '2023-09-25 15:00:20', 'timeout'),        (5, '2023-05-25 16:00:11', 'timeout'),        (5, '2023-07-25 17:02:00', 'confirmed'),        (6, '2023-07-05 18:00:39', 'confirmed'),        (6, '2023-09-25 19:50:20', 'timeout'),        (6, '2023-07-05 18:00:16', 'confirmed'),        (7, '2023-05-25 20:04:00', 'timeout'),        (7, '2023-04-05 21:02:39', 'timeout'),        (7, '2023-04-05 21:00:20', 'timeout'),        (8, '2023-03-25 22:00:11', 'timeout'),        (8, '2023-10-25 23:04:00', 'confirmed'),        (8, '2023-03-25 22:50:20', 'timeout'),        (9, '2023-09-06 00:00:39', 'confirmed'),        (9, '2023-09-06 00:02:20', 'confirmed'),        (9, '2023-09-06 00:00:11', 'confirmed'),        (10, '2023-07-26 02:04:39', 'confirmed'),        (10, '2023-07-26 02:04:40', 'confirmed'),        (11, '2023-09-06 03:00:20', 'timeout'),        (12, '2023-09-16 03:00:20', 'timeout'),        (12, '2023-09-17 03:00:21', 'timeout'); "," Напишите запрос, извлекающий из предложенной базы данных идентификаторы пользователей, которые как минимум дважды запросили сообщение с подтверждением регистрации в течение 24 часов.",30,5,"select A.user_id from Confirmations as A inner join Confirmations as B on A.user_id = B.user_id  where A.time_stamp != B.time_stamp and abs(timestampdiff(SECOND, A.time_stamp, B.time_stamp)) <= 24*60*60  group by user_id",SELECT DISTINCT C1.user_id FROM Confirmations AS C1 INNER JOIN Confirmations AS C2 ON C1.user_id = C2.user_id WHERE C2.time_stamp > C1.time_stamp AND       C1.time_stamp + INTERVAL 24 HOUR >= C2.time_stamp,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Weather; DROP TABLE IF EXISTS Countries;  -- Создание таблицы Countries CREATE TABLE Countries (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Countries (name) VALUES ('Russia'),        ('Kazakhstan'),        ('China'),        ('Ukraine'),        ('Belarus');  -- Создание таблицы Weather CREATE TABLE Weather (     country_id    INT,     weather_state INT,     day           DATE );  TRUNCATE Weather; INSERT INTO Weather (country_id, weather_state, day) VALUES (4, -20, '2023-01-12'),        (1, 13, '2023-03-19'),        (3, -7, '2022-10-22'),        (1, -7, '2022-11-14'),        (5, 30, '2023-01-06'),        (5, 12, '2023-04-27'),        (5, 6, '2022-11-20'),        (3, 20, '2023-09-30'),        (2, 22, '2023-07-06'),        (1, 13, '2023-06-01'),        (3, 30, '2023-09-17'),        (4, 23, '2023-09-09'),        (5, 7, '2023-03-01'),        (2, 32, '2023-08-25'),        (3, 23, '2022-09-27'),        (2, -29, '2023-01-05'),        (3, 17, '2023-03-15'),        (1, 1, '2023-07-20'),        (1, 0, '2022-10-08'),        (4, 15, '2023-09-27'),        (3, 15, '2023-07-07'),        (1, -12, '2022-11-12'),        (2, -5, '2023-04-08'),        (2, 15, '2023-09-18'),        (5, 13, '2022-09-28'),        (3, 8, '2023-03-01'),        (4, -10, '2023-03-12'),        (5, 20, '2023-09-01'),        (5, 25, '2023-09-04'),        (3, 10, '2023-08-28'); "," В зависимости от средней температуры в месяце, метеоресурс характеризует ее определенным типом погоды:  Cold, если средняя температура меньше или равна 15 Hot, если средняя температура больше или равна 25 Warm в остальных случаях Напишите запрос, который извлекает из предложенной базы данных названия стран, а также определяет тип погоды в каждой стране в сентябре 2023 года. При этом в результирующую таблицу должны быть добавлены названия только тех стран, информация о температуре в которых известна.  Поле с названием страны должно иметь псевдоним country, поле с типом погоды в стране — weather_type.  ",30,4,"select name as country, case    when avg(weather_state) <= 15 then 'Cold'   when avg(weather_state) >= 25 then 'Hot'   else 'Warm'   end as weather_type from Countries left join Weather on Countries.id = Weather.country_id where 9 = month(day) and 2023 = year(day) group by country",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS SchoolC; DROP TABLE IF EXISTS SchoolB; DROP TABLE IF EXISTS SchoolA;  -- Создание таблицы SchoolA CREATE TABLE SchoolA (     student_id   INT,     student_name VARCHAR(20) );  INSERT INTO SchoolA (student_id, student_name) VALUES (1, 'Anita'),        (2, 'Blake'),        (3, 'Jose'),        (4, 'Jennifer'),        (5, 'Alexis');  -- Создание таблицы SchoolB CREATE TABLE SchoolB (     student_id   INT,     student_name VARCHAR(20) );  INSERT INTO SchoolB (student_id, student_name) VALUES (6, 'James'),        (7, 'Rebecca');  -- Создание таблицы SchoolC CREATE TABLE SchoolC (     student_id   INT,     student_name VARCHAR(20) );  INSERT INTO SchoolC (student_id, student_name) VALUES (9, 'Anita'),        (3, 'Jose'),        (2, 'Katherine'),        (4, 'Christine'); "," Напишите запрос, который составляет все возможные тройки учеников, выбирая из школ A, B и C по одному ученику, и отображает полученный результат в виде таблицы из трех полей:  student_A — имя ученика из школы A student_B — имя ученика из школы B student_C — имя ученика из школы C При этом в каждой тройке имена и идентификаторы выбранных учеников должны быть попарно различны, то есть не должно быть двух учащихся с одинаковыми именами или одинаковыми идентификаторами.  ",30,5,"select SchoolA.student_name as student_A, SchoolB.student_name as student_B, SchoolC.student_name as student_C from SchoolA cross join SchoolB cross join SchoolC where SchoolA.student_name != SchoolB.student_name and SchoolA.student_name != SchoolC.student_name and SchoolA.student_id != SchoolB.student_id and SchoolA.student_id != SchoolC.student_id",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Students; DROP TABLE IF EXISTS Departments;  -- Создание таблицы Departments CREATE TABLE Departments (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(255) );  INSERT INTO Departments (name) VALUES ('Computer Science'),        ('Medicine'),        ('Trademark and Licensing'),        ('Art History and Archaeology'),        ('Italian');  -- Создание таблицы Students CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     dept_id INT,     FOREIGN KEY (dept_id) REFERENCES Departments(id) );  TRUNCATE Students; INSERT INTO Students (name, dept_id) VALUES ('Alice', 3),        ('Bob', 1),        ('Carol', 2),        ('David', 2),        ('Emma', 1),        ('Frank', 3),        ('Grace', 4),        ('Helen', 4),        ('Ivan', 2),        ('Jack', 3),        ('Kate', 3),        ('Liam', 4),        ('Mary', 2),        ('Nathan', 1),        ('Olivia', 1),        ('Peter', 4),        ('Quinn', 2),        ('Rose', 1),        ('Samuel', 2),        ('Thomas', 3); ","Напишите запрос, который извлекает из предложенной базы данных названия всех факультетов, а также определяет, сколько студентов обучается на каждом факультете.  Поле с названием факультета должно иметь псевдоним department, поле с количеством обучающихся на факультете студентов — students_count.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля students_count, при совпадении — в порядке возрастания значения поля department.  ",20,3,"select Departments.name as department, count(dept_id)  as students_count from Departments left join Students on Departments.id = Students.dept_id group by department order by students_count desc, department",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Votes; DROP TABLE IF EXISTS Candidates;  -- Создание таблицы Candidates CREATE TABLE Candidates (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Candidates (name, surname) VALUES ('Barry', 'Wheeler'),        ('Sarah', 'Breaker'),        ('Cynthia', 'Weaver'),        ('Thomas', 'Zane'),        ('Robert', 'Nightingale'),        ('Emill', 'Hartman');  -- Создание таблицы Votes CREATE TABLE Votes (     id           INT PRIMARY KEY AUTO_INCREMENT,     candidate_id INT,     FOREIGN KEY (candidate_id) REFERENCES Candidates(id) );  TRUNCATE Votes; INSERT INTO Votes (candidate_id) VALUES (2),        (4),        (3),        (2),        (5),        (1),        (2),        (4),        (5),        (2),        (3),        (5),        (1),        (4),        (3),        (2),        (5),        (1),        (4),        (3),        (2),        (4),        (3),        (2),        (5),        (1),        (2),        (4),        (5),        (2),        (3),        (5),        (1),        (4),        (3),        (2),        (5),        (1),        (4),        (3); ","Напишите запрос, извлекающий из предложенной базы данных имя и фамилию кандидата, который набрал наибольшее количество голосов, а также определяющий набранное им количество голосов.  Поле с количеством набранных кандидатом голосов должно иметь псевдоним votes_count.  ",30,4,"select name, surname, count(Votes.candidate_id) as votes_count from Candidates left join Votes on Candidates.id = Votes.candidate_id group by name, surname order by votes_count desc limit 1",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Ads; DROP TABLE IF EXISTS Playback;  -- Создание таблицы Playback CREATE TABLE Playback (     id         INT PRIMARY KEY AUTO_INCREMENT,     user_id    INT,     start_time INT,     end_time   INT );  INSERT INTO Playback (user_id, start_time, end_time) VALUES (4, 179, 369),        (3, 52, 477),        (1, 5, 258),        (3, 490, 535),        (7, 197, 269),        (8, 104, 110),        (2, 158, 438),        (1, 345, 559),        (10, 152, 670),        (6, 132, 539),        (6, 580, 626),        (1, 580, 686),        (4, 380, 424),        (9, 29, 302),        (6, 700, 900),        (3, 570, 647),        (4, 500, 670),        (8, 121, 602),        (4, 680, 687),        (4, 719, 780);  -- Создание таблицы Ads CREATE TABLE Ads (     id         INT PRIMARY KEY AUTO_INCREMENT,     user_id    INT,     time_stamp INT );  TRUNCATE Ads; INSERT INTO Ads (user_id, time_stamp) VALUES (8, 121),        (1, 479),        (8, 1186),        (10, 1319),        (10, 807),        (9, 1427),        (7, 670),        (5, 396),        (6, 926),        (1, 241),        (8, 1188),        (9, 302),        (7, 522),        (3, 162),        (4, 753),        (8, 437),        (8, 1067),        (4, 1122),        (6, 804),        (10, 966); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы сессий, во время которых не была показана рекламная интеграция.  Поле с идентификатором сессии должно иметь псевдоним session_id.  ",30,5,select id as session_id from Playback where id != all( select Playback.id  from Playback join Ads on Playback.user_id = Ads.user_id where time_stamp between start_time and end_time),SELECT Playback.id AS session_id FROM Playback LEFT JOIN Ads ON Ads.user_id = Playback.user_id       AND time_stamp BETWEEN start_time AND end_time WHERE Ads.id IS NULL,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Submissions; CREATE TABLE Submissions (     sub_id    INT,     parent_id INT );  TRUNCATE Submissions; INSERT INTO Submissions (sub_id, parent_id) VALUES (6, NULL),        (9, NULL),        (15, 9),        (14, 9),        (2, 8),        (8, NULL),        (7, 1),        (3, 1),        (11, 1),        (1, NULL),        (10, 9),        (12, 6),        (13, NULL),        (4, 6); ","Первое поле этой таблицы содержит идентификатор поста или комментария. Направленность второго поля определяется первым полем: если первое поле содержит идентификатор поста, то второе поле содержит значение NULL, если же первое поле содержит идентификатор комментария, то второе поле содержит идентификатор поста, к которому был оставлен комментарий. Напишите запрос, который извлекает из предложенной базы данных идентификаторы постов, а также определяет количество комментариев, оставленных под каждым постом.  Поле с идентификатором поста должно иметь псевдоним post_id, поле с количеством оставленных под постом комментариев — number_of_comments.  ",30,6,"select A.sub_id as post_id, count(B.sub_id) as number_of_comments from Submissions as A left join Submissions as B on A.sub_id = B.parent_id where A.parent_id is null group by A.sub_id  order by post_id desc",,
7.5 Соединения. Задачи ,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products (name, price) VALUES ('Apple iPhone 13 Pro', 779),        ('Samsung Galaxy S21', 629),        ('Sony WH-1000XM4 Headphones', 105),        ('Nike Air Zoom Pegasus 38', 415),        ('Adidas Ultraboost 21', 480),        ('Lenovo ThinkPad X1 Carbon', 99),        ('Dell XPS 13 Laptop', 1475),        ('Canon EOS R6 Camera', 1309),        ('Bose QuietComfort 35 II', 435),        ('Samsung 65-inch QLED TV', 345),        ('LG OLED55CXPUA TV', 740),        ('Apple AirPods Pro', 439),        ('Fitbit Versa 3', 139),        ('PlayStation 5', 320),        ('Xbox Series X', 144),        ('Amazon Echo Dot (4th Gen)', 210),        ('GoPro HERO9 Black', 70),        ('Samsung Galaxy Tab S7', 389),        ('Dyson V11 Animal Vacuum', 132),        ('Instant Pot Duo 7-in-1', 283);  -- Создание таблицы Sales CREATE TABLE Sales (     seller_id  INT,     product_id INT,     buyer_id   INT,     sale_date  DATE,     quantity   INT );  TRUNCATE Sales; INSERT INTO Sales (seller_id, product_id, buyer_id, sale_date, quantity) VALUES (9, 13, 6, '2023-07-19', 3),        (4, 20, 8, '2023-07-13', 5),        (6, 8, 2, '2023-06-03', 3),        (2, 16, 6, '2023-03-14', 2),        (8, 8, 6, '2023-05-23', 9),        (1, 14, 3, '2023-01-10', 7),        (10, 3, 6, '2023-03-28', 6),        (3, 13, 4, '2023-01-17', 3),        (1, 10, 4, '2023-01-26', 7),        (10, 17, 3, '2023-06-02', 1),        (10, 13, 4, '2023-05-13', 4),        (8, 19, 2, '2023-02-15', 6),        (1, 15, 4, '2023-06-03', 7),        (1, 5, 1, '2023-05-21', 3),        (1, 13, 9, '2023-04-07', 9),        (7, 12, 2, '2023-06-12', 7),        (1, 6, 3, '2023-02-01', 2),        (5, 11, 4, '2023-03-09', 6),        (8, 19, 6, '2023-06-02', 3),        (1, 12, 6, '2023-02-06', 2),        (7, 9, 10, '2023-05-10', 4),        (2, 16, 5, '2023-05-31', 5),        (2, 18, 8, '2023-03-09', 4),        (10, 12, 2, '2023-02-07', 4),        (9, 2, 9, '2023-06-23', 10),        (2, 14, 10, '2023-04-29', 2),        (4, 11, 8, '2023-07-04', 5),        (3, 6, 6, '2023-01-31', 10),        (4, 17, 2, '2023-07-16', 6),        (10, 13, 4, '2023-07-01', 5),        (2, 12, 5, '2023-04-08', 2),        (4, 10, 4, '2023-04-05', 3),        (8, 18, 1, '2023-05-22', 3),        (5, 2, 1, '2023-02-14', 9),        (8, 10, 2, '2023-04-08', 10),        (8, 18, 10, '2023-02-15', 3),        (6, 13, 4, '2023-02-06', 8),        (1, 7, 4, '2023-05-08', 3),        (4, 9, 3, '2023-07-13', 1),        (1, 20, 8, '2023-01-15', 10),        (6, 9, 6, '2023-03-09', 2),        (6, 8, 4, '2023-05-02', 10),        (10, 14, 4, '2023-07-13', 7),        (7, 4, 9, '2023-06-29', 9),        (1, 6, 3, '2023-01-23', 10),        (10, 10, 6, '2023-02-07', 4),        (2, 12, 5, '2023-05-10', 8),        (3, 1, 4, '2023-04-10', 6),        (8, 17, 7, '2023-05-18', 6); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы покупателей, которые приобрели товар Canon EOS R6 Camera, но не приобрели товар Lenovo ThinkPad X1 Carbon.  ",50,7,select A.buyer_id  from (select buyer_id from Sales  where product_id = (select id from Products                     where Products.id = Sales.product_id                     and Products.name = 'Canon EOS R6 Camera')) as A left join   (select buyer_id from Sales  where product_id = (select id from Products                     where Products.id = Sales.product_id                     and Products.name = 'Lenovo ThinkPad X1 Carbon')) as B on A.buyer_id = B.buyer_id where B.buyer_id is null,SELECT buyer_id FROM Sales INNER JOIN Products ON product_id = Products.id WHERE name = 'Canon EOS R6 Camera' AND       buyer_id NOT IN (SELECT buyer_id                        FROM Sales                        INNER JOIN Products ON product_id = Products.id                        WHERE name = 'Lenovo ThinkPad X1 Carbon'),
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Users;  -- Создание таблицы Users CREATE TABLE Users (     id        INT PRIMARY KEY AUTO_INCREMENT,     join_date DATE );  INSERT INTO Users (join_date) VALUES ('2020-01-05'),        ('2022-02-12'),        ('2023-03-20'),        ('2021-04-15'),        ('2023-05-18'),        ('2023-06-02'),        ('2020-07-09'),        ('2023-08-11'),        ('2022-09-23'),        ('2023-10-14'),        ('2022-11-07'),        ('2023-12-19');  -- Создание таблицы Orders CREATE TABLE Orders (     id         INT PRIMARY KEY AUTO_INCREMENT,     order_date DATE,     item_id    INT,     buyer_id   INT,     seller_id  INT );  TRUNCATE Orders; INSERT INTO Orders (order_date, item_id, buyer_id, seller_id) VALUES ('2023-02-05', 4, 1, 2),        ('2022-03-12', 2, 1, 3),        ('2023-04-20', 3, 2, 3),        ('2023-05-15', 1, 4, 2),        ('2023-06-18', 1, 3, 4),        ('2023-07-02', 2, 2, 4),        ('2021-08-09', 4, 4, 1),        ('2023-09-11', 3, 1, 4),        ('2023-10-23', 1, 2, 1),        ('2023-11-14', 2, 3, 2),        ('2023-12-07', 4, 4, 3),        ('2023-01-19', 3, 1, 2),        ('2022-02-01', 1, 4, 3),        ('2023-03-08', 2, 2, 1),        ('2023-04-25', 4, 3, 4),        ('2020-05-29', 1, 4, 2),        ('2023-06-10', 3, 1, 4),        ('2023-07-21', 2, 2, 3),        ('2023-08-28', 4, 6, 1),        ('2023-09-03', 1, 7, 3),        ('2023-04-20', 4, 2, 1),        ('2022-04-25', 2, 6, 4),        ('2023-04-30', 3, 4, 2),        ('2023-05-05', 1, 8, 2),        ('2023-05-10', 2, 2, 3),        ('2020-05-15', 4, 6, 4),        ('2023-05-20', 3, 6, 1),        ('2020-05-25', 1, 7, 3),        ('2023-05-30', 2, 2, 1),        ('2023-06-05', 4, 7, 2),        ('2023-06-10', 1, 6, 3),        ('2023-06-15', 2, 5, 4),        ('2022-06-20', 3, 4, 2),        ('2022-06-25', 4, 6, 2),        ('2021-06-30', 1, 1, 3),        ('2021-07-05', 3, 5, 1),        ('2023-07-10', 4, 2, 3),        ('2020-07-15', 1, 5, 2),        ('2020-07-20', 2, 6, 4); "," Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех пользователей площадки, а также определяет, сколько покупок совершил каждый пользователь в 2023 году.  Поле с количеством покупок, совершенных пользователем, должно иметь псевдоним purchases_in_2023.",20,3,"select A.id, count(buyer_id) as purchases_in_2023 from Users as A left join (select * from Orders                       where  year(order_date) = 2023) as B                                              on A.id = B.buyer_id group by A.id","SELECT Users.id, COUNT(Orders.id) AS purchases_in_2023 FROM Users LEFT JOIN Orders ON buyer_id = Users.id AND YEAR(order_date) = 2023 GROUP BY Users.id",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS BigBoxes; DROP TABLE IF EXISTS SmallBoxes;  -- Создание таблицы SmallBoxes CREATE TABLE SmallBoxes (     id           INT AUTO_INCREMENT PRIMARY KEY,     apple_count  INT,     orange_count INT );  INSERT INTO SmallBoxes (apple_count, orange_count) VALUES (5, 6),        (20, 10),        (8, 8),        (19, 4),        (19, 19),        (10, 5),        (12, 7),        (15, 9),        (25, 30),        (8, 15),        (10, 12),        (6, 3),        (14, 6),        (13, 12),        (9, 9),        (7, 15),        (11, 11),        (16, 8),        (22, 10),        (18, 16);  -- Создание таблицы BigBoxes CREATE TABLE BigBoxes (     id           INT AUTO_INCREMENT PRIMARY KEY,     small_box_id INT,     apple_count  INT,     orange_count INT );  TRUNCATE BigBoxes; INSERT INTO BigBoxes (small_box_id, apple_count, orange_count) VALUES (null, 6, 15),        (14, 4, 15),        (3, 8, 4),        (2, 19, 20),        (6, 12, 9),        (6, 9, 9),        (14, 16, 7),        (NULL, 7, 15),        (12, 8, 8),        (20, 9, 6),        (8, 10, 12),        (NULL, 5, 7),        (3, 10, 5),        (2, 15, 8),        (NULL, 10, 9),        (18, 20, 15),        (3, 10, 8),        (12, 12, 12),        (NULL, 8, 7),        (20, 7, 6); ","Напишите запрос, который определяет общее количество яблок и количество апельсинов во всех больших коробках. При этом если внутри большой коробки находится маленькая коробка, количество фруктов в маленькой коробке также должно быть учтено.",30,4,"select (sum(B.apple_count) + sum(ifnull(S.apple_count, 0))) as apple_count, (sum(B.orange_count) + sum(ifnull(S.orange_count, 0))) as orange_count  from BigBoxes as B left join SmallBoxes as S on B.small_box_id = S.id","SELECT   SUM(BB.apple_count) + SUM(SB.apple_count) AS apple_count,   SUM(BB.orange_count) + SUM(SB.orange_count) AS orange_count FROM   BigBoxes BB LEFT JOIN SmallBoxes SB ON BB.small_box_id = SB.id;",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Points; CREATE TABLE Points (     id INT AUTO_INCREMENT PRIMARY KEY,     x  INT,     y  INT );  TRUNCATE Points; INSERT INTO Points (x, y) VALUES (2, 7),        (4, 8),        (2, 10),        (1, 1),        (3, 2),        (1, 4),        (5, 3),        (6, 6),        (9, 5); ","Напишите запрос, который определяет все пары точек, образующих прямоугольник с ненулевой площадью, вычисляет площади прямоугольников, образуемых каждой парой, и отображает полученный результат в виде таблицы из трех полей:  p1 — идентификатор первой точки p2 — идентификатор второй точки area — площадь прямоугольника, образуемого этими точками При этом в результирующую таблицу должны быть добавлены только уникальные пары точек. Например, пара точек с идентификаторами 1 и 2, а также пара точек с идентификаторами 2 и 1 считаются одинаковыми. Из них должна быть выбрана только та пара, в которой идентификатор первой точки меньше второй.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля area, при совпадении — в порядке возрастания значения поля p1, при совпадении — в порядке возрастания значения поля p2.",40,5,"select P1.id as p1, P2.id as p2, abs(P1.x - P2.x) * abs(P1.y - P2.y) as area from Points as P1 cross join Points as P2 where P1.id != P2.id   and P1.id < P2.id   and abs(P1.x - P2.x) * abs(P1.y - P2.y) != 0 order by area desc, p1,p2","SELECT Points.id AS p1, Points2.id AS p2,        ABS(Points2.x - Points.x) * ABS(Points2.y - Points.y) AS area FROM Points INNER JOIN Points AS Points2 ON Points.id < Points2.id WHERE Points.x != Points2.x AND Points.y != Points2.y ORDER BY area DESC, p1, p2",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Streams; DROP TABLE IF EXISTS Subscriptions;  -- Создание таблицы Subscriptions CREATE TABLE Subscriptions (     user_id    INT AUTO_INCREMENT PRIMARY KEY,     start_date DATE,     end_date   DATE );  INSERT INTO Subscriptions (start_date, end_date) VALUES ('2022-02-18', '2023-10-30'),        ('2023-09-21', '2023-11-13'),        ('2021-02-28', '2022-08-18'),        ('2023-04-20', '2023-09-22'),        ('2020-10-26', '2021-05-08'),        ('2023-09-11', '2024-01-17'),        ('2023-03-05', '2024-03-30'),        ('2022-08-10', '2023-02-15'),        ('2023-05-15', '2024-05-30'),        ('2021-01-10', '2022-07-15'),        ('2022-06-14', '2023-12-31'),        ('2023-07-20', '2024-01-05'),        ('2022-03-21', '2024-03-31'),        ('2023-01-28', '2023-07-28'),        ('2023-06-02', '2023-12-02'),        ('2023-08-08', '2024-02-08'),        ('2022-04-25', '2022-10-25'),        ('2023-02-10', '2023-08-10'),        ('2021-05-28', '2023-11-28'),        ('2020-01-15', '2023-07-15');  -- Создание таблицы Streams CREATE TABLE Streams (     session_id  INT AUTO_INCREMENT PRIMARY KEY,     user_id     INT,     stream_date DATE );  TRUNCATE Streams; INSERT INTO Streams (user_id, stream_date) VALUES (9, '2023-05-16'),        (3, '2023-10-27'),        (7, '2022-04-29'),        (13, '2022-08-08'),        (4, '2023-12-31'),        (5, '2023-01-05'),        (6, '2023-02-15'),        (7, '2022-03-30'),        (8, '2022-05-25'),        (9, '2022-07-10'),        (10, '2023-08-15'),        (10, '2023-09-20'),        (12, '2023-10-25'),        (13, '2022-11-30'),        (14, '2023-01-05'),        (18, '2023-02-10'),        (14, '2023-03-15'),        (17, '2022-04-20'),        (14, '2023-05-25'),        (19, '2023-06-30'); ","Напишите запрос, определяющий количество пользователей сервиса, которые имели активную подписку в 2023 году, но при этом не провели ни одной трансляции в 2023 году.  Поле с искомым количеством пользователей должно иметь псевдоним users_count.",30,4,"select count(*) as users_count from (select user_id, start_date, end_date from Subscriptions where year(start_date) <= 2023 and year(end_date) >= 2023) as U left join (select user_id, stream_date from Streams where year(stream_date) = 2023) as S on U.user_id = S.user_id where S.stream_date is null",SELECT COUNT(Subscriptions.user_id) AS users_count FROM Subscriptions LEFT JOIN Streams ON Streams.user_id = Subscriptions.user_id AND YEAR(stream_date) = 2023 WHERE (2023 BETWEEN YEAR(start_date) AND YEAR(end_date)) AND Streams.user_id IS NULL,
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     order_date  DATE );  TRUNCATE Orders; INSERT INTO Orders (customer_id, order_date) VALUES (1, '2023-09-05'),        (2, '2023-08-11'),        (8, '2023-07-09'),        (10, '2023-07-18'),        (10, '2023-07-14'),        (8, '2023-07-27'),        (8, '2023-07-21'),        (4, '2023-07-08'),        (8, '2023-07-18'),        (10, '2023-07-09'),        (4, '2023-07-19'),        (1, '2023-09-17'),        (9, '2023-09-17'),        (2, '2023-07-31'),        (9, '2023-09-18'),        (3, '2023-09-02'),        (2, '2023-07-31'),        (5, '2023-08-22'),        (1, '2023-08-24'),        (3, '2023-09-02'),        (6, '2023-10-12'),        (4, '2023-08-05'),        (5, '2023-09-22'),        (10, '2023-08-09'),        (1, '2023-08-18'),        (9, '2023-09-10'),        (9, '2023-08-27'),        (8, '2023-07-17'),        (1, '2023-08-16'),        (8, '2023-08-06'),        (1, '2023-08-29'),        (9, '2023-09-24'),        (4, '2023-07-12'),        (7, '2023-09-18'),        (9, '2023-08-14'),        (8, '2023-07-20'),        (5, '2023-08-16'),        (6, '2023-11-07'),        (2, '2023-07-24'),        (4, '2023-07-17'),        (8, '2023-08-12'),        (5, '2023-08-14'); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы покупателей, которые в течение любых 7 дней совершили как минимум 2 заказа.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля customer_id.  ",30,5,"select distinct O1.customer_id from Orders as O1 cross join Orders as O2 on O1.customer_id = O2.customer_id and O1.id != O2.id where abs(datediff(O1.order_date,O2.order_date)) < 7 order by customer_id ","SELECT DISTINCT O1.customer_id FROM Orders AS O1 INNER JOIN Orders AS O2 ON O1.customer_id = O2.customer_id AND                            O1.id != O2.id AND                            O2.order_date BETWEEN O1.order_date AND DATE_ADD(O1.order_date, INTERVAL 6 DAY) ORDER BY customer_id",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Rides; CREATE TABLE Rides (     id           INT PRIMARY KEY AUTO_INCREMENT,     driver_id    INT,     passenger_id INT );  TRUNCATE Rides; INSERT INTO Rides (id, driver_id, passenger_id) VALUES (1, 16, 19),        (2, 11, 22),        (3, 11, 22),        (4, 7, 1),        (5, 15, 9),        (6, 4, 15),        (7, 10, 17),        (8, 11, 22),        (9, 23, 19),        (10, 6, 27),        (11, 16, 15),        (12, 18, 25),        (13, 18, 23),        (14, 3, 7),        (15, 12, 23),        (16, 22, 12),        (17, 6, 23),        (18, 30, 22),        (19, 3, 10),        (20, 1, 27),        (21, 21, 9),        (22, 9, 8),        (23, 13, 17),        (24, 19, 29),        (25, 20, 3),        (26, 28, 14),        (27, 9, 10),        (28, 23, 19),        (29, 10, 13),        (30, 1, 27); ","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех водителей, а также определяет, сколько раз каждый водитель был в качестве пассажира.  Поле с количеством поездок водителя в качестве пассажира должно иметь псевдоним count.",40,6,"select D.driver_id, ifnull(P.count, 0) as count from (select distinct driver_id from Rides) as D left join (select passenger_id, count(*) as count  from Rides  group by passenger_id) as P on D.driver_id = P.passenger_id order by D.driver_id","SELECT R1.driver_id, COUNT(DISTINCT R2.id) AS count FROM Rides AS R1 LEFT JOIN Rides AS R2 ON R1.driver_id = R2.passenger_id GROUP BY R1.driver_id",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers; DROP TABLE IF EXISTS Salespersons;  -- Создание таблицы Salespersons CREATE TABLE Salespersons (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Salespersons (name) VALUES ('Stephanie'),        ('Rebecca'),        ('Deborah'),        ('Jordan'),        ('Veronica'),        ('Marisa'),        ('Deanna'),        ('Emma'),        ('Julie'),        ('Maria');  -- Создание таблицы Customers CREATE TABLE Customers (     id             INT PRIMARY KEY AUTO_INCREMENT,     salesperson_id INT );  INSERT INTO Customers (salesperson_id) VALUES (5),        (4),        (8),        (10),        (3),        (1),        (6),        (2),        (1),        (4),        (4),        (5),        (8),        (8),        (10),        (5),        (3),        (1),        (6),        (3);  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     price       INT );  TRUNCATE Orders; INSERT INTO Orders (customer_id, price) VALUES (8, 2480),        (6, 654),        (13, 2938),        (4, 2071),        (4, 2412),        (1, 236),        (17, 2514),        (18, 849),        (7, 925),        (10, 93),        (14, 449),        (15, 923),        (14, 160),        (1, 1978),        (14, 2903),        (13, 2093),        (14, 2429),        (12, 1058),        (18, 2342),        (19, 484),        (4, 1040),        (14, 2346),        (19, 239),        (14, 2253),        (20, 510),        (12, 497),        (6, 1638),        (9, 1088),        (6, 1766),        (2, 1548); "," Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех продавцов, а также определяет общую сумму, заработанную каждым продавцом.  Поле с заработанной продавцом суммой должно иметь псевдоним total.",30,5,"select  S.id, ifnull(sum(O.price), 0) as total from Customers as C right join Orders as O on C.id = O.customer_id                     right join Salespersons as S on C.salesperson_id = S.id group by S.id","SELECT   s.id,   SUM(COALESCE(o.price, 0)) AS total FROM   Salespersons AS s   LEFT JOIN Customers AS c ON c.salesperson_id = s.id   LEFT JOIN Orders AS o ON o.customer_id = c.id GROUP BY   s.id;",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Visits; DROP TABLE IF EXISTS Members;  -- Создание таблицы Members CREATE TABLE Members (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50) );  INSERT INTO Members (name) VALUES ('John'),        ('Sarah'),        ('Michael'),        ('Emily'),        ('David'),        ('Sophia'),        ('Liam'),        ('Olivia'),        ('Daniel'),        ('Ava'),        ('Ethan'),        ('Mia');  -- Создание таблицы Visits CREATE TABLE Visits (     id         INT PRIMARY KEY,     member_id  INT,     visit_date DATE );  INSERT INTO Visits (id, member_id, visit_date) VALUES (101, 2, '2023-10-28'),        (102, 4, '2022-01-12'),        (103, 1, '2023-12-10'),        (104, 5, '2022-10-19'),        (105, 6, '2021-03-01'),        (106, 9, '2023-05-07'),        (107, 11, '2023-05-12'),        (108, 3, '2023-06-18'),        (109, 7, '2023-09-30'),        (110, 12, '2023-08-15'),        (111, 5, '2023-10-25'),        (112, 5, '2022-02-11'),        (113, 1, '2023-12-01'),        (114, 6, '2022-09-09'),        (115, 6, '2021-05-01'),        (116, 6, '2023-03-07'),        (117, 11, '2023-07-19'),        (118, 12, '2022-04-18'),        (119, 11, '2021-08-30'),        (120, 6, '2023-08-05');  -- Создание таблицы Purchases CREATE TABLE Purchases (     visit_id       INT,     charged_amount INT );  TRUNCATE Purchases; INSERT INTO Purchases (visit_id, charged_amount) VALUES (102, 2000),        (103, 9000),        (106, 7000),        (108, 500),        (105, 1500),        (101, 200),        (109, 3000),        (119, 400),        (110, 7000),        (120, 5000),        (116, 12000),        (111, 7000),        (115, 350),        (118, 10500),        (117, 100); ","Для каждого посетителя магазин определяет коэффициент конверсии, который вычисляется следующим образом: 100 ⋅ общее количество совершенных покупок общее количество посещений магазина общееколичествопосещениймагазина 100⋅общееколичествосовершенныхпокупок ​    На основе коэффициента конверсии магазин определяет статус посетителя:  Diamond, если коэффициент конверсии больше или равен 80 Gold, если коэффициент конверсии больше или равен 50 и меньше 80 Silver, если коэффициент конверсии меньше 50 Bronze, если посетитель ни разу не был в магазине Напишите запрос, который извлекает из предложенной базы данных идентификаторы и имена всех посетителей магазина, а также определяет статус каждого посетителя.  Поле со статусом посетителя должно иметь псевдоним status.",50,6,"select M.id, M.name, case                         when ((100*count(P.charged_amount))/count(V.id)) >= 80 then 'Diamond'                        when ((100*count(P.charged_amount))/count(V.id)) >= 50                              and ((100*count(P.charged_amount))/count(V.id)) < 80 then 'Gold'                        when ((100*count(P.charged_amount))/count(V.id)) < 50 then 'Silver'                        else 'Bronze'                        end as status  from Visits as V left join Purchases as P on V.id = P.visit_id                  right join Members as M on V.member_id = M.id group by M.id","select  id,  name,  case    when score < 0 then 'Bronze'   when score < 50 then 'Silver'   when score < 80 then 'Gold'   else 'Diamond'  end as status from (  select   Members.id,   Members.name,   ifnull(100 * count(Purchases.visit_id) / count(Visits.id), -1) as score  from   Members   left join Visits on Visits.member_id = Members.id   left join Purchases on Purchases.visit_id = Visits.id  group by    Members.id,   Members.name ) as scores",
7.6 Соединения. Задачи ,"DROP TABLE IF EXISTS Trips; DROP TABLE IF EXISTS Users;  -- Создание таблицы Users CREATE TABLE Users (     id       INT AUTO_INCREMENT PRIMARY KEY,     banned   VARCHAR(50),     role     ENUM ('client', 'driver') );  INSERT INTO Users(banned, role) VALUES ('yes', 'client'),        ('yes', 'client'),        ('no', 'client'),        ('no', 'client'),        ('no', 'client'),        ('no', 'driver'),        ('no', 'driver'),        ('no', 'driver'),        ('no', 'driver'),        ('yes', 'driver'),        ('no', 'driver');  -- Создание таблицы Trips CREATE TABLE Trips (     id         INT PRIMARY KEY AUTO_INCREMENT,     client_id  INT,     driver_id  INT,     status     ENUM ('completed', 'cancelled_by_driver', 'cancelled_by_client'),     request_at VARCHAR(50) );  TRUNCATE Trips; INSERT INTO Trips(client_id, driver_id, status, request_at) VALUES (3, 6, 'completed', '2023-10-01'),        (4, 8, 'completed', '2023-10-01'),        (2, 9, 'completed', '2023-10-01'),        (1, 8, 'cancelled_by_client', '2023-10-01'),        (5, 11, 'completed', '2023-10-02'),        (5, 11, 'cancelled_by_driver', '2023-10-02'),        (2, 10, 'completed', '2023-10-02'),        (2, 8, 'completed', '2023-10-02'),        (3, 11, 'completed', '2023-10-02'),        (3, 7, 'cancelled_by_driver', '2023-10-03'),        (2, 6, 'cancelled_by_driver', '2023-10-03'),        (4, 8, 'completed', '2023-10-03'),        (2, 11, 'completed', '2023-10-03'),        (3, 10, 'completed', '2023-10-04'),        (1, 10, 'completed', '2023-10-05'),        (4, 8, 'completed', '2023-10-05'),        (2, 8, 'cancelled_by_driver', '2023-10-05'),        (5, 9, 'completed', '2023-10-05'),        (2, 6, 'completed', '2023-10-05'),        (5, 8, 'completed', '2023-10-06'),        (3, 9, 'completed', '2023-10-06'),        (2, 10, 'completed', '2023-10-07'),        (2, 6, 'completed', '2023-10-07'),        (3, 6, 'completed', '2023-10-08'),        (3, 7, 'completed', '2023-10-08'),        (5, 8, 'completed', '2023-10-09'),        (2, 8, 'completed', '2023-10-09'),        (2, 11, 'completed', '2023-10-09'),        (4, 10, 'completed', '2023-10-09'),        (3, 11, 'completed', '2023-10-10'); ","Каждый день службе такси необходимо знать коэффициент отмененных поездок, который вычисляется путем деления количества отмененных в день поездок (водителем или пассажиром) на количество всех совершенных в этот день поездок. Причем те поездки, в которых водитель или пассажир заблокированы, не учитываются.  Напишите запрос, который для дней 2023-10-01, 2023-10-02 и 2023-10-03 определяет коэффициент отмененных поездок и отображает полученный результат в виде таблицы из двух полей:  day — день cancellation_rate — коэффициент поездок, отмененных в этот день  Значения в поле cancellation_rate должны быть округлены до 2 знаков после запятой.",60,7,"select request_at as day, round(max(if(status = 'cancelled_by_driver' or status = 'cancelled_by_client', 1, 0))/count(*), 2) as cancellation_rate from Trips as T left join Users as U on T.client_id = U.id                 left join Users as U1 on T.driver_id = U1.id where request_at in ('2023-10-01', '2023-10-02', '2023-10-03') and U.banned != 'yes' and U1.banned != 'yes' group by request_at  ","SELECT request_at AS day,        ROUND(SUM(status != 'completed') / COUNT(status), 2) AS cancellation_rate FROM Trips INNER JOIN Users AS U1 ON client_id = U1.id INNER JOIN Users AS U2 ON driver_id = U2.id WHERE (request_at BETWEEN '2023-10-01' AND '2023-10-03') AND (U1.banned, U2.banned) = ('no', 'no') GROUP BY request_at",
8.1 Обновление данных ,"Создание таблицы Grades CREATE TABLE Grades (     student_id INT,     class_id   INT,     grade      INT );  INSERT INTO Grades (student_id, class_id, grade) VALUES (3, 3, 5),        (1, 1, 5),        (3, 1, 4),        (1, 2, 5),        (2, 1, 3),        (2, 2, 4),        (1, 3, 5),        (2, 3, 3),        (3, 2, 5); ","Напишите запрос, который изменяет в таблице Grades все оценки на 5",5,1,update Grades set grade = 5,,
8.1 Обновление данных ,"CREATE TABLE Grades (     student_id INT,     class_id   INT,     grade      INT );  INSERT INTO Grades (student_id, class_id, grade) VALUES (3, 3, 5),        (1, 1, 5),        (3, 1, 4),        (1, 2, 5),        (2, 1, 3),        (2, 2, 4),        (1, 3, 5),        (2, 3, 3),        (3, 2, 5); ","Напишите запрос, который изменяет в таблице Grades все оценки, равные 4, на 5.  ",5,1,update Grades set grade = 5 where grade = 4,,
8.1 Обновление данных ,"CREATE TABLE Grades (     student_id INT,     class_id   INT,     grade      VARCHAR(20) );  INSERT INTO Grades (student_id, class_id, grade) VALUES (3, 3, 'A'),        (1, 1, 'D'),        (3, 1, 'B'),        (1, 2, 'A'),        (2, 1, 'C'),        (2, 2, 'B'),        (1, 3, 'E'),        (2, 3, 'C'),        (3, 2, 'A'); ","Напишите запрос, который изменяет в таблице Grades все оценки на их текстовые эквиваленты:  Оценка Описание A Great B Great C Well D Bad E Bad",15,3,"update Grades set grade = case   when grade in ('A', 'B') then 'Great'    when grade = 'C' then 'Well'   when grade in ('D', 'E') then 'Bad'   end","UPDATE Grades SET grade = CASE                  WHEN grade IN ('A', 'B') THEN 'Great'                 WHEN grade = 'C' THEN 'Well'                 ELSE 'Bad'             END ",
8.1 Обновление данных ,"DROP TABLE IF EXISTS Grades; DROP TABLE IF EXISTS Classes; DROP TABLE IF EXISTS Students;  -- Создание таблицы Students CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     student VARCHAR(40) );  INSERT INTO Students (student) VALUES ('Peter Parker'),        ('Mary Jane'),        ('Gwen Stacy');  -- Создание таблицы Classes CREATE TABLE Classes (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Classes (name) VALUES ('Math'),        ('Chemistry'),        ('Biology');  -- Создание таблицы Grades CREATE TABLE Grades (     student_id INT,     class_id   INT,     grade      INT );  INSERT INTO Grades (student_id, class_id, grade) VALUES (1, 3, 3),        (1, 1, 3),        (3, 1, 4),        (1, 2, 4),        (2, 1, 3),        (2, 2, 4),        (1, 3, 5),        (2, 3, 3),        (3, 2, 5); ","Напишите запрос, который изменяет в таблице Grades все оценки студента Peter Parker на 5.  ",15,2,update Grades set grade = 5 where student_id = (select id from Students                     where student = 'Peter Parker'),,
8.1 Обновление данных ,"DROP TABLE IF EXISTS Grades; DROP TABLE IF EXISTS Classes; DROP TABLE IF EXISTS Students;  -- Создание таблицы Students CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     student VARCHAR(40) );  INSERT INTO Students (student) VALUES ('Peter Parker'),        ('Mary Jane'),        ('Gwen Stacy');  -- Создание таблицы Classes CREATE TABLE Classes (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Classes (name) VALUES ('Math'),        ('Chemistry'),        ('Biology');  -- Создание таблицы Grades CREATE TABLE Grades (     student_id INT,     class_id   INT,     grade      INT );  INSERT INTO Grades (student_id, class_id, grade) VALUES (2, 1, 4),        (1, 1, 5),        (3, 1, 4),        (1, 2, 5),        (2, 1, 3),        (2, 2, 4),        (1, 3, 5),        (2, 3, 3),        (2, 1, 5); ","Напишите запрос, который изменяет в таблице Grades все оценки студентки Mary Jane по предмету Math на 5.  ",20,3,update Grades set grade = 5 where student_id = (select id from Students                     where student = 'Mary Jane')       and class_id = (select id from Classes                       where name = 'Math'),UPDATE Students JOIN Grades ON Students.id = student_id         JOIN Classes ON Classes.id = Grades.class_id SET grade = 5 WHERE student = 'Mary Jane' AND name = 'Math',
8.1 Обновление данных ,"DROP TABLE IF EXISTS Grades; DROP TABLE IF EXISTS Classes; DROP TABLE IF EXISTS Students;  -- Создание таблицы Students CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     student VARCHAR(40) );  INSERT INTO Students (student) VALUES ('Peter Parker'),        ('Mary Jane'),        ('Gwen Stacy');  -- Создание таблицы Classes CREATE TABLE Classes (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Classes (name) VALUES ('Math'),        ('Chemistry'),        ('Biology');  -- Создание таблицы Grades CREATE TABLE Grades (     student_id      INT,     class_id        INT,     grade           INT,     date_of_receipt DATE );  INSERT INTO Grades (student_id, class_id, grade, date_of_receipt) VALUES (3, 1, 4, '2023-07-28'),        (1, 3, 5, '2023-07-28'),        (3, 3, 4, '2023-07-26'),        (1, 2, 5, '2023-07-27'),        (2, 3, 3, '2023-07-28'),        (2, 2, 4, '2023-07-27'),        (1, 3, 5, '2023-07-26'),        (2, 1, 3, '2023-07-26'),        (3, 2, 5, '2023-07-27'); ","Напишите запрос, который изменяет в таблице Grades все оценки, полученные студентами 2023-07-26 по предмету Biology, на значение NULL.",20,3,update Grades as g join Students as s on g.student_id = s.id join Classes as c on g.class_id = c.id set grade = null where name = 'Biology'  and date_of_receipt = '2023-07-26',UPDATE Grades  SET grade = NULL WHERE date_of_receipt = '2023-07-26' AND        class_id = (SELECT id                   FROM Classes                   WHERE name = 'Biology'),
8.1 Обновление данных ,"DROP TABLE IF EXISTS Grades; DROP TABLE IF EXISTS Classes; DROP TABLE IF EXISTS Students;  -- Создание таблицы Students CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     student VARCHAR(40) );  INSERT INTO Students (student) VALUES ('Peter Parker'),        ('Mary Jane'),        ('Gwen Stacy');  -- Создание таблицы Classes CREATE TABLE Classes (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Classes (name) VALUES ('Math'),        ('Chemistry'),        ('Biology');  -- Создание таблицы Grades CREATE TABLE Grades (     student_id      INT,     class_id        INT,     grade           INT,     date_of_receipt DATE );  INSERT INTO Grades (student_id, class_id, grade, date_of_receipt) VALUES (3, 1, 4, '2023-07-28'),        (1, 1, 5, '2023-07-28'),        (3, 3, 4, '2023-07-26'),        (1, 2, 5, '2023-07-27'),        (2, 1, 3, '2023-07-28'),        (2, 2, 4, '2023-07-27'),        (1, 3, 5, '2023-07-26'),        (2, 3, 3, '2023-07-26'),        (3, 2, 5, '2023-07-27'); ","Напишите запрос, который изменяет в таблице Grades самую первую полученную студенткой Gwen Stacy оценку на 5.  ",25,4,update Grades  set grade = 5 where student_id = (select id from Students                     where student = 'Gwen Stacy') order by date_of_receipt limit 1,,
8.1 Обновление данных ,"DROP TABLE IF EXISTS Grades; DROP TABLE IF EXISTS Classes; DROP TABLE IF EXISTS Students;  -- Создание таблицы Students CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     student VARCHAR(40) );  INSERT INTO Students (student) VALUES ('Peter Parker'),        ('Mary Jane'),        ('Gwen Stacy');  -- Создание таблицы Classes CREATE TABLE Classes (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Classes (name) VALUES ('Math'),        ('Chemistry'),        ('Biology');  -- Создание таблицы Grades CREATE TABLE Grades (     student_id      INT,     class_id        INT,     grade           INT,     date_of_receipt DATE );  INSERT INTO Grades (student_id, class_id, grade, date_of_receipt) VALUES (3, 1, 4, '2023-07-26'),        (1, 1, 5, '2023-07-28'),        (3, 3, 4, '2023-07-28'),        (1, 2, 5, '2023-07-27'),        (2, 1, 3, '2023-07-28'),        (2, 2, 4, '2023-07-27'),        (1, 3, 5, '2023-07-26'),        (2, 3, 3, '2023-07-26'),        (3, 2, 5, '2023-07-27'); ","Напишите запрос, который изменяет в таблице Grades самую последнюю полученную студенткой Gwen Stacy оценку на 5.  ",15,4,update Grades  set grade = 5 where student_id = (select id from Students                     where student = 'Gwen Stacy') order by date_of_receipt desc limit 1 ;,,
8.1 Обновление данных ,"DROP TABLE IF EXISTS author CASCADE; CREATE TABLE IF NOT EXISTS author (  author_id   int PRIMARY KEY GENERATED ALWAYS AS IDENTITY,  name_author text );  INSERT INTO author(name_author) VALUES ('Булгаков М.А.'),        ('Достоевский Ф.М.'),        ('Есенин С.А.'),        ('Пастернак Б.Л.'),        ('Лермонтов М.Ю.');  DROP TABLE IF EXISTS genre CASCADE; CREATE TABLE IF NOT EXISTS genre (  genre_id   INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,  name_genre TEXT );  INSERT INTO genre(name_genre) VALUES ('Роман'),        ('Поэзия'),        ('Приключения');  DROP TABLE IF EXISTS book CASCADE; CREATE TABLE IF NOT EXISTS book (  book_id   INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,  title     TEXT,  author_id INT NOT NULL,  genre_id  INT,  price     DECIMAL(8, 2),  amount    INT,  FOREIGN KEY (author_id) REFERENCES author (author_id) ON DELETE CASCADE,  FOREIGN KEY (genre_id) REFERENCES genre (genre_id) ON DELETE SET NULL );  INSERT INTO book(title, author_id, genre_id, price, amount) VALUES ('Мастер и Маргарита', 1, 1, 670.99, 3),        ('Белая гвардия', 1, 1, 540.50, 5),        ('Идиот', 2, 1, 460.00, 10),        ('Братья Карамазовы', 2, 1, 799.01, 3),        ('Игрок', 2, 1, 480.50, 10),        ('Стихотворения и поэмы', 3, 2, 650.00, 15),        ('Черный человек', 3, 2, 570.20, 6),        ('Лирика', 4, 2, 518.99, 2);  DROP TABLE IF EXISTS supply; CREATE TABLE IF NOT EXISTS supply (  supply_id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,  title     TEXT,  author    TEXT,  price     DECIMAL(8, 2),  amount    INT );  INSERT INTO supply(title, author, price, amount) VALUES ('Доктор Живаго', 'Пастернак Б.Л.', 380.80, 4),        ('Черный человек', 'Есенин С.А.', 570.20, 6),        ('Белая гвардия', 'Булгаков М.А.', 540.50, 7),        ('Идиот', 'Достоевский Ф.М.', 360.80, 3),        ('Стихотворения и поэмы', 'Лермонтов М.Ю.', 255.90, 4),        ('Остров сокровищ', 'Стивенсон Р.Л.', 599.99, 5); "," Для книг, которые уже есть на складе (в таблице book), но по другой цене, чем в поставке (supply),  необходимо в таблице book увеличить количество на значение, указанное в поставке,  и пересчитать цену. А в таблице  supply обнулить количество этих книг. Формула для пересчета цены:  p r i c e = ( p 1 ∗ k 1 + p 2 ∗ k 2 ) k 1 + k 2 price=  k  1 ​  +k  2 ​   (p  1 ​  ∗k  1 ​  +p  2 ​  ∗k  2 ​  ) ​   где  p1, p2 - цена книги в таблицах book и supply;         k1, k2 - количество книг в таблицах book и supply.",40,7,"update book b join author a using (author_id) , supply s set b.amount = b.amount + s.amount,     b.price = (b.amount * b.price + s.amount * s.price)/(b.amount + s.amount),     s.amount = 0 where b.title = s.title and b.price != s.price and s.author = a.name_author;  select * from book; select * from supply;","with aa as ( select a.author_id   , a.name_author   , s.title   , s.price   , s.amount from author a join supply s on a.name_author = s.author  join book b on a.author_id = b.author_id and b.title = s.title and b.price != s.price ), bb as ( update supply s set amount = 0 from aa where aa.title = s.title and aa.name_author = s.author )       update book b set amount = b.amount + aa.amount,     price = (b.amount * b.price + aa.amount * aa.price)/(b.amount + aa.amount)    from aa        where aa.title = b.title and aa.author_id = b.author_id       returning *      ",
8.2 Удаление данных ,"CREATE TABLE Purchases (     id          INT PRIMARY KEY AUTO_INCREMENT,     film_id     INT,     user_id     INT,     FOREIGN KEY (film_id) REFERENCES Films(id),     FOREIGN KEY (user_id) REFERENCES Users(id) );  INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который удаляет из таблицы Purchases всю информацию о совершенных пользователями покупках.  ",5,1,delete from Purchases ,TRUNCATE Purchases; ,
8.2 Удаление данных ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id   INT PRIMARY KEY AUTO_INCREMENT,     user VARCHAR(40) );  INSERT INTO Users (user) VALUES ('Matt Damon'),        ('Edward Norton'),        ('Nicolas Cage'),        ('Ben Affleck'),        ('John Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT,     FOREIGN KEY (film_id) REFERENCES Films(id),     FOREIGN KEY (user_id) REFERENCES Users(id) );  INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 4),        (9, 4),        (6, 1),        (7, 1),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который удаляет из таблицы Users информацию о пользователях, которые не приобрели ни одного фильма.",10,2,delete from Users using Users left join Purchases on Users.id = Purchases.user_id where user_id is null,DELETE FROM Users WHERE id NOT IN (SELECT user_id                   FROM Purchases),
8.2 Удаление данных ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id   INT PRIMARY KEY AUTO_INCREMENT,     user VARCHAR(40) );  INSERT INTO Users (user) VALUES ('Matt Damon'),        ('Edward Norton'),        ('Nicolas Cage'),        ('Ben Affleck'),        ('John Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT,     FOREIGN KEY (film_id) REFERENCES Films(id),     FOREIGN KEY (user_id) REFERENCES Users(id) );  INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (5, 1),        (10, 1),        (7, 2),        (6, 3); ","Напишите запрос, который удаляет из таблицы Purchases информацию о двух последних совершенных покупках пользователем Matt Damon.",10,2,delete from Purchases where user_id = (select id from Users                  where user = 'Matt Damon') order by id desc limit 2,,
8.2 Удаление данных ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id   INT PRIMARY KEY AUTO_INCREMENT,     user VARCHAR(40) );  INSERT INTO Users (user) VALUES ('Matt Damon'),        ('Edward Norton'),        ('Nicolas Cage'),        ('Ben Affleck'),        ('John Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT,     FOREIGN KEY (film_id) REFERENCES Films(id),     FOREIGN KEY (user_id) REFERENCES Users(id) );  INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который удаляет из таблицы Users информацию о пользователе Matt Damon с предварительным удалением информации о покупках, совершенных этим пользователем.",20,4,delete from Purchases using Purchases join Users on Purchases.user_id = Users.id where Users.user = 'Matt Damon' ; delete from Users where user = 'Matt Damon' ;,DELETE FROM Purchases WHERE user_id = (SELECT id                  FROM Users                  WHERE user = 'Matt Damon');  DELETE FROM Users WHERE user = 'Matt Damon',
8.2 Удаление данных ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id   INT PRIMARY KEY AUTO_INCREMENT,     user VARCHAR(40) );  INSERT INTO Users (user) VALUES ('Matt Damon'),        ('Edward Norton'),        ('Nicolas Cage'),        ('Ben Affleck'),        ('John Travolta');  -- Создание таблицы Purchases CREATE TABLE Purchases (     id          INT PRIMARY KEY AUTO_INCREMENT,     film_id     INT,     user_id     INT,     FOREIGN KEY (film_id) REFERENCES Films(id),     FOREIGN KEY (user_id) REFERENCES Users(id) ); INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (9, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, который удаляет из таблицы Films информацию о фильмах серии Toy Story с предварительным удалением информации о покупках фильмов этой серии.",20,3,delete from Purchases using Purchases join Films on Purchases.film_id = Films.id where title like 'Toy Story%' ; delete from Films where title like 'Toy Story%',DELETE FROM Purchases WHERE film_id IN (SELECT id                   FROM Films                   WHERE title LIKE 'Toy Story%');  DELETE FROM Films WHERE title LIKE 'Toy Story%',
8.3 Добавление данных ,"DROP TABLE IF EXISTS Songs; CREATE TABLE Songs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO Songs (id, trackname, artist) VALUES (1, 'Crazy on You', 'Heart'),        (2, 'My Lover', 'The Sounds'),        (3, 'Spent the Day in Bed', 'Morrissey'),        (4, 'Bigmouth Strikes Again', 'The Smiths'),        (5, 'Everyday is Like Sunday', 'Morrissey'); ","Напишите запрос, который добавляет в таблицу Songs информацию о песне под названием Let Me Kiss You, исполнителем которой является Morrissey. Идентификатор добавляемой песни должен быть на единицу больше идентификатора последней песни в таблице Songs.",15,3,"insert into Songs (id, trackname, artist)   value ((select max(id) from Songs as S)+1, 'Let Me Kiss You', 'Morrissey')","insert into Songs  set trackname = 'Let Me Kiss You',     artist = 'Morrissey',     id = (select max(id)           from Songs as S) + 1;",
8.3 Добавление данных ,"DROP TABLE IF EXISTS Songs; CREATE TABLE Songs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO Songs (id, trackname, artist) VALUES (1, 'Crazy on You', 'Heart'),        (2, 'My Lover', 'The Sounds'),        (3, 'Spent the Day in Bed', 'Morrissey'),        (4, 'Bigmouth Strikes Again', 'The Smiths'),        (5, 'Everyday is Like Sunday', 'Morrissey'); ","Напишите запрос, который добавляет в таблицу Songs информацию о трех следующих песнях:  Название Исполнитель Running up That Hill Kate Bush Thrill The Sounds Keep Yourself Alive Queen Идентификатор добавляемой первой песни должен быть на единицу больше идентификатора последней песни в таблице Songs, идентификаторы следующих песен — на два и на три соответственно.  ",25,4,"insert into Songs (id, trackname, artist) values ((select max(id)+1 from Songs as S), 'Running up That Hill', 'Kate Bush'),       ((select max(id)+1 from Songs as S), 'Thrill', 'The Sounds'),       ((select max(id)+1 from Songs as S), 'Keep Yourself Alive', 'Queen')","INSERT INTO Songs VALUES ((@max_id := (SELECT MAX(id) + 1 FROM Songs AS S)), 'Running up That Hill', 'Kate Bush'),        (@max_id + 1, 'Thrill', 'The Sounds'),        (@max_id + 2, 'Keep Yourself Alive', 'Queen');",
8.3 Добавление данных ,"DROP TABLE IF EXISTS Songs; CREATE TABLE Songs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO Songs (id, trackname, artist) VALUES (1, 'Crazy on You', 'Heart'),        (2, 'My Lover', 'The Sounds'),        (3, 'Spent the Day in Bed', 'Morrissey'),        (4, 'Bigmouth Strikes Again', 'The Smiths'),        (5, 'Everyday is Like Sunday', 'Morrissey'); ","Таблица NewSongs имеет ту же структуру, что и таблица Songs, но не содержит ни одной записи.  Напишите запрос, который копирует содержимое таблицы Songs в таблицу NewSongs.",10,1,"insert into NewSongs (id, trackname, artist) select id, trackname, artist  from Songs",,
8.3 Добавление данных ,"DROP TABLE IF EXISTS Songs;  CREATE TABLE Songs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO Songs (id, trackname, artist) VALUES (1, 'Crazy on You', 'Heart'),        (2, 'My Lover', 'The Sounds'),        (3, 'Spent the Day in Bed', 'Morrissey'),        (4, 'Bigmouth Strikes Again', 'The Smiths'),        (5, 'Everyday is Like Sunday', 'Morrissey'); ","Таблица MorrisseySongs имеет ту же структуру, что и таблица Songs, но не содержит ни одной записи.  Напишите запрос, который копирует информацию о песнях исполнителя Morrissey из таблицы Songs в таблицу MorrisseySongs, а затем удаляет информацию о песнях данного исполнителя из таблицы Songs.",20,2,insert into MorrisseySongs select *  from Songs where artist = 'Morrissey' ; delete from Songs where artist = 'Morrissey',INSERT INTO MorrisseySongs SELECT * FROM Songs WHERE artist = 'Morrissey';  DELETE FROM Songs WHERE artist = 'Morrissey',
8.3 Добавление данных ,"DROP TABLE IF EXISTS Songs; CREATE TABLE Songs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO Songs (id, trackname, artist) VALUES (1, 'Crazy on You', 'Heart'),        (2, 'My Lover', 'The Sounds'),        (3, 'Spent the Day in Bed', 'Morrissey'),        (4, 'Bigmouth Strikes Again', 'The Smiths'),        (5, 'Everyday is Like Sunday', 'Morrissey'); ","Таблица NewSongs имеет ту же структуру, что и таблица Songs, но не содержит ни одной записи.  Напишите запрос, который копирует информацию о первой и последней песнях из таблицы Songs в таблицу NewSongs.  ",15,2,"insert into NewSongs select * from Songs where id in ((select max(id) from Songs), (select min(id) from Songs))","INSERT INTO NewSongs (id, trackname, artist) SELECT id, trackname, artist FROM Songs WHERE id IN (   SELECT MIN(id) FROM Songs   UNION   SELECT MAX(id) FROM Songs );",
8.3 Добавление данных ,"DROP TABLE IF EXISTS NewSongs; DROP TABLE IF EXISTS Songs;  -- Создание таблицы Songs CREATE TABLE Songs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO Songs (id, trackname, artist) VALUES (1, 'Crazy on You', 'Heart'),        (2, 'My Lover', 'The Sounds'),        (3, 'Spent the Day in Bed', 'Morrissey'),        (4, 'Bigmouth Strikes Again', 'The Smiths'),        (5, 'Everyday is Like Sunday', 'Morrissey');  -- Создание таблицы NewSongs CREATE TABLE NewSongs (     id        INT PRIMARY KEY,     trackname VARCHAR(40),     artist    VARCHAR(40) );  INSERT INTO NewSongs (id, trackname, artist) VALUES (1, 'Thrill', 'The Sounds'),        (2, 'Painted By Numbers', 'The Sounds'),        (3, 'Let Me Kiss You', 'Morrissey'); "," Напишите запрос, который добавляет в таблицу NewSongs информацию о песнях из таблицы Songs. Идентификатор первой добавляемой песни должен быть на единицу больше идентификатора последней песни в таблице NewSongs, идентификаторы следующих песен — на два, на три, и так далее.",20,4,"insert into NewSongs (id, trackname, artist) select (select max(id) from NewSongs) + Songs.id, trackname, artist from Songs","INSERT INTO NewSongs SELECT (SELECT MAX(id)         FROM NewSongs) + id,         trackname, artist FROM Songs",
9.1 Создание таблиц. Часть 1 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать четыре следующих поля с учетом порядка:  id (тип INT) — идентификатор студента name (тип VARCHAR(20)) — имя студента surname (тип VARCHAR(20)) — фамилия студента age (тип INT) — возраст студента",10,1,"create table Students (     id      int,     name    varchar(20),     surname varchar(20),     age     int );",,
9.1 Создание таблиц. Часть 1 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать четыре следующих поля с учетом порядка:  id (тип INT) — идентификатор студента; поле не должно содержать значение NULL  name (тип VARCHAR(20)) — имя студента; поле не должно содержать значение NULL  surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать значение NULL  age (тип INT) — возраст студента ",15,2,"create table Students (     id      int not null,     name    varchar(20) not null,     surname varchar(20) not null,     age     int );",,
9.1 Создание таблиц. Часть 1 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать четыре следующих поля с учетом порядка:  id (тип INT) — идентификатор студента; поле не должно содержать повторяющиеся значения и значение NULL  name (тип VARCHAR(20)) — имя студента; поле не должно содержать значение NULL  surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать значение NULL  age (тип INT) — возраст студента ",10,2,"create table Students (     id      int not null unique,     name    varchar(20) not null,     surname varchar(20) not null,     age     int );",,
9.1 Создание таблиц. Часть 1 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать четыре следующих поля с учетом порядка:  id (тип INT) — идентификатор студента; поле не должно содержать повторяющиеся значения и значение NULL  name (тип VARCHAR(20)) — имя студента; поле не должно содержать значение NULL  surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать значение NULL  age (тип INT) — возраст студента; в качестве значения по умолчанию поле должно иметь число 18",10,2,"create table Students (     id      int unique not null,     name    varchar(20) not null,     surname varchar(20) not null,     age     int default 18 );",,
9.1 Создание таблиц. Часть 1 ,," Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать пять следующих полей с учетом порядка:  id (тип INT) — идентификатор студента; поле не должно содержать повторяющиеся значения и значение NULL  name (тип VARCHAR(20)) — имя студента; поле не должно содержать значение NULL  surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать значение NULL  age (тип INT) — возраст студента; в качестве значения по умолчанию поле должно иметь число 18 date_of_receipt (тип DATE) — дата поступления студента на учебу; в качестве значения по умолчанию поле должно иметь текущую дату Примечание. Например, если текущей датой является 2023-11-01, то при добавлении записи в таблицу Students без указания значения поля date_of_receipt значением этого поля должна быть дата 2023-11-01.",15,2,"create table Students (     id     int not null unique,     name   varchar(20) not null,     surname varchar(20) not null,     age     int default 18,     date_of_receipt date default (curdate()) );",,
9.1 Создание таблиц. Часть 1 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать пять следующих полей с учетом порядка:  id (тип INT) — идентификатор студента; поле не должно содержать повторяющиеся значения и значение NULL name (тип VARCHAR(20)) — имя студента; поле не должно содержать пустые строки и значение NULL surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать пустые строки и значение NULL age (тип INT) — возраст студента; поле не должно содержать значения меньше 18; в качестве значения по умолчанию поле должно иметь число 18 date_of_receipt (тип DATE) — дата поступления студента на учебу; поле не должно содержать значения меньше 2023-09-01; в качестве значения по умолчанию поле должно иметь текущую дату Примечание. Например, если текущей датой является 2023-11-01, то при добавлении записи в таблицу Students без указания значения поля date_of_receipt значением этого поля должна быть дата 2023-11-01.",25,4,"create table Students (     id              int unique not null,     name            varchar(20) not null,                         surname         varchar(20) not null,     age             int default 18                          check (age >= 18),     date_of_receipt date default (curdate()),     constraint no_empty_name check (name != ''),                           constraint no_empty_surname check (surname != ''),                            constraint date_sep check (date_of_receipt >= '2023-09-01') );","CREATE TABLE Students (     id INT UNIQUE NOT NULL,      name VARCHAR(20) CHECK (name != '') NOT NULL,     surname VARCHAR(20) CHECK (surname != '') NOT NULL,     age INT CHECK (age >= 18) DEFAULT 18,     date_of_receipt DATE CHECK (date_of_receipt >= '2023-09-01') DEFAULT (CURDATE()) )",
9.1 Создание таблиц. Часть 1 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать шесть следующих полей с учетом порядка:  id (тип INT) — идентификатор студента; поле не должно содержать повторяющиеся значения и значение NULL name (тип VARCHAR(20)) — имя студента; поле не должно содержать пустые строки и значение NULL surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать пустые строки и значение NULL age (тип INT) — возраст студента; поле не должно содержать значения меньше 18; в качестве значения по умолчанию поле должно иметь число 18 date_of_receipt (тип DATE) — дата поступления студента на учебу; поле не должно содержать значения меньше 2023-09-01; в качестве значения по умолчанию поле должно иметь текущую дату phone_number (тип VARCHAR(20)) — номер телефона студента; поле должно содержать только те значения, что соответствуют следующим форматам: 7 (ddd) ddd-dd-dd 8 (ddd) ddd-dd-dd где d — цифра в диапазоне [0; 9] Примечание 1. Например, если текущей датой является 2023-11-01, то при добавлении записи в таблицу Students без указания значения поля date_of_receipt значением этого поля должна быть дата 2023-11-01.  Примечание 2. Гарантируется, что для записи номера телефона используются только цифры в диапазоне [0; 9], символы -, (, ) и пробел.",30,4,"create table Students (     id              int unique not null,     name            varchar(20) not null,     surname         varchar(20) not null,     age             int default 18,     date_of_receipt date default (curdate()),     phone_number    varchar(20),      constraint no_empty_name check (name != ''),     constraint no_empty_surname check (surname != ''),     constraint age_18 check (age >= 18),     constraint receipt_date check (date_of_receipt >= '2023-09-01'),     constraint phone check (phone_number like ('7________________') or                             phone_number like ('8________________')) );","CREATE TABLE Students (     id INT UNIQUE NOT NULL,      name VARCHAR(20) CHECK (name != '') NOT NULL,     surname VARCHAR(20) CHECK (surname != '') NOT NULL,     age INT CHECK (age >= 18) DEFAULT 18,     date_of_receipt DATE CHECK (date_of_receipt >= '2023-09-01') DEFAULT (CURDATE()),     phone_number VARCHAR(20) CHECK (phone_number LIKE '7 (___) ___-__-__' OR phone_number LIKE '8 (___) ___-__-__') )",
9.2 Создание таблиц. Часть 2 ,,"Напишите запрос, который создает таблицу Students, предназначенную для хранения информации о студентах. Она должна включать три следующих поля с учетом порядка:  id (тип INT) — идентификатор студента; поле должно являться первичным ключом; поле должно поддерживать автоматическое заполнение name (тип VARCHAR(20)) — имя студента; поле не должно содержать пустые строки surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать пустые строки",10,2,"create table Students (     id          int primary key auto_increment,     name        varchar(20) check (name != ''),     surname     varchar(20) check (surname != '') );",,
9.2 Создание таблиц. Часть 2 ,,"Напишите запрос, который создает две таблицы: Students и Classes.  1. Таблица Students предназначена для хранения информации о студентах. Она должна включать три следующих поля с учетом порядка:  id (тип INT) — идентификатор студента; поле должно являться первичным ключом; поле должно поддерживать автоматическое заполнение name (тип VARCHAR(20)) — имя студента; поле не должно содержать пустые строки surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать пустые строки 2. Таблица Classes предназначена для хранения информации об изучаемых студентами предметах. Она должна включать два следующих поля с учетом порядка:  id (тип INT) — идентификатор предмета; поле должно являться первичным ключом; поле должно поддерживать автоматическое заполнение name (тип VARCHAR(20)) — название предмета; поле не должно содержать пустые строки",15,2,"create table Students (     id       int primary key auto_increment,     name     varchar(20) check (name != ''),     surname  varchar(20) check (surname != '') ); create table Classes (     id       int primary key auto_increment,     name     varchar(20) check (name != '') );",,
9.2 Создание таблиц. Часть 2 ,,"Напишите запрос, который создает три таблицы: Students, Classes и Grades.  1. Таблица Students предназначена для хранения информации о студентах. Она должна включать три следующих поля с учетом порядка:  id (тип INT) — идентификатор студента; поле должно являться первичным ключом; поле должно поддерживать автоматическое заполнение name (тип VARCHAR(20)) — имя студента; поле не должно содержать пустые строки surname (тип VARCHAR(20)) — фамилия студента; поле не должно содержать пустые строки 2. Таблица Classes предназначена для хранения информации об изучаемых студентами предметах. Она должна включать два следующих поля с учетом порядка:  id (тип INT) — идентификатор предмета; поле должно являться первичным ключом; поле должно поддерживать автоматическое заполнение name (тип VARCHAR(20)) — название предмета; поле не должно содержать пустые строки 3. Таблица Grades предназначена для хранения информации об успеваемости студентов. Она должна включать три следующих поля с учетом порядка:  student_id (тип INT) — идентификатор студента; поле должно являться внешним ключом, связанным с полем id таблицы Students; при изменении или удалении записи таблицы Students к зависимым записям таблицы Grades должны применяться аналогичные действия class_id (тип INT) — идентификатор предмета; поле должно являться внешним ключом, связанным с полем id таблицы Classes; при изменении или удалении записи таблицы Classes к зависимым записям таблицы Grades должны применяться аналогичные действия grade (тип INT) — оценка; поле должно содержать только числа в диапазоне [1; 5] Первичным ключом в таблице Grades должно являться сочетание полей student_id и class_id.  ",40,4,"create table Students (     id        int primary key auto_increment,     name      varchar(20) check (name != ''),     surname   varchar(20) check (surname != '') ); create table Classes (     id       int primary key auto_increment,     name     varchar(20) check (name != '') ); create table Grades (      student_id  int,     class_id    int,     grade       int check (grade like ('_')),     primary key (student_id, class_id),     foreign key (student_id) references Students (id)        on delete cascade        on update cascade,             foreign key (class_id) references Classes (id)        on delete cascade        on update cascade );         ","CREATE TABLE Students (  id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) CHECK (CHAR_LENGTH(name) > 0),     surname VARCHAR(20) CHECK (CHAR_LENGTH(surname) > 0) );  CREATE TABLE Classes (  id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) CHECK (CHAR_LENGTH(name) > 0) );  CREATE TABLE Grades (  student_id INT,     class_id INT,     grade INT CHECK (grade BETWEEN 1 AND 5),     PRIMARY KEY (student_id, class_id),     FOREIGN KEY (student_id) REFERENCES Students (id)   ON UPDATE CASCADE         ON DELETE CASCADE,  FOREIGN KEY (class_id) REFERENCES Classes (id)   ON UPDATE CASCADE         ON DELETE CASCADE );",
"9.3 Удаление, переименование и обновление таблиц ",,"Вам доступна база данных, которая может включать три таблицы: Students, Classes и Grades. То есть каждая из таблиц может как присутствовать в базе данных, так и отсутствовать.  Напишите запрос, который удаляет из предложенной базы данных все существующие таблицы.  ",10,1,drop table if exists Students; drop table if exists Classes; drop table if exists Grades;,"DROP TABLE IF EXISTS Students, Classes, Grades ",
"9.3 Удаление, переименование и обновление таблиц ",,"Вам доступна база данных, принадлежащая университету Эмпайр Стейт. Она включает таблицу Students, которая хранит информацию о студентах университета.  Таблица Students Напишите запрос, который изменяет имя таблицы Students на Pupils.  Скрипт для создания таблицы Students",5,1,rename table Students to Pupils;,,
"9.3 Удаление, переименование и обновление таблиц ",,"Вам доступна база данных, принадлежащая университету Эмпайр Стейт. Она включает таблицу Students, которая хранит информацию о студентах университета.  Таблица Students Напишите запрос, который выполняет с таблицей Students следующие преобразования:  меняет имя поля name на firstname меняет имя поля surname на lastname удаляет поле age ",10,2,"alter table Students  rename column name to firstname, rename column surname to lastname,  drop column age;",ALTER TABLE Students RENAME COLUMN name to firstname;  ALTER TABLE Students RENAME COLUMN surname to lastname;  ALTER TABLE Students DROP COLUMN age;,
"9.3 Удаление, переименование и обновление таблиц ",,"Напишите запрос, который добавляет в таблицу Students новое поле с именем hometown и располагает его между полями surname и age. Поле hometown должно иметь тип VARCHAR(20), не должно хранить значение NULL, а также должно иметь значение по умолчанию в виде строки New York City.  ",10,2,alter table Students add column hometown varchar(20) not null default 'New York City' after surname;,,
"9.3 Удаление, переименование и обновление таблиц ",,"Напишите запрос, который добавляет полям name и surname таблицы Students значение по умолчанию в виде пустой строки (''). При этом типы полей name и surname, а также имеющиеся у них ограничения должны остаться неизменными.",10,3,"alter table Students alter column name set default '',  alter column surname set default '';","ALTER TABLE Students MODIFY COLUMN name VARCHAR(20) NOT NULL DEFAULT '', MODIFY COLUMN surname VARCHAR(20) NOT NULL DEFAULT '';",
"9.3 Удаление, переименование и обновление таблиц ",,"Напишите запрос, который выполняет с таблицей Students следующие преобразования:  удаляет поле id определяет в качестве первичного ключа сочетание полей name и surname",10,3,"alter table Students drop column id; alter table Students add primary key (name, surname);","ALTER TABLE Students DROP COLUMN id, ADD PRIMARY KEY (name, surname)",
"9.3 Удаление, переименование и обновление таблиц ",,"Напишите запрос, который определяет поле student_id таблицы Math как внешний ключ, связанный с полем id таблицы Students.",10,2,alter table Math add foreign key (student_id) references Students (id);,,
"9.3 Удаление, переименование и обновление таблиц ",,"Напишите запрос, который выполняет с таблицей Students следующие преобразования:  добавляет проверку того, что значением поля name является строка, состоящая из двух и более символов добавляет проверку того, что значением поля surname является строка, состоящая из двух и более символов добавляет проверку того, что значением поля age является положительное число",15,2,"alter table Students add check (name like ('__%')), add check (surname like ('__%')), add check (age > 0);",,
"9.3 Удаление, переименование и обновление таблиц ",,"Напишите запрос, который разбивает поле fullname таблицы Students на два поля name и surname типа VARCHAR(20), а затем корректно распределяет данные, содержащиеся в поле fullname, по двум новым полям: имя в поле name, фамилию в поле surname.",40,5,"alter table Students add column name varchar(20), add column surname varchar(20) ; update Students set surname = substring(fullname, (locate(' ', fullname)+1)),     name = left(fullname, (locate(' ', fullname)-1)) ; alter table Students drop column fullname","ALTER TABLE Students ADD COLUMN name VARCHAR(20) DEFAULT (SUBSTRING_INDEX(fullname, ' ', 1)), ADD COLUMN surname VARCHAR(20) DEFAULT (SUBSTRING_INDEX(fullname, ' ', -1));  ALTER TABLE Students ALTER COLUMN name DROP DEFAULT, ALTER COLUMN surname DROP DEFAULT, DROP COLUMN fullname;",
9.4. Триггеры,"DROP TABLE IF EXISTS Posts; CREATE TABLE Posts (     id           INT PRIMARY KEY AUTO_INCREMENT,     user_id      INT,     post_date    DATETIME );  INSERT INTO Posts (user_id, post_date) VALUES (101, '2024-01-10 12:30:00'),        (102, '2024-01-10 13:45:00'),        (103, '2024-01-10 14:15:00'),        (104, '2024-01-10 15:00:00'),        (105, '2024-01-10 16:20:00'); "," Напишите запрос, создающий триггер, который перед добавлением нового поста устанавливает ему в качестве даты и времени публикации текущие дату и время в любом часовом поясе.",20,4,create trigger P before insert on Posts for each row  set new.post_date = now();,DELIMITER // CREATE TRIGGER set_post_date_before_insert BEFORE INSERT ON Posts FOR EACH ROW BEGIN     SET NEW.post_date = CURRENT_TIMESTAMP; END // DELIMITER ;,
9.4. Триггеры,"DROP TABLE IF EXISTS Employees;  CREATE TABLE Employees (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50),     salary INT );  INSERT INTO Employees (name, surname, salary) VALUES ('Lech', 'Walesa', 1800),        ('Julie', 'Andrews', 1500),        ('Florence', 'Nightingale', 3200),        ('Marie', 'Curie', 2100),        ('Stephen', 'Hawking', 2400),        ('Tim', 'Berners', 3800),        ('Aung', 'San', 2200),        ('Lance', 'Armstrong', 5000),        ('Shakira', 'Curie', 3000),        ('Jon', 'Stewart', 1900),        ('Wright', 'BrothersOrville', 5400); ","Прожиточный минимум — минимальная сумма доходов, необходимая для обеспечения жизнедеятельности гражданина. Будем считать, что прожиточный минимум составляет  1000 1000 долларов.  Напишите запрос, создающий триггер, который перед добавлением нового сотрудника нормализует его заработную плату. Если заработная плата меньше прожиточного минимума, триггер должен установить ей значение, равное прожиточному минимуму. Если заработная плата больше либо равна прожиточному минимуму, триггер должен оставить ее без изменений.",20,4,"create trigger E before insert on Employees for each row set new.salary = if(new.salary < 1000, 1000, new.salary)","CREATE TRIGGER check_min_salary BEFORE INSERT ON Employees FOR EACH ROW SET NEW.salary = GREATEST(NEW.salary, 1000)",
9.4. Триггеры,"DROP TABLE IF EXISTS UsersEmailHistory; DROP TABLE IF EXISTS Users;  -- Создание таблицы Users CREATE TABLE Users (     id      INT AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     email   VARCHAR(40),     PRIMARY KEY (id) );  INSERT INTO Users (name, surname, email) VALUES ('Matt', 'Damon', 'matt@gmail.com'),        ('Edward', 'Norton', 'ENorton.@outlook.com'),        ('Nicolas', 'Cage', 'ghostrider@outlook.com'),        ('Ben', 'Affleck', 'thebestbat@gmail.com'),        ('John', 'Travolta', 'WhereAmI@cloud.com');  -- Создание таблицы UsersEmailHistory CREATE TABLE UsersEmailHistory (     log_id     INT AUTO_INCREMENT,     user_id    INT,     old_email  VARCHAR(40),     new_email  VARCHAR(40),     updated_on DATE,     PRIMARY KEY (log_id) );  INSERT INTO UsersEmailHistory (user_id, old_email, new_email, updated_on) VALUES (3, 'cagecage2@gmail.com', 'ghostrider@outlook.com', '2023-08-19'),        (1, 'mattie@cloud.com', 'matt@gmail.com', '2023-08-20'); ","Напишите запрос, создающий триггер, который после изменения пользователем адреса электронной почты фиксирует данное изменение и добавляет соответствующую информацию в таблицу UsersEmailHistory.  Скрипт для создания таблиц Users и UsersEmailHistory Тестовые данные Примечание 1. Имя создаваемого триггера может быть произвольным.  Примечание 2. Поле log_id таблицы UsersEmailHistory использует ограничение AUTO_INCREMENT.",25,5,"create trigger log_change_mail   after update   on Users for each row   insert into UsersEmailHistory (user_id, old_email, new_email, updated_on)   values (OLD.id, OLD.email, NEW.email, curdate()) ;",,
9.4. Триггеры,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50),     stock INT );  INSERT INTO Products (name, stock) VALUES ('Apple iPhone 13 Pro', 14),        ('Samsung Galaxy S21', 29),        ('Sony WH-1000XM4 Headphones', 1),        ('Nike Air Zoom Pegasus 38', 5),        ('Adidas Ultraboost 21', 19),        ('Lenovo ThinkPad X1 Carbon', 49),        ('Dell XPS 13 Laptop', 22),        ('Canon EOS R6 Camera', 32),        ('Bose QuietComfort 35 II', 75),        ('Samsung 65-inch QLED TV', 11),        ('LG OLED55CXPUA TV', 84),        ('Apple AirPods Pro', 66),        ('Fitbit Versa 3', 102),        ('PlayStation 5', 14),        ('Xbox Series X', 87),        ('Amazon Echo Dot (4th Gen)', 11),        ('GoPro HERO9 Black', 44),        ('Samsung Galaxy Tab S7', 52),        ('Dyson V11 Animal Vacuum', 31),        ('Instant Pot Duo 7-in-1', 109);  -- Создание таблицы Orders CREATE TABLE Orders (     id   INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     quantity INT,     FOREIGN KEY (product_id) REFERENCES Products (id) );  INSERT INTO Orders (product_id, quantity) VALUES (4, 11),        (11, 4),        (17, 5),        (1, 20),        (20, 2); ","Напишите запрос, создающий триггер, который после добавления нового заказа уменьшает количество соответствующего товара на складе.",20,4,create trigger Changes after insert on Orders for each row update Products set stock = stock - (select quantity from Orders                      where id = new.id) where id = (select product_id from Orders             where id = new.id),CREATE TRIGGER UpdateStock AFTER INSERT ON Orders FOR EACH ROW BEGIN     UPDATE Products     SET stock := stock - NEW.quantity     WHERE Products.id = NEW.product_id; END;,
9.4. Триггеры,"DROP TABLE IF EXISTS Reviews; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id         INT PRIMARY KEY AUTO_INCREMENT,     name       VARCHAR(50),     avg_rating DECIMAL(3, 2) );  INSERT INTO Products VALUES (10, 'Instant Pot Duo 7-in-1', 5),        (20, 'Amazon Echo Dot (4th Gen)', 5),        (30, 'PlayStation 5', 5),        (40, 'Apple AirPods Pro', 5),        (50, 'Samsung 65-inch QLED TV', 5);  -- Создание таблицы Reviews CREATE TABLE Reviews (     id          INT PRIMARY KEY AUTO_INCREMENT,     product_id  INT,     rating      INT,     FOREIGN KEY (product_id) REFERENCES Products (id) );  INSERT INTO Reviews (product_id, rating) VALUES (10, 5),        (20, 5),        (30, 5),        (40, 5),        (50, 5); ","Напишите запрос, создающий триггер, который после добавления нового отзыва обновляет средний рейтинг соответствующего товара.",25,5,create trigger R after insert on Reviews for each row update Products set avg_rating = (select avg(rating) from Reviews                   where Products.id = product_id) ;,CREATE TRIGGER UpdateAvgRating AFTER INSERT ON Reviews FOR EACH ROW BEGIN     UPDATE Products     SET avg_rating = (SELECT AVG(rating) FROM Reviews WHERE product_id = NEW.product_id)     WHERE Products.id = NEW.product_id; END;,
9.4. Триггеры,"DROP TABLE IF EXISTS Users; CREATE TABLE Users (     id           INT AUTO_INCREMENT,     name         VARCHAR(20),     surname      VARCHAR(20),     phone_number VARCHAR(20),     PRIMARY KEY (id) );  INSERT INTO Users (name, surname, phone_number) VALUES ('Matt', 'Damon', '+79087333025'),        ('Edward', 'Norton', '+79642218964'),        ('Nicolas', 'Cage', '+79808814813'),        ('Ben', 'Affleck', '+79042778299'),        ('John', 'Travolta', '+79640950623'); ","Напишите запрос, создающий триггер, который перед изменением номера телефона пользователя переводит его в следующий формат:  +7dddddddddd Также запрос должен включать создание триггера, который при добавлении информации о новом пользователе переводит его номер телефона в формат, приведенный выше.  Гарантируется, что номер телефона пользователя всегда указывается в одном из следующих форматов:  +7dddddddddd +8dddddddddd +7 ddd ddd dd dd +8 ddd ddd dd dd где d — цифра в диапазоне [0; 9].",40,7,"create trigger telephone_number   before update   on Users for each row   set NEW.phone_number = replace(NEW.phone_number, '+8', '+7'),       NEW.phone_number = replace(NEW.phone_number, ' ', '')   ; create trigger new_user_number   before insert   on Users for each row   set NEW.phone_number = replace(NEW.phone_number, '+8', '+7'),       NEW.phone_number = replace(NEW.phone_number, ' ', '')   ;","CREATE TRIGGER formatting_phone_before_update  BEFORE UPDATE ON Users FOR EACH ROW SET NEW.phone_number = CONCAT('+7', SUBSTRING(REPLACE(NEW.phone_number, ' ', ''), 3));   CREATE TRIGGER formatting_phone_before_insert BEFORE INSERT ON Users FOR EACH ROW SET NEW.phone_number = CONCAT('+7', SUBSTRING(REPLACE(NEW.phone_number, ' ', ''), 3))","CREATE TRIGGER insert_phone_number BEFORE INSERT ON Users FOR EACH ROW SET NEW.phone_number = REPLACE(REPLACE(NEW.phone_number, '+8', '+7'), ' ', '');  CREATE TRIGGER update_phone_number BEFORE UPDATE ON Users FOR EACH ROW SET NEW.phone_number = REPLACE(REPLACE(NEW.phone_number, '+8', '+7'), ' ', '');  "
9.4. Триггеры,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    DECIMAL(5, 2) );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Users CREATE TABLE Users (     id             INT PRIMARY KEY AUTO_INCREMENT,     name           VARCHAR(40),     surname        VARCHAR(40),     total_spending DECIMAL(5, 2) ); INSERT INTO Users (name, surname, total_spending) VALUES ('Matt', 'Damon', 23.96),        ('Edward', 'Norton', 10.98),        ('Nicolas', 'Cage', 10.98),        ('Ben', 'Affleck', 7.98),        ('John', 'Travolta', 0.0);  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT ); INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (6, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1); ","Напишите запрос, создающий триггер, который после покупки пользователем очередного фильма прибавляет к его сумме, потраченной на покупку фильмов, стоимость только что купленного фильма.",30,6,CREATE TRIGGER total_spending_updating AFTER INSERT ON Purchases FOR EACH ROW UPDATE Users SET total_spending = total_spending + (SELECT price                                        FROM Films                                        WHERE id = NEW.film_id) WHERE id = NEW.user_id,CREATE TRIGGER update_total_spending AFTER INSERT ON Purchases FOR EACH ROW UPDATE Users INNER JOIN Purchases ON Purchases.user_id = Users.id INNER JOIN Films ON Purchases.film_id = Films.id SET total_spending = total_spending + Films.price WHERE Purchases.id = NEW.id,create trigger new_film   after insert   on Purchases for each row   update Users as U     inner join Films as F on NEW.film_id = F.id   set U.total_spending = U.total_spending + F.price   where U.id = NEW.user_id   ;
9.4. Триггеры,"DROP TABLE IF EXISTS Notifications; DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers;  CREATE TABLE Customers (     id   INT,     name VARCHAR(40) );  INSERT INTO Customers (id, name) VALUES (10, 'Ivan'),        (20, 'John'),        (30, 'Mark'),        (40, 'Elon'),        (50, 'Pavel'),        (60, 'Andrey'),        (70, 'Peter'),        (80, 'Ben');  CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     store       VARCHAR(40),     amount      INT,     status      VARCHAR(40) );  INSERT INTO Orders (store, customer_id, amount, status) VALUES ('Ozon', 20, 101, 'Created'),        ('PCUniverse', 40, 799, 'Shipped'),        ('PCUniverse', 10, 99, 'Delivered'),        ('DarkStore', 30, 99, 'Created'),        ('Ozon', 50, 678, 'Delivered'),        ('Ozon', 10, 458, 'Created');  CREATE TABLE Notifications (     id          INT PRIMARY KEY AUTO_INCREMENT,     order_id    INT,     message     TEXT,     FOREIGN KEY (order_id) REFERENCES Orders (id) );  INSERT INTO Notifications (order_id, message) VALUES (1, 'John, new status of your delivery on 2024-08-26: Created'),        (2, 'Elon, new status of your delivery on 2024-08-26: Shipped'),        (3, 'Ivan, new status of your delivery on 2024-08-26: Delivered'),        (4, 'Mark, new status of your delivery on 2024-08-26: Created'),        (5, 'Pavel, new status of your delivery on 2024-08-26: Delivered'),        (6, 'Ivan, new status of your delivery on 2024-08-26: Created'); ","Напишите запрос, создающий триггер, который после добавления нового заказа также добавляет сообщение для покупателя. При этом сообщение должно быть записано в следующем формате:  <Имя покупателя>, new status of your delivery on <текущая дата>: <статус заказа> Также запрос должен включать создание триггера, который после обновления статуса заказа также обновляет сообщение для покупателя. При этом сообщение должно быть записано в том же формате, что и при добавлении заказа.",60,8,"create trigger AddOfder after insert  on Orders for each row insert into Notifications (order_id, message) values ((select max(order_id) from Notifications as NN) + 1, concat((select name from Customers         where id = new.customer_id), ',', ' new status of your delivery on ', curdate(), ': ',          (select status from Orders          where id = new.id))) ;  create trigger UpOrder after update on Orders for each row update Notifications set message = concat(                       (select name from Customers                        where id = new.customer_id)                        , ','                        , ' new status of your delivery on '                        , curdate()                        , ': '                        , new.status                      )  where order_id = new.id -- and old.status != new.status  /* ; UPDATE Orders SET status = 'Delivered' WHERE id = 2; select * from Notifications */","CREATE TRIGGER UpdateOrder AFTER UPDATE ON Orders FOR EACH ROW BEGIN     UPDATE Notifications     INNER JOIN Orders ON order_id = Orders.id     INNER JOIN Customers ON customer_id = Customers.id     SET message = CONCAT(name, ', new status of your delivery on ', CURDATE(), ': ', status)     WHERE New.id = order_id; END;  CREATE TRIGGER CreateOrder AFTER INSERT ON Orders FOR EACH ROW BEGIN     INSERT INTO Notifications (order_id, message)     SELECT NEW.id,            CONCAT(name, ', new status of your delivery on ',  CURDATE(), ': ', NEW.status)     FROM Customers     WHERE id = NEW.customer_id;     END;",
9.5 Представления ,"DROP TABLE IF EXISTS Products;  CREATE TABLE Products (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50),     stock INT );  TRUNCATE Products; INSERT INTO Products (name, stock) VALUES ('Apple iPhone 13 Pro', 7),        ('Samsung Galaxy S21', 29),        ('Sony WH-1000XM4 Headphones', 1),        ('Nike Air Zoom Pegasus 38', 5),        ('Adidas Ultraboost 21', 19),        ('Lenovo ThinkPad X1 Carbon', 49),        ('Dell XPS 13 Laptop', 22),        ('Canon EOS R6 Camera', 32),        ('Bose QuietComfort 35 II', 75),        ('Samsung 65-inch QLED TV', 10),        ('LG OLED55CXPUA TV', 8),        ('Apple AirPods Pro', 66),        ('Fitbit Versa 3', 0),        ('PlayStation 5', 9),        ('Xbox Series X', 87),        ('Amazon Echo Dot (4th Gen)', 11),        ('GoPro HERO9 Black', 44),        ('Samsung Galaxy Tab S7', 52),        ('Dyson V11 Animal Vacuum', 3),        ('Instant Pot Duo 7-in-1', 109); ","Напишите запрос, создающий представление с именем LowStockProducts. Представление должно включать информацию (название, количество) о товарах, количество которых на складе меньше десяти штук.",10,2,"create view LowStockProducts as select name, stock from Products where stock < 10;",,
9.5 Представления ,"DROP TABLE IF EXISTS Users; CREATE TABLE Users (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     email   VARCHAR(40) );  TRUNCATE Users; INSERT INTO Users (name, surname, email) VALUES ('Christopher', 'Nolan', NULL),        ('Steven', 'Spielberg', NULL),        ('Quentin', 'Tarantino', 'queen@gmail.com'),        ('Martin', 'Scorsese', NULL),        ('David', 'Fincher', 'dfincher@outlook.com'),        ('Ridley', 'Scott', 'riddler@gmail.com'),        ('Stanley', 'Kubrick', 'bigstan@icloud.com'),        ('Clint', 'Eastwood', 'cowboy@yahoo.com'),        ('James', 'Cameron', NULL),        ('Tim', 'Burton', 'timmy@icloud.com'); ","Напишите запрос, создающий представление с именем UsersWithEmail. Представление должно включать информацию (идентификатор, имя, фамилия, адрес электронной почты) о тех пользователях, адрес электронной почты которых известен.  ",10,2,"create view LowStockProducts as select name, stock from Products where stock < 10;",,
9.5 Представления ,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     player_id    INT,     event_date   DATE,     games_played INT );  TRUNCATE Activity; INSERT INTO Activity VALUES (4, '2024-09-01', 3),        (4, '2023-04-10', 2),        (6, '2024-06-15', 7),        (6, '2024-02-20', 1),        (7, '2023-03-25', 4),        (7, '2024-08-12', 0),        (8, '2024-08-25', 2),        (8, '2024-08-12', 7),        (14, '2024-08-04', 6),        (10, '2023-01-10', 8),        (11, '2023-11-22', 2),        (10, '2024-09-02', 5),        (11, '2023-05-20', 9),        (11, '2024-08-03', 3),        (12, '2024-08-31', 1),        (22, '2023-02-03', 0),        (22, '2023-04-05', 10),        (22, '2023-08-17', 3),        (23, '2023-07-08', 5); ","Напишите запрос, создающий представление с именем ActivePlayers. Представление должно включать информацию (идентификатор, дата последнего входа в игру) об игроках, которые на 2024-09-01 заходили в игру в течение последних тридцати дней.  Поле с информацией о дате последнего входу в игру должно иметь псевдоним last_login.",20,3,"create view ActivePlayers as select player_id, max(event_date) as last_login from Activity where event_date between '2024-09-01' - interval 29 day and '2024-09-01' group by player_id","CREATE VIEW ActivePlayers AS SELECT player_id, MAX(event_date) AS last_login FROM Activity WHERE DATEDIFF('2024-09-01', event_date) BETWEEN 0 AND 29 GROUP BY player_id;",
9.5 Представления ,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50),     salary  INT );  TRUNCATE Employees; INSERT INTO Employees (name, surname, salary) VALUES ('Lech', 'Walesa', 8923),        ('Julie', 'Andrews', 4580),        ('Florence', 'Nightingale', 7546),        ('Marie', 'Curie', 4839),        ('Stephen', 'Hawking', 8195),        ('Tim', 'Berners', 7037),        ('Aung', 'San', 3162),        ('Lance', 'Armstrong', 9886),        ('Shakira', 'Curie', 8056),        ('Jon', 'Stewart', 6718),        ('Wright', 'BrothersOrville', 7253),        ('Ernest', 'Hemingway', 7811),        ('Roman', 'Abramovich', 8825),        ('Tom', 'Cruise', 7381),        ('Rupert', 'Murdoch', 3947),        ('Al', 'Gore', 3059),        ('Sacha', 'Baron', 3331),        ('George', 'Clooney', 3373),        ('Paul', 'Krugman', 7741),        ('Jimmy', 'Wales', 3153); ","Напишите запрос, создающий представление с именем AboveAverageSalaries. Представление должно включать информацию (имя, фамилия, заработная плата) о сотрудниках, зарплата которых выше средней зарплаты всех сотрудников.  ",15,3,"create view AboveAvarageSalaries as select name, surname, salary from Employees where salary > (select avg(salary) from Employees)",,
9.5 Представления ,"DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id       INT PRIMARY KEY AUTO_INCREMENT,     name     VARCHAR(50),     category VARCHAR(40),     price    INT );  INSERT INTO Products (name, category, price) VALUES ('Apple iPhone 13 Pro', 'Electronics', 1099),        ('Samsung Galaxy S21', 'Electronics', 999),        ('Sony WH-1000XM4 Headphones', 'Electronics', 299),        ('Nike Air Zoom Pegasus 38', 'Footwear', 120),        ('Adidas Ultraboost 21', 'Footwear', 180),        ('Lenovo ThinkPad X1 Carbon', 'Electronics', 1499),        ('Dell XPS 13 Laptop', 'Electronics', 1199),        ('Canon EOS R6 Camera', 'Electronics', 2499),        ('Bose QuietComfort 35 II', 'Electronics', 299),        ('Samsung 65-inch QLED TV', 'Electronics', 1499),        ('LG OLED55CXPUA TV', 'Electronics', 1799),        ('Apple AirPods Pro', 'Electronics', 249),        ('Fitbit Versa 3', 'Electronics', 199),        ('PlayStation 5', 'Electronics', 499),        ('Xbox Series X', 'Electronics', 499),        ('Amazon Echo Dot (4th Gen)', 'Electronics', 49),        ('GoPro HERO9 Black', 'Electronics', 349),        ('Samsung Galaxy Tab S7', 'Electronics', 649),        ('Dyson V11 Animal Vacuum', 'Appliances', 599),        ('Instant Pot Duo 7-in-1', 'Appliances', 89);  -- Создание таблицы Orders CREATE TABLE Orders (     id   INT PRIMARY KEY AUTO_INCREMENT,     product_id INT,     quantity INT,     FOREIGN KEY (product_id) REFERENCES Products (id) );  TRUNCATE Orders; INSERT INTO Orders (product_id, quantity) VALUES (4, 11),        (11, 4),        (17, 5),        (1, 20),        (20, 2); ","Напишите запрос, создающий представление с именем CategorySalesSummary. Представление должно включать информацию о названии категории и общей сумме продаж в каждой категории.",20,3,"create view CategorySalesSummary as select category, sum(price*(select quantity from Orders                             where product_id = Products.id)) as total from Products group by category","CREATE VIEW CategorySalesSummary AS SELECT category, SUM(price * quantity) AS total FROM Products INNER JOIN Orders ON product_id = Products.id GROUP BY category;",
9.5 Представления ,"DROP TABLE IF EXISTS Purchases; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id       INT PRIMARY KEY AUTO_INCREMENT,     title    VARCHAR(20),     director VARCHAR(20),     price    FLOAT );  INSERT INTO Films (title, director, price) VALUES ('Toy Story 2', 'John Lasseter', 2.99),        ('WALL-E', 'Andrew Stanton', 4.99),        ('Ratatouille', 'Brad Bird', 4.99),        ('Up', 'Pete Docter', 4.99),        ('Brave', 'Brenda Chapman', 7.99),        ('Monsters University', 'Dan Scanlon', 7.99),        ('Cars 2', 'John Lasseter', 7.99),        ('Finding Nemo', 'Andrew Stanton', 4.99),        ('Toy Story', 'John Lasseter', 2.99),        ('The Incredibles', 'Brad Bird', 4.99);  -- Создание таблицы Purchases CREATE TABLE Purchases (     id      INT PRIMARY KEY AUTO_INCREMENT,     film_id INT,     user_id INT );  TRUNCATE Purchases; INSERT INTO Purchases (film_id, user_id) VALUES (1, 1),        (1, 3),        (2, 4),        (1, 2),        (9, 4),        (8, 1),        (7, 2),        (6, 3),        (5, 1),        (10, 1),        (10, 2),        (5, 3),        (7, 4),        (3, 2),        (9, 5),        (6, 2),        (8, 4),        (3, 3),        (2, 1),        (7, 1),        (8, 2),        (8, 3),        (8, 5),        (3, 5),        (1, 4),        (9, 1),        (5, 2),        (9, 3),        (6, 1),        (3, 1); ","Напишите запрос, создающий представление с именем PopularMovies. Представление должно включать информацию (название, количество покупок) о фильмах, которые были куплены не менее трех раз.  Поле с общим количеством покупок должно иметь псевдоним total_purchases.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля total_purchases, при совпадении в порядке возрастания значения поля title.",20,3,"create view PopularMovies as select (select title from Films         where id = Purchases.film_id) as title, count(*) as total_purchases from Purchases group by film_id having total_purchases >= 3 order by total_purchases, title","CREATE VIEW PopularMovies AS SELECT title, COUNT(*) AS total_purchases FROM Films INNER JOIN Purchases ON film_id = Films.id GROUP BY film_id HAVING total_purchases > 2 ORDER BY total_purchases, title;",
9.5 Представления ,"DROP TABLE IF EXISTS Students; CREATE TABLE Students (     id       INT PRIMARY KEY AUTO_INCREMENT,     name     VARCHAR(60),     group_id INT );  TRUNCATE Students; INSERT INTO Students (name, group_id) VALUES ('Alice', 101),        ('Bob', 102),        ('Charlie', 101),        ('David', 103),        ('Eva', 102),        ('Frank', 104),        ('Grace', 101),        ('Hannah', 105),        ('Ivy', 103),        ('Jack', 102),        ('Kate', 104),        ('Liam', 105),        ('Mia', 101),        ('Noah', 103),        ('Olivia', 102),        ('Peter', 102),        ('Quinn', 101),        ('Riley', 104),        ('Sophia', 103),        ('Thomas', 102); ","Напишите запрос, создающий представление с именем NoMinMaxStudents. Представление должно включать информацию об идентификаторах групп, в которых нет ни максимального, ни минимального количества учеников.",25,4,"create view GroupsView as select group_id from Students group by group_id having count(name) != (select max(C) from (select group_id, count(*)as C from Students                          group by group_id) as CC)    and count(name) != (select min(C) from (select group_id, count(*)as C from Students                          group by group_id) as CC)",CREATE VIEW StudentsCount (cnt) AS   SELECT COUNT(name) FROM Students GROUP BY group_id;  CREATE VIEW NoMinMaxStudents AS SELECT group_id FROM Students GROUP BY group_id HAVING COUNT(name) != (SELECT MAX(cnt) FROM StudentsCount) AND         COUNT(name) != (SELECT MIN(cnt) FROM StudentsCount);,
9.5 Представления ,"DROP TABLE IF EXISTS Relations; CREATE TABLE Relations (     user_id     INT,     follower_id INT );  TRUNCATE Relations; INSERT INTO Relations (user_id, follower_id) VALUES (1, 3),        (2, 3),        (7, 3),        (1, 4),        (2, 4),        (7, 4),        (1, 5),        (2, 6),        (7, 5),        (3, 1),        (4, 1),        (3, 2),        (4, 2),        (5, 1),        (6, 2),        (5, 7),        (6, 7),        (5, 4),        (7, 6),        (6, 5); ","Напишите запрос, создающий представление с именем MostCommonFollowers. Представление должно определять все пары пользователей с максимальным количеством общих подписчиков. Другими словами, если максимальное количество общих подписчиков между любыми двумя пользователями равно max, то запрос должен определить все пары пользователей, у которых есть max общих подписчиков.  Поле с идентификатором первого пользователя должно иметь псевдоним user1_id, поле с идентификатором второго пользователя — user2_id. Также для каждой записи результирующей таблицы должно выполняться неравенство user1_id < user2_id.",50,7,"create view R as (select R1.user_id as user1_id,                          R2.user_id as user2_id,                   count(*) as c             from Relations as R1 join Relations as R2 on R1.follower_id = R2.follower_id AND R1.user_id < R2.user_id group by user1_id, user2_id); select user1_id,        user2_id       from R        where c = (select max(c) from R)","CREATE VIEW UsersInfo AS  SELECT R1.user_id AS user1_id,         R2.user_id AS user2_id,         COUNT(*) AS count_of_common_followers FROM Relations AS R1 INNER JOIN Relations AS R2         ON R1.follower_id = R2.follower_id        AND R1.user_id < R2.user_id GROUP BY user1_id, user2_id;  CREATE VIEW MostCommonFollowers AS SELECT user1_id, user2_id  FROM UsersInfo WHERE count_of_common_followers = (SELECT MAX(count_of_common_followers)                                    FROM UsersInfo);",
9.5 Представления ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id            INT PRIMARY KEY AUTO_INCREMENT,     product_id    INT,     quantity      INT,     purchase_date DATE );  TRUNCATE Orders; INSERT INTO Orders (product_id, quantity, purchase_date) VALUES (1, 7, '2020-03-16'),        (1, 4, '2020-05-02'),        (1, 7, '2020-07-10'),        (1, 6, '2021-02-23'),        (1, 5, '2021-05-21'),        (1, 6, '2021-10-11'),        (3, 5, '2019-08-08'),        (8, 1, '2021-06-03'),        (2, 5, '2023-12-25'),        (7, 7, '2022-07-10'),        (3, 5, '2019-09-24'),        (8, 5, '2022-07-29'),        (7, 5, '2023-01-16'),        (3, 7, '2022-12-21'),        (3, 3, '2021-06-16'),        (3, 7, '2019-06-11'),        (8, 3, '2021-06-13'),        (8, 1, '2020-05-25'),        (3, 3, '2023-06-14'),        (8, 5, '2022-01-13'),        (7, 9, '2023-07-19'),        (5, 3, '2023-12-01'),        (4, 8, '2022-02-15'),        (3, 7, '2020-09-06'),        (8, 3, '2020-11-23'),        (4, 9, '2023-10-05'),        (7, 2, '2023-10-12'),        (8, 5, '2020-01-03'),        (6, 6, '2022-06-21'),        (8, 6, '2021-07-01'),        (3, 4, '2018-12-26'),        (3, 5, '2019-08-11'),        (3, 7, '2022-02-21'),        (3, 5, '2018-09-04'),        (7, 3, '2022-03-07'),        (6, 5, '2021-01-01'),        (3, 4, '2022-03-18'),        (5, 2, '2023-01-31'),        (8, 7, '2022-07-19'),        (7, 3, '2022-10-27'),        (2, 6, '2023-10-16'),        (8, 5, '2020-08-04'),        (4, 7, '2022-08-28'); "," Напишите запрос, создающий представление с именем PopularProducts. Представление должно определять уникальные идентификаторы товаров, которые были заказаны три или более раз в течение двух лет подряд.",60,8,"create view CountView as select product_id, year(purchase_date) as Pur_year, count(quantity)as Count_q from Orders group by year(purchase_date), product_id having Count_q >= 3 order by product_id, Pur_year ; select distinct product_id from CountView where product_id = (select product_id from CountView as CV                     where CountView.product_id = CV.product_id                     and CountView.Pur_year = CV.Pur_year + 1)","CREATE VIEW ProductInfo AS  SELECT product_id,        YEAR(purchase_date) AS purchase_year,        COUNT(*) AS count_of_purchases FROM Orders GROUP BY product_id, purchase_year;  CREATE VIEW PopularProducts AS SELECT DISTINCT P1.product_id FROM ProductInfo AS P1 INNER JOIN ProductInfo AS P2          ON P1.product_id = P2.product_id        AND P1.purchase_year = P2.purchase_year + 1 WHERE P1.count_of_purchases >= 3 AND P2.count_of_purchases >= 3;",
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Math; CREATE TABLE Math (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20),     grade   VARCHAR(20) );  INSERT INTO Math (name, surname, grade) VALUES ('Flash', 'Thompson', 'D'),        ('Peter', 'Parker', 'A'),        ('Mary', 'Jane', 'D'),        ('Gwen', 'Stacy', 'B'),        ('Harry', 'Osborn', 'A'),        ('Ben', 'Reilly', 'E'),        ('Miles', 'Morales', 'A'),        ('John', 'Jameson', 'E'),        ('Curtis', 'Connors', 'B'),        ('Edward', 'Brock', 'C'),        ('Yuriko', 'Watanabe', 'C'),        ('Martin', 'Li', 'B'),        ('Sergei', 'Kravinoff', 'A'),        ('Felicia', 'Hardy', 'D'),        ('Aaron', 'Davis', 'E'),        ('Rio', 'Morales', 'B'),        ('Robbie', 'Robertson', 'C'),        ('Hailey', 'Cooper', 'A'),        ('John', 'Howard', 'D'),        ('Flint', 'Marco', 'C'); ","У каждой буквенной оценки имеется текстовый эквивалент, который определяется согласно следующей таблице:  Оценка Описание A Great B Great C Well D Bad E Bad Напишите запрос, который разбивает студентов на группы в зависимости от текстового эквивалента их оценки, определяет количество студентов в каждой группе и отображает полученный результат в виде таблицы из двух полей:  result — текстовый эквивалент оценки (Great, Well или Bad) students — количество студентов, получивших оценку, соответствующую этому текстовому эквиваленту ",20,2,"SELECT (SELECT title         FROM StephenKingBooks         WHERE release_year = (SELECT MIN(release_year)                               FROM StephenKingBooks)) AS first_book,        (SELECT title         FROM StephenKingBooks         WHERE release_year = (SELECT MAX(release_year)                               FROM StephenKingBooks)) AS last_book;",,
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50) );  INSERT INTO Customers (name) VALUES ('Dipper'),        ('Mabel'),        ('Chris'),        ('Mia'),        ('Wendy');  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     amount      INT );  INSERT INTO Orders (customer_id, amount) VALUES (5, 800),        (2, 300),        (3, 649),        (2, 587),        (1, 686),        (3, 674),        (2, 837),        (2, 858),        (4, 423),        (2, 997),        (3, 343),        (5, 177),        (4, 682),        (1, 726),        (5, 130),        (3, 454),        (4, 567),        (4, 807),        (5, 162),        (2, 596); ","Напишите запрос, который определяет имя покупателя с наибольшей средней суммой заказа и указывает полученный результат в поле с псевдонимом customer.",20,3,"with TableTemp as ( select name, avg(amount) as Sr from Orders O left join Customers C on O.customer_id = C.id group by name) select name as customer from TableTemp order by Sr desc limit 1","WITH OrdersCustomers AS (SELECT name, amount                    FROM Customers INNER JOIN Orders ON customer_id = Customers.id)  SELECT name AS customer FROM OrdersCustomers GROUP BY name HAVING AVG(amount) = (SELECT AVG(amount)                       FROM Orders                       GROUP BY customer_id                       ORDER BY AVG(amount) DESC                       LIMIT 1);",
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id         INT PRIMARY KEY AUTO_INCREMENT,     store      VARCHAR(40),     order_date DATE,     amount     INT );  INSERT INTO Orders (store, order_date, amount) VALUES ('Ozon', '2023-06-01', 101),        ('PCUniverse', '2023-06-07', 799),        ('PCUniverse', '2023-07-07', 99),        ('DarkStore', '2023-06-21', 99),        ('DarkStore', '2023-06-27', 1015),        ('Ozon', '2023-07-02', 678),        ('PCUniverse', '2023-07-02', 858),        ('Ozon', '2023-07-13', 458),        ('Ozon', '2023-06-14', 801),        ('DarkStore', '2023-07-21', 325),        ('Gloria Jeans', '2023-07-13', 811),        ('Mvideo', '2023-07-24', 422),        ('Mvideo', '2023-06-22', 667),        ('Gloria Jeans', '2023-06-11', 83),        ('Gloria Jeans', '2023-07-05', 1500),        ('Ozon', '2023-07-31', 242),        ('PCUniverse', '2023-06-01', 679),        ('Gloria Jeans', '2023-06-30', 328),        ('Ozon', '2023-07-01', 1),        ('DarkStore', '2023-07-15', 42),        ('PCUniverse', '2023-06-14', 189),        ('Gloria Jeans', '2023-07-25', 317),        ('DarkStore', '2023-07-21', 822),        ('Mvideo', '2023-06-10', 10),        ('Gloria Jeans', '2023-07-22', 400) ","Напишите запрос, определяющий название магазина, который заработал наибольшее количество денег в июне, а также название магазина, который заработал наибольшее количество денег в июле. Полученные значения должны быть указаны в полях с псевдонимами best_in_june и best_in_july соответственно.",30,4,"with June as ( select store, sum(amount) as avg_amount from Orders where month(order_date) = 6 group by store order by avg_amount desc limit 1 ), July as ( select store, sum(amount) as avg_amount from Orders where month(order_date) = 7 group by store order by avg_amount desc limit 1 ) select June.store as best_in_june, July.store as best_in_july from June, July             ","WITH StoreOrders (store, month_orders,      sum_orders) AS (     SELECT        store, MONTH(order_date), SUM(amount)     FROM          Orders     GROUP BY      store, MONTH(order_date) )  SELECT (SELECT store         FROM StoreOrders         WHERE month_orders = 6         ORDER BY sum_orders DESC         LIMIT 1) AS best_in_june,                  (SELECT store         FROM StoreOrders         WHERE month_orders = 7         ORDER BY sum_orders DESC         LIMIT 1) AS best_in_july",
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325),        ('Gloria Jeans', 811),        ('Mvideo', 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        ('Gloria Jeans', 1500),        ('Ozon', 242),        ('PCUniverse', 679),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', 42),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 822),        ('Mvideo', 10),        ('Gloria Jeans', 400) ","Напишите запрос, который извлекает из предложенной базы данных всю информацию о каждом заказе. Также рядом с данными о каждом заказе должна быть указана средняя сумма заказа в том магазине, в котором был совершен заказ.  Поле со средней суммой заказа в магазине должно иметь псевдоним avg_for_store. Значения в поле avg_for_store должны быть округлены до 1 знака после запятой.",25,4,"with A as ( select store, round(avg(amount), 1) as avg_for_store from Orders group by store ) select id, O.store, amount, avg_for_store  from Orders O left join A on O.store = A.store",,
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Flights; CREATE TABLE Flights (     departure_airport INT PRIMARY KEY AUTO_INCREMENT,     arrival_airport   INT,     flights_count     INT );  INSERT INTO Flights (arrival_airport, flights_count) VALUES  (8, 19),         (8, 47),         (11, 33),         (18, 17),         (2, 9),         (18, 21),         (12, 26),         (19, 13),         (13, 6),         (2, 9),         (3, 33),         (5, 2),         (1, 1),         (17, 49),         (2, 14),         (7, 21),         (15, 30),         (6, 14),         (9, 49),         (18, 10); ","Трафиком аэропорта называется общее количество авиарейсов, в которых участвует аэропорт (в качестве аэропорта отправления или аэропорта прибытия). Например, трафик аэропорта с идентификатором 1 равен 19 + 1 = 20.  Напишите запрос, который определяет идентификаторы аэропортов с наибольшим трафиком.  Поле с идентификатором аэропорта должно иметь псевдоним airport_id.",30,5,"with A as ( select store, round(avg(amount), 1) as avg_for_store from Orders group by store ) select id, O.store, amount, avg_for_store  from Orders O left join A on O.store = A.store","WITH Airports AS (     SELECT airport_id, SUM(flights_count) AS total_flights     FROM (SELECT departure_airport AS airport_id, flights_count           FROM Flights                       UNION ALL                    SELECT arrival_airport AS airport_id, flights_count           FROM Flights) AS F     GROUP BY airport_id )  SELECT airport_id FROM Airports WHERE total_flights = (SELECT MAX(total_flights)                        FROM Airports)","with ArrivalFLights as (     select arrival_airport as airport          , sum(flights_count) as flights_count       from Flights   group by arrival_airport ),  Traffic as (     select dep.departure_airport as airport          , dep.flights_count + ifnull(arr.flights_count, 0) as traffic       from Flights as dep  left join ArrivalFLights as arr         on dep.departure_airport = arr.airport )  select airport as airport_id   from Traffic  where traffic = (             select max(traffic)               from Traffic        );"
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Salaries; CREATE TABLE Salaries (     company_id    INT,     employee_id   INT,     employee_name VARCHAR(20),     salary        INT );  TRUNCATE Salaries; INSERT INTO Salaries (company_id, employee_id, employee_name, salary) VALUES (2, 19, 'Corey', 467),        (2, 13, 'Kayla', 8005),        (2, 3, 'Michael', 8009),        (3, 2, 'Wayne', 11275),        (3, 4, 'Scott', 5582),        (4, 18, 'Tina', 902),        (4, 15, 'Suzanne', 803),        (7, 17, 'Kayla', 10000),        (7, 5, 'Larry', 811),        (7, 3, 'Hector', 8952),        (9, 20, 'Gina', 555),        (9, 14, 'Veronica', 949),        (9, 7, 'Nathaniel', 757),        (9, 9, 'Frank', 999),        (9, 10, 'Stephen', 829),        (10, 7, 'Jacqueline', 11831),        (11, 15, 'Matthew', 9942),        (11, 4, 'Derek', 11059),        (13, 11, 'Alicia', 831),        (13, 8, 'Michael', 2644),        (13, 17, 'Kristie', 2207),        (14, 12, 'Alyssa', 947),        (14, 9, 'Alex', 2982),        (16, 10, 'Mark', 1000),        (16, 19, 'Kelly', 845),        (17, 13, 'Dustin', 423),        (17, 12, 'Cheyenne', 13965),        (18, 10, 'Steven', 6226),        (19, 16, 'Valerie', 8188),        (20, 3, 'Phillip', 12080); ","Для каждой организации налоговая служба определяет собственную налоговую ставку:  0%, если максимальная зарплата любого сотрудника организации меньше 1000 24%, если максимальная зарплата любого сотрудника организации находится в диапазоне [1000; 10000] ​​​​​​ 49%, если максимальная зарплата любого сотрудника организации больше 10000 Напишите запрос, который извлекает из предложенной базы данных идентификаторы и имена сотрудников организаций, а также зарплату каждого сотрудника после уплаты налогов.  Поле с идентификатором сотрудника должно иметь псевдоним id, поле с именем — name. Значения в поле salary должны быть округлены до ближайшего целого числа.  ",30,4,"with MS as ( select company_id as c_id, max(salary) as max_s from Salaries group by company_id ), CT as ( select company_id, employee_id, employee_name, salary, max_s   from Salaries S left join MS on S.company_id = MS.c_id ) select employee_id as id, employee_name as name, round(                                                    case                                                    when max_s < 1000 then salary                                                   when max_s > 10000 then salary-salary*0.49                                                   else salary-salary*0.24                                                   end) as salary from CT","with TaxRates as (  select    company_id,   case     when max(salary) < 1000 then 0    when max(salary) between 1000 and 10000 then 0.24    when max(salary) > 10000 then 0.49   end as tax_rate  from Salaries  group by    company_id )    select  s.employee_id as id,  s.employee_name as name,  round(s.salary * (1 - tr.tax_rate), 0) as salary from   Salaries as s  inner join TaxRates as tr on tr.company_id = s.company_id",
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Votes; CREATE TABLE Votes (     voter     VARCHAR(50),     candidate VARCHAR(50) );  INSERT INTO Votes (voter, candidate) VALUES ('Shaun', 'Eric'),        ('Donna', 'Emily'),        ('Donna', 'Moro'),        ('Tina', 'Deborah'),        ('Tina', 'Michael'),        ('Laura', NULL),        ('James', 'Michael'),        ('James', 'Emily'),        ('Wanda', 'Eric'),        ('Dustin', NULL),        ('William', 'Victoria'),        ('Kylie', 'Emily'),        ('Traci', 'Amber'),        ('William', 'Stephen'),        ('Tina', 'Christina'),        ('Kylie', 'Vincent'),        ('Shaun', 'Michael'),        ('Samantha', 'Stephen'),        ('James', 'Christina'),        ('Shaun', 'Vincent'),        ('Shaun', 'Deborah'),        ('Melissa', 'Amber'),        ('Samantha', 'Amber'),        ('Shaun', 'Bryan'),        ('Donna', 'Amber'),        ('Melissa', 'Eric'),        ('Robin', NULL),        ('Wanda', 'Emily'),        ('James', 'Stephen'),        ('Tina', 'Amber'),        ('Kevin', NULL),        ('Shaun', 'Victoria'),        ('Wanda', 'Bryan'),        ('Michelle', NULL),        ('Traci', 'Emily'),        ('Shaun', 'Stephen'),        ('William', 'Michael'),        ('William', 'Emily'),        ('John', NULL),        ('Melissa', 'Michael'); "," Каждый избиратель имеет 1 голос, который он может отдать одному или нескольким кандидатам. Если избиратель голосует за нескольких кандидатов, его голос распределяются между ними поровну. Например, если избиратель голосует за 2кандидатов, каждый из них получит по 0.5 голосов.  Напишите запрос, который определяет имя кандидата, набравшего наибольшее количество голосов.",35,5,"with K as ( select voter, 1 / count(*) as kt from Votes group by voter ), S as ( select V.voter, candidate, kt from Votes V left join K on V.voter = K.voter where candidate is not null ) select candidate from S group by candidate order by sum(kt) desc limit 1"," WITH test AS (     SELECT voter, 1 / COUNT(candidate) AS total     FROM Votes     GROUP BY voter )   SELECT candidate FROM Votes JOIN test ON Votes.voter = test.voter GROUP BY candidate ORDER BY SUM(total) DESC LIMIT 1",
9.6 Обобщенные табличные выражения. Часть 1 ,"DROP TABLE IF EXISTS Passengers; DROP TABLE IF EXISTS Buses;  -- Создание таблицы Buses CREATE TABLE Buses (     id             INT PRIMARY KEY AUTO_INCREMENT,     departure_time INT );  INSERT INTO Buses (departure_time) VALUES (2),        (4),        (7),        (9),        (11),        (13),        (15),        (17),        (19),        (21),        (1),        (3),        (5); -- Создание таблицы Passengers CREATE TABLE Passengers (     id           INT PRIMARY KEY,     arrival_time INT );  INSERT INTO Passengers (id, arrival_time) VALUES (11, 1),        (12, 5),        (13, 6),        (14, 7),        (15, 2),        (16, 10),        (17, 14),        (18, 7),        (19, 9),        (20, 20),        (21, 3),        (22, 8),        (23, 11),        (24, 18),        (25, 4),        (26, 12),        (27, 19),        (28, 16),        (29, 6),        (30, 14); "," Пассажиры прибывают на автовокзал в определенное время и из доступных автобусов выбирают тот, который уезжает раньше всех.  Напишите запрос, который определяет, со скольким количеством пассажиров выедет из автовокзала каждый автобус, и отображает полученный результат в виде таблицы из двух полей:  bus_id — идентификатор автобуса passenger_count — количество пассажиров в этом автобусе Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля bus_id.",40,6,"with T as ( select P.id as pass, min(B.departure_time) as bus_dep  from Passengers P cross join  Buses B where P.arrival_time <= B.departure_time group by pass      ) select id as bus_id, count(*) as passenger_count    from T inner join Buses B where T.bus_dep = B.departure_time group by bus_id","WITH total AS (     SELECT p.id, (SELECT id                   FROM Buses b                   WHERE b.departure_time >= p.arrival_time                   ORDER BY departure_time                   LIMIT 1) AS bus_id     FROM Passengers p )  SELECT bus_id, COUNT(id) AS passenger_count FROM total GROUP BY 1 ORDER BY 1;",
9.7 Рекурсивные CTE,,"Напишите запрос, который извлекает таблицу, содержащую квадраты всех целых чисел от 1 до 10 включительно.  Поле с квадратом целого числа должно иметь псевдоним number.",15,2,with recursive Qwaters as (    select 1 as number      union all    select (sqrt(number)+1)*(sqrt(number)+1)    from Qwaters    limit 10 ) select * from Qwaters,"WITH RECURSIVE Squares AS (     SELECT 1 AS number     UNION     SELECT POW(SQRT(number) + 1, 2)     FROM Squares     LIMIT 10 )  SELECT number FROM Squares;",
9.7 Рекурсивные CTE,,"Напишите запрос, который извлекает таблицу, содержащую все даты с 31 декабря 2024 года по 1 декабря 2024 включительно.  Поле с датой должно иметь псевдоним day.",20,3,"with recursive Days as (     select date('2024-12-31') as rts     union all     select subdate(rts,  interval 1 day)     from Days     limit 31 ) select rts as day from Days",WITH RECURSIVE December2024 AS (     SELECT '2024-12-31' AS day     UNION     SELECT day - INTERVAL 1 DAY     FROM December2024     LIMIT 31 )  SELECT * FROM December2024;,WITH RECURSIVE Dates AS (     SELECT '2024-12-31' AS day     UNION ALL     SELECT day - INTERVAL 1 DAY     FROM Dates     WHERE day > '2024-12-01' )  SELECT * FROM Dates;
9.7 Рекурсивные CTE,,"В SQL с помощью функции ORD() можно получить код символа в таблице ASCII.  Результатом приведенного ниже запроса:  SELECT ORD('A'),        ORD('B'),        ORD('C'); является:  +----------+----------+----------+ | ORD('A') | ORD('B') | ORD('C') | +----------+----------+----------+ | 65       | 66       | 67       | +----------+----------+----------+ С помощью функции CHAR() можно выполнить обратную операцию: получить символ по его коду.  Результатом приведенного ниже запроса:  SELECT CHAR(65),        CHAR(66),        CHAR(67); является:  +----------+----------+----------+ | CHAR(65) | CHAR(66) | CHAR(67) | +----------+----------+----------+ | b'A'     | b'B'     | b'C'     | +----------+----------+----------+ Обратите внимание, что возвращаемым значением функции CHAR() является байтовая строка, а не обычная. При необходимости получить результат в виде обычной строки достаточно выполнить дополнительную конвертацию.  Результатом приведенного ниже запроса:  SELECT CONVERT(CHAR(65), CHAR),        CONVERT(CHAR(66), CHAR),        CONVERT(CHAR(67), CHAR); является:  +-------------------------+-------------------------+-------------------------+ | CONVERT(CHAR(65), CHAR) | CONVERT(CHAR(66), CHAR) | CONVERT(CHAR(67), CHAR) | +-------------------------+-------------------------+-------------------------+ | A                       | B                       | C                       | +-------------------------+-------------------------+-------------------------+ Применив предложенные функции, напишите запрос, который извлекает таблицу, содержащую все заглавные латинские буквы от A до Z включительно.  Поле с латинской буквой должно иметь псевдоним letter.",30,5,"with recursive L as (     select 65 as let     union all     select let + 1     from L     limit 26 ) select CONVERT(CHAR(let), CHAR) as letter from L",WITH RECURSIVE AsciiUpperCase AS (     SELECT 'A' AS letter     UNION     SELECT CHAR(ORD(letter) + 1)     FROM AsciiUpperCase     LIMIT 26 )  SELECT * FROM AsciiUpperCase;,
9.7 Рекурсивные CTE,,"Напишите запрос, который извлекает таблицу, содержащую названия всех 12 месяцев на английском языке.  Поле с названием месяца должно иметь псевдоним month.",20,4,"with recursive M as (     select '2024-01-01' as mo     union all     select adddate(mo, interval 1 month)      from M     limit 12 ) select monthname(mo) as month from M",,
9.7 Рекурсивные CTE,,"Напишите запрос, который извлекает таблицу, содержащую все целые числа от 1 до 20 включительно, а также их факториалы.  Поле с целым числом должно иметь псевдоним number, поле с факториалом числа — factorial.",20,5,"with recursive F as (     select  1 as factorial, 1 as num     union all     select factorial * num, num + 1     from F     limit 20     offset 1 ) select num-1 as number, factorial from F","WITH RECURSIVE Factorials AS (     SELECT 1 AS number,            1 AS factorial     UNION ALL     SELECT number + 1, factorial * (number + 1)     FROM Factorials     LIMIT 20 )  SELECT * FROM Factorials;",
9.7 Рекурсивные CTE,,"Напишите запрос, который извлекает таблицу, содержащую 20 случайных целых чисел в диапазоне [10; 50].  Поле со случайным числом должно иметь псевдоним number.",25,5,with recursive R as (     select 10 as number     union all     select number + 1     from R     limit 41 ) select * from R order by rand() limit 20,WITH RECURSIVE RandomNumbers AS (     SELECT FLOOR(10 + RAND() * 41) AS number     UNION ALL     SELECT FLOOR(10 + RAND() * 41)     FROM RandomNumbers     LIMIT 20 )  SELECT * FROM RandomNumbers;,
9.7 Рекурсивные CTE,"CREATE TABLE Numbers (     num INT );  TRUNCATE Numbers; INSERT INTO Numbers VALUES (1),        (5),        (3),        (7),        (2); "," Напишите запрос, который извлекает из предложенной базы данных все целые числа, располагая их в порядке возрастания и добавляя между ними отсутствующие значения (например, число 4 между числами 3 и 5).",20,4,WITH RECURSIVE Digits AS (     SELECT MIN(num) AS num     FROM Numbers     UNION     SELECT num + 1     FROM Digits     WHERE num < (SELECT MAX(num) FROM Numbers) )  SELECT * FROM Digits;,,
9.7 Рекурсивные CTE,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id         INT PRIMARY KEY AUTO_INCREMENT,     store      VARCHAR(40),     order_date DATE );  TRUNCATE Orders; INSERT INTO Orders (store, order_date) VALUES ('Ozon      ', '2023-12-29'),        ('PCUniverse', '2023-12-31'),        ('PCUniverse', '2023-12-29'),        ('Mvideo', '2023-12-25'),        ('DarkStore', '2023-12-26'); "," Напишите запрос, который извлекает из предложенной базы данных все даты, располагая их в порядке возрастания и добавляя между ними отсутствующие даты (например, дату 2023-12-30 между датами 2023-12-29 и 2023-12-31). Помимо этого, для каждой даты должно быть указано количество заказов, совершенных в эту дату.  Поле с количеством заказов, совершенных в определенную дату, должно иметь псевдоним orders_count.",30,6,"with recursive D as (     select min(order_date) as order_date from Orders     union all     select order_date + interval 1 day     from D     where order_date < any (select order_date from Orders) ) select D.order_date, ifnull(count(store), 0) as orders_count from  D left join Orders O on D.order_date = O.order_date group by D.order_date","WITH RECURSIVE OrdersDate AS ( SELECT MIN(order_date) AS order_date FROM Orders UNION SELECT order_date + INTERVAL 1 DAY FROM OrdersDate WHERE order_date < (SELECT MAX(order_date) FROM Orders) )  SELECT order_date, IFNULL((SELECT COUNT(*)                     FROM Orders                     WHERE Orders.order_date = OrdersDate.order_date                     GROUP BY Orders.order_date), 0) AS orders_count",
9.8 Рекурсивные CTE,"DROP TABLE IF EXISTS Files; CREATE TABLE Files (     id                  INT PRIMARY KEY AUTO_INCREMENT,     name                VARCHAR(40),     parent_directory_id INT );  TRUNCATE Files; INSERT INTO Files (name, parent_directory_id) VALUES ('desktop', NULL),        ('test', 1),        ('Картинки', 2),        ('1.jpg', 3),        ('avatar.png', 3),        ('certificate.png', 3),        ('py.png', 3),        ('World_Time_Zones_Map.png', 3),        ('Снимок экрана.png', 3),        ('Неравенства.djvu', 2),        ('Программы', 2),        ('image_util.py', 11),        ('sort.py', 11),        ('Разные файлы', 2),        ('astros.json', 14); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы всех файлов и папок, а также указывающий для каждого файла или папки путь до него в следующем формате:  .../<название родительской папки>/<название файла или папки> Поле с путем до файла или папки должно иметь псевдоним path.",30,5,"with recursive P as (     select id, convert(name, char(100)) as path     from Files     where parent_directory_id is null     union all     select F.id, concat(P.path, '/', F.name)     from P join Files F on P.id = F.parent_directory_id ) select * from P",,
9.8 Рекурсивные CTE,"DROP TABLE IF EXISTS Investment; CREATE TABLE Investment (     id                INT PRIMARY KEY AUTO_INCREMENT,     investment_amount DECIMAL(20, 2) );  TRUNCATE Investment; INSERT INTO Investment (investment_amount) VALUES (9705321.00),        (5612948.60),        (5322146.00); ","Каждая инвестиционная сумма может быть инвестирована одним, двумя или тремя инвесторами. Если сумма инвестируется несколькими инвесторами, она делится между ними поровну.  Напишите запрос, который разделяет каждую инвестиционную сумму на равные доли в зависимости от количества инвесторов и отображает полученный результат в виде таблицы из трех полей:  investors_number — количество инвесторов investment_amount — инвестиционная сумма individual_amount — доля каждого инвестора",40,6,"with recursive I as (     select 1 as investors_number, investment_amount, investment_amount as individual_amount      from Investment     union all      select investors_number + 1, investment_amount,             investment_amount/(investors_number + 1)     from I     where investors_number <=2 ) select * from I order by investment_amount",,
9.8 Рекурсивные CTE,"DROP TABLE IF EXISTS Routes; CREATE TABLE Routes (     source_city      VARCHAR(40),     destination_city VARCHAR(40),     distance         INT );  TRUNCATE Routes; INSERT INTO Routes VALUES ('New York', 'Boston', 215),        ('New York', 'Philadelphia', 95),        ('Philadelphia', 'Washington', 140),        ('Boston', 'Chicago', 985),        ('Washington', 'Atlanta', 640),        ('Atlanta', 'Miami', 660); ","Напишите запрос, извлекающий из предложенной базы данных названия городов, в которые можно добраться из города New York (напрямую или с помощью промежуточных рейсов), а также указывающий расстояние маршрута до каждого города.  ",30,6,"with recursive F as  (     select destination_city, distance     from Routes     where source_city = 'New York'     union all     select R.destination_city, R.distance + F.distance as distance     from F join Routes R on F.destination_city = R.source_city ) select * from F",,
9.8 Рекурсивные CTE,"DROP TABLE IF EXISTS Tasks; CREATE TABLE Tasks (     id                 INT PRIMARY KEY AUTO_INCREMENT,     name               VARCHAR(40),     depends_on_task_id INT,     time_required      INT  );  TRUNCATE Tasks; INSERT INTO Tasks (name, depends_on_task_id, time_required) VALUES ('Development', NULL, 10),        ('Testing', 1, 5),        ('Deployment', 2, 2); "," Напишите запрос, извлекающий из предложенной базы данных названия всех задач, а также указывающий для каждой задачи время, необходимое для ее выполнения, с учетом времени решения всех задач, от которых она зависит.  Поле с конечным временем, необходимым для выполнения задачи, должно иметь псевдоним total_time.",25,5,"with recursive W as (     select id, name, time_required as total_time     from Tasks     where depends_on_task_id is null     union all     select T.id, T.name, W.total_time + T.time_required as total_time     from W join Tasks T on W.id = T.depends_on_task_id ) select name, total_time from W",,
9.8 Рекурсивные CTE,"DROP TABLE IF EXISTS Routes; CREATE TABLE Routes (     source_city      VARCHAR(40),     destination_city VARCHAR(40)  );  TRUNCATE Routes; INSERT INTO Routes VALUES ('Groningen', 'Heerenveen'),        ('Groningen', 'Harlingen'),        ('Harlingen', 'Wieringerwerf'),        ('Wieringerwerf', 'Hoorn'),        ('Hoorn', 'Amsterdam'),        ('Amsterdam', 'Haarlem'),        ('Heerenveen', 'Lelystad'),        ('Lelystad', 'Amsterdam'); "," Напишите запрос, определяющий все возможные маршруты, которыми можно добраться из города Groningen в город Haarlem, и указывающий полученные результаты в поле с псевдонимом route в следующем формате:  Groningen -> <название промежуточного города> -> ... -> <название промежуточного города> -> Haarlem ",45,7,"with recursive T as  (     select destination_city, convert(concat('Groningen', ' -> ', destination_city), char(500)) as route     from Routes     where source_city = 'Groningen'     union all     select R.destination_city, concat(T.route, ' -> ', R.destination_city)      from T join Routes R on T.destination_city = R.source_city ) select route from T where route like ('%Haarlem')","WITH RECURSIVE Travels AS (     SELECT CONVERT(CONCAT(source_city, ' -> ', destination_city), CHAR(100)) AS route,            destination_city     FROM Routes     WHERE source_city = 'Groningen'      UNION ALL      SELECT CONCAT(Travels.route, ' -> ', Routes.destination_city), Routes.destination_city     FROM Travels     INNER JOIN Routes ON Travels.destination_city = Routes.source_city )  SELECT route FROM Travels WHERE destination_city = 'Haarlem';",
9.8 Рекурсивные CTE,"DROP TABLE IF EXISTS Genealogy; CREATE TABLE Genealogy (     id        INT PRIMARY KEY,     name      VARCHAR(20),     father_id INT,     mother_id INT,     FOREIGN KEY (father_id) REFERENCES Genealogy (id),     FOREIGN KEY (mother_id) REFERENCES Genealogy (id) );  TRUNCATE Genealogy; INSERT INTO Genealogy VALUES (1, 'Maria', NULL, NULL),        (2, 'Tom', NULL, NULL),        (3, 'Robert', NULL, NULL),        (4, 'Claire', NULL, NULL),        (5, 'Jennifer', 2, 1),        (6, 'Sam', 3, 4),        (7, 'James', 6, 5); ","Напишите запрос, извлекающий из предложенной базы данных имена всех членов семьи, а также указывающий для каждого члена его родственное отношение к члену семьи по имени James:  mother — мать father — отец grandmother — бабушка grandfather — дедушка Сам James по отношению к самому себе должен являться сыном — son.  Поле с родственным отношением члена семьи должно иметь псевдоним relationship.  ",70,9,"DROP TABLE IF EXISTS Genealogy; CREATE TABLE Genealogy (     id        INT PRIMARY KEY,     name      VARCHAR(20),     father_id INT,     mother_id INT,     FOREIGN KEY (father_id) REFERENCES Genealogy (id),     FOREIGN KEY (mother_id) REFERENCES Genealogy (id) );  TRUNCATE Genealogy; INSERT INTO Genealogy VALUES (1, 'Maria', NULL, NULL),        (2, 'Tom', NULL, NULL),        (3, 'Robert', NULL, NULL),        (4, 'Claire', NULL, NULL),        (5, 'Jennifer', 2, 1),        (6, 'Sam', 3, 4),        (7, 'James', 6, 5); ","WITH RECURSIVE JamesRelations AS (     SELECT *,            CONVERT('son', CHAR(30)) AS relationship,            0 AS level     FROM Genealogy     WHERE name = 'James'      UNION ALL      SELECT Genealogy.*,            CASE                WHEN JamesRelations.father_id = Genealogy.id AND level = 0 THEN 'father'                WHEN JamesRelations.mother_id = Genealogy.id AND level = 0 THEN 'mother'                WHEN JamesRelations.father_id = Genealogy.id AND level = 1 THEN 'grandfather'                WHEN JamesRelations.mother_id = Genealogy.id AND level = 1 THEN 'grandmother'            END,            level + 1     FROM JamesRelations     INNER JOIN Genealogy ON Genealogy.id = JamesRelations.father_id OR Genealogy.id = JamesRelations.mother_id )  SELECT name, relationship FROM JamesRelations;",
10.1 Переменные ,,"Напишите запрос, который создает пользовательскую переменную с именем variable и присваивает ей в качестве значения строку Hello, World!.",5,1,"set @variable := 'Hello, World!'; ",,
10.1 Переменные ,,"Напишите запрос, который создает пользовательскую переменную с именем number и присваивает ей в качестве значения число 2361822, представленное в двоичной системе счисления.",15,3,"set @number := conv(2361822, 10, 2); ",,
10.1 Переменные ,,"Напишите запрос, который создает пользовательские переменные с именами name, birthdate и pets. В качестве значения переменной name должно быть присвоено Ваше имя, представленное строкой, переменной birthdate — Ваша дата рождения в формате YYYY-MM-DD, переменной pets — количество имеющихся у Вас домашних животных.",10,1,"set @name := 'Kiryl',     @birthdate := '1981-03-29',     @pets := 0","SELECT 'Vasiliy', '1980-01-01', 1          INTO @name, @birthdate, @pets;",
10.1 Переменные ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который создает пользовательскую переменную с именем avg_usa_rating и присваивает ей в качестве значения средний рейтинг режиссеров из USA, округленный до 2 знаков после запятой.",10,2,"set @avg_usa_rating := (select round(avg(rating),2) from Directors  where country = 'usa') ;","SELECT ROUND(AVG(rating), 2) INTO @avg_usa_rating FROM Directors WHERE country = 'USA';",
10.1 Переменные ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', NULL),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', NULL),        ('Tim', 'Burton', 'USA', NULL); "," Напишите запрос, который создает пользовательскую переменную с именем num_of_rated_directors и присваивает ей в качестве значения количество режиссеров, рейтинг которых известен.",10,2,SET @num_of_rated_directors := (SELECT COUNT(*)                                 FROM Directors                                 WHERE rating IS NOT NULL),SELECT COUNT(*) INTO @num_of_rated_directors FROM Directors WHERE rating IS NOT NULL,
10.1 Переменные ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); ","Напишите запрос, который создает пользовательскую переменную с именем min_usa_rating, присваивает ей в качестве значения минимальный рейтинг режиссеров из USA и извлекает значение созданной переменной.",10,2,set @min_usa_rating := (                         select min(rating) from Directors                         where country = 'USA' ) ; select @min_usa_rating as min_usa_rating,SELECT MIN(rating) INTO @min_usa_rating FROM Directors WHERE country = 'USA';  SELECT @min_usa_rating AS min_usa_rating,
10.1 Переменные ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(40),     surname VARCHAR(40),     country VARCHAR(40),     rating  INT );  TRUNCATE Directors; INSERT INTO Directors (name, surname, country, rating) VALUES ('Christopher', 'Nolan', 'England', 90),        ('Steven', 'Spielberg', 'USA', 79),        ('Quentin', 'Tarantino', 'USA', 95),        ('Martin', 'Scorsese', 'USA', 68),        ('David', 'Fincher', 'USA', 100),        ('Ridley', 'Scott', 'England', 54),        ('Stanley', 'Kubrick', 'USA', 9),        ('Clint', 'Eastwood', 'USA', 74),        ('James', 'Cameron', 'Canada', 8),        ('Tim', 'Burton', 'USA', 41); "," Напишите запрос, который создает пользовательские переменные с именами name, surname и rating. В качестве значения переменной name должно быть присвоено имя режиссера из USA с наименьшим рейтингом, переменным surname и rating — фамилия и рейтинг соответственно.",15,3,"SELECT name, surname, rating   INTO @name, @surname, @rating   FROM Directors  WHERE rating = (SELECT MIN(rating)                    FROM Directors                   WHERE country = 'USA')   AND country = 'USA'","set @name := (select name from Directors               where country = 'USA'               order by rating               limit 1); set @surname := (select surname from Directors                  where country = 'USA'                  order by rating                  limit 1); set @rating := (select min(rating) from Directors                  where country = 'USA') ; select @name, @surname, @rating",
10.2 Пользовательские функции. Часть 1 ,,"Реализуйте функцию NON_SPACE_CHARACTERS(), которая принимает один аргумент:  string — строка Функция должна возвращать количество символов в строке string, не являющихся пробелом.",20,3,"delimiter // create function NON_SPACE_CHARACTERS(string text) returns text deterministic  begin   return char_length(replace(string, ' ', '')); end // delimiter;",,
10.2 Пользовательские функции. Часть 1 ,,"Реализуйте функцию SAME_DIGITS(), которая принимает один аргумент:  number — положительное целое число Функция должна возвращать число 1, если число number состоит из одинаковых цифр, или 0 в противном случае.",40,6,"delimiter // create function SAME_DIGITS(number int) returns int deterministic begin   declare unit int;   set unit := left(number, 1);   return if(repeat((unit), char_length(number)) = number, 1, 0); end // delimiter;"," CREATE FUNCTION SAME_DIGITS(number INT) RETURNS INT  RETURN number = REPEAT(LEFT(number, 1), CHAR_LENGTH(number))",
10.2 Пользовательские функции. Часть 1 ,,"Реализуйте функцию CALCULATE(), которая принимает три аргумента в следующем порядке:  a — число с плавающей точкой b — число с плавающей точкой operation — один из четырех символов, определяющих математическую операцию: +, -, * или / Функция должна возвращать значение выражения a operation b.",30,3,"delimiter // create function CALCULATE(a float, b float, operation char(5) ) returns float deterministic begin   return case operation          when '+' then a+b          when '-' then a-b          when '/' then a/b          else a*b          end;            end // delimiter;"," CREATE FUNCTION CALCULATE(a FLOAT, b FLOAT, operation TEXT) RETURNS FLOAT  RETURN CASE operation              WHEN '+' THEN a + b              WHEN '-' THEN a - b              WHEN '*' THEN a * b              WHEN '/' THEN a / b         END;",
10.2 Пользовательские функции. Часть 1 ,,"MIDDLE_POINT() Реализуйте функцию MIDDLE_POINT(), которая принимает четыре аргумента в следующем порядке:  x1 — целое число y1 — целое число x2 — целое число y2 — целое число Функция должна определять координаты точки, являющейся серединой отрезка с концами в точках  ( x 1 ; y 1 ) (x  1 ​  ;y  1 ​  ) и  ( x 2 ; y 2 ) (x  2 ​  ;y  2 ​  ), и возвращать полученный результат в виде строки в следующем формате:  (<координата точки по оси x>; <координата точки по оси y>) ",25,3,"CREATE FUNCTION MIDDLE_POINT(x1 INT, y1 INT, x2 INT, y2 INT) RETURNS TINYTEXT DETERMINISTIC RETURN CONCAT('(', (x1 + x2) / 2, '; ', (y1 + y2) / 2, ')');","delimiter // create function MIDDLE_POINT(x1 int, y1 int, x2 int, y2 int) returns text deterministic  begin   return concat('(', (x1+x2)/2, '; ', (y1+y2)/2, ')')         ; end // delimiter;",
10.2 Пользовательские функции. Часть 1 ,,"Реализуйте функцию LAST_SECOND_DIGIT(), которая принимает один аргумент:  number — положительное целое число Функция должна возвращать вторую по счету цифру числа number с конца. При попытке получить вторую по счету с конца цифру однозначного числа функция LAST_SECOND_DIGIT() должна вернуть значение NULL.",25,3,"DELIMITER // CREATE FUNCTION LAST_SECOND_DIGIT(number INT) RETURNS INT DETERMINISTIC BEGIN     RETURN IF(CHAR_LENGTH(number) > 1, SUBSTRING(number, -2, 1), NULL); END // DELIMITER ;","CREATE FUNCTION LAST_SECOND_DIGIT(number INT UNSIGNED) RETURNS INT DETERMINISTIC COMMENT 'Функция должна возвращать вторую по счету цифру числа number с конца' RETURN (SELECT IF(number>9,number DIV 10 MOD 10,NULL));",
10.2 Пользовательские функции. Часть 1 ,,"Функция SOLVE() Квадратный трехчлен – это многочлен вида  a x 2 + b x + c ax  2  +bx+c, где  a ≠ 0 a  =0. Например: x 2 + 1 x 2 − 5 x + 6 x  2  +1 x  2  −5x+6 Значение переменной  x x, при котором квадратный трехчлен обращается в ноль, называют его корнем. Квадратный трехчлен может иметь один корень, два корня или вовсе не иметь корней. Корни квадратного трехчлена, если они существуют, находятся по формуле: x 1 , 2 = − b ± b 2 − 4 a c 2 a x  1,2 ​  =  2a −b±  b  2  −4ac ​   ​   Реализуйте функцию SOLVE(), которая принимает три аргумента в следующем порядке:  a — целое число, коэффициент  a a квадратного трехчлена b — целое число, коэффициент  b b квадратного трехчлена c — целое число, коэффициент  c c квадратного трехчлена Функция должна возвращать корень многочлена с коэффициентами a, b и c. Если многочлен с переданными коэффициентами имеет два корня, функция SOLVE() должна вернуть меньший из них, если не имеет корней — значение NULL.  Тестовые данные Примечание 1. В качестве типов параметров функции, типа возвращаемого значения и типов переменных допустимо использовать любые согласованные с условием задачи типы данных.",50,5,"delimiter // create function SOLVE(a int, b int, c int) returns double deterministic begin   declare x1 double;   declare x2 double;   set x1 := (-b-sqrt(pow(b, 2)-4*a*c))/(2*a);   set x2 := (-b+sqrt(pow(b, 2)-4*a*c))/(2*a);   return if(x1 < x2, x1, x2);    end // delimiter;","CREATE FUNCTION SOLVE(a INT, b INT, c INT) RETURNS FLOAT DETERMINISTIC      RETURN (IF(a = 0, NULL, LEAST((-b-SQRT(b*b-4*a*c))/(2*a), (-b+SQRT(b*b-4*a*c))/(2*a))))",
10.2 Пользовательские функции. Часть 1 ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id         INT PRIMARY KEY AUTO_INCREMENT,     store      VARCHAR(40),     order_date DATE,     amount     INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325); ","Реализуйте функцию TOTAL(), которая принимает один аргумент:  store_name — строка, название магазина Функция должна возвращать общую сумму, которую заработал магазин с названием store_name.",15,3,delimiter // create function TOTAL(store_name text) returns int not deterministic reads sql data begin   return (select sum(amount) from Orders           group by store           having store = store_name); end // delimiter;,CREATE FUNCTION TOTAL(store_name TEXT) RETURNS INT RETURN (SELECT SUM(amount) FROM Orders         WHERE store = store_name);,
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию POSITIVE_SUM(), которая принимает три аргумента в следующем порядке:  a — целое число b — целое число c — целое число Функция должна выбирать из чисел a, b и c положительные и возвращать их сумму. Если ни одно из переданных в функцию чисел не является положительным, функция должна вернуть число 0.",30,5,"delimiter // create function POSITIVE_SUM(a int, b int, c int) returns int deterministic begin   if a > 0 then set a := a;   else set a := 0;   end if;   if b > 0 then set b := b;   else set b := 0;   end if;   if c > 0 then set c := c;   else set c := 0;   end if;   return a+b+c; end // delimiter;","CREATE FUNCTION POSITIVE_SUM(a INT, b INT, c INT) RETURNS INT DETERMINISTIC BEGIN     DECLARE result INT DEFAULT 0;     IF a > 0 THEN         SET result := result + a;     END IF;     IF b > 0 THEN         SET result := result + b;     END IF;     IF c > 0 THEN         SET result := result + c;     END IF;     RETURN result; END; ","create function POSITIVE_SUM(a int, b int, c int) returns int return greatest(a, 0) + greatest(b, 0) + greatest(c, 0);"
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию IS_DIGIT(), которая принимает один аргумент:  string — строка Функция должна возвращать число 1, если строка string состоит исключительно из цифровых символов, или 0 в противном случае.",40,6,"delimiter // create function IS_DIGIT(string char(50)) returns int deterministic begin    while left(string, 1) between '0' and '9' do    set string := substring(string, 2);    end while;    if string like '' then return 1;    end if;    return 0; end //    delimiter;","CREATE FUNCTION IS_DIGIT(string TEXT) RETURNS INT DETERMINISTIC BEGIN     WHILE CHAR_LENGTH(string) > 0 DO         IF LEFT(string, 1) NOT BETWEEN '0' AND '9' THEN             RETURN 0;         end if;     SET string := MID(string, 2);     end while;     RETURN 1; END;",
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию SUM_OF_FIRST_DIGITS(), которая принимает один аргумент:  string — строка Функция должна суммировать все цифровые символы в строке string слева направо до тех пор, пока не встретится хотя бы один нецифровой символ, и возвращать полученный результат. Если переданная в функцию строка начинается с нецифрового символа, функция должна вернуть число 0.",50,7,"delimiter // create function SUM_OF_FIRST_DIGITS(string text) returns int deterministic begin   declare summ int default 0;   while left(string, 1) between '0' and '9' do   set summ := summ + left(string, 1);   set string := substring(string, 2);   end while;   return summ; end // delimiter;"," CREATE FUNCTION SUM_OF_FIRST_DIGITS(string TEXT) RETURNS INT DETERMINISTIC BEGIN     DECLARE ind INT DEFAULT 1;     DECLARE symbol CHAR;     DECLARE result INT DEFAULT 0;     WHILE ind <= CHAR_LENGTH(string) DO         SET symbol := SUBSTRING(string, ind, 1);         IF symbol IN ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9') THEN             SET result := result + CAST(symbol AS UNSIGNED);         ELSE             RETURN result;         END IF;         SET ind := ind + 1;     END WHILE;      RETURN result; END;    ",
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию SWAPCASE(), которая принимает один аргумент:  string — строка Функция должна заменять в строке string регистр всех буквенных символов на противоположный и возвращать полученный результат.",60,8,"delimiter // create function SWAPCASE(string text) returns text deterministic begin   declare n int default 1;   declare r text default '';   declare let text default substring(string, 1, 1);   declare res text default '';   while char_length(string) >= n do     if let like binary upper(let) then set r := lower(let);     elseif let like binary lower(let) then set r := upper(let);     end if;        set n := n + 1;    set let := substring(string, n, 1);    set res := concat(res, r);   end while;   return res;  end // delimiter;  select SWAPCASE('123BeEgEeK')  "," CREATE FUNCTION SWAPCASE(string TEXT) RETURNS TEXT DETERMINISTIC BEGIN     DECLARE ind INT DEFAULT 1;     DECLARE symbol CHAR;     DECLARE result TEXT DEFAULT '';     WHILE ind <= CHAR_LENGTH(string) DO         SET symbol := SUBSTRING(string, ind, 1);         IF BINARY symbol = LOWER(symbol) THEN             SET result := CONCAT(result, UPPER(symbol));         ELSE             SET result := CONCAT(result, LOWER(symbol));         END IF;         SET ind := ind + 1;     END WHILE;      RETURN result; END;",
10.3 Пользовательские функции. Часть 2 ,,"Функция MIN_DIGIT() Реализуйте функцию MIN_DIGIT(), которая принимает один аргумент:  number — положительное целое число Функция должна возвращать минимальную цифру числа number.",50,8,"delimiter // create function MIN_DIGIT(number char(50)) returns int deterministic begin    declare ind int default char_length(number);   declare pos int default substring(number, 1, 1);   declare mini int default 9;      while ind >= 1 do    if pos < mini then set mini := pos;    else set mini := mini;    end if;   set pos := substring(number, ind, 1);   set ind := ind - 1;   end while;      return mini; end // delimiter;       ",CREATE FUNCTION MIN_DIGIT(number INT)     RETURNS TINYINT BEGIN     DECLARE result TINYINT;     SET result = 9;      WHILE number > 0 DO         IF number MOD 10 < result THEN             SET result = number MOD 10;         END IF;                  SET number = number DIV 10;     END WHILE;      RETURN result; END;," CREATE FUNCTION MIN_DIGIT(number INT) RETURNS INT DETERMINISTIC BEGIN     DECLARE ind INT DEFAULT 1;     DECLARE symbol CHAR;     DECLARE result INT DEFAULT 9;     WHILE ind <= CHAR_LENGTH(number) DO         SET symbol := SUBSTRING(number, ind, 1);         IF symbol < result THEN             SET result := symbol;         END IF;         SET ind := ind + 1;     END WHILE;      RETURN result; END;"
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию FACTORIAL(), которая принимает один аргумент:  n — положительное целое число Функция должна возвращать произведение всех целых чисел от 1 до n включительно.",30,6,delimiter // create function FACTORIAL(n int) returns int deterministic begin    declare pos int default 1;   declare result int default 1;      while pos <= n do     set result := pos * result;          set pos := pos + 1;   end while;   return result; end // delimiter;, CREATE FUNCTION FACTORIAL(n INT) RETURNS INT DETERMINISTIC BEGIN      DECLARE res INT DEFAULT 1;     WHILE n > 1 DO         SET res := res * n;         SET n := n - 1;     END WHILE;             RETURN res; END ;,
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию SUM_OF_MID_DIGITS(), которая принимает один аргумент:  number — положительное целое число Функция должна возвращать сумму цифр числа number, не учитывая первую и последнюю цифры. Если переданное в функцию число является однозначным или двузначным, функция должна вернуть число 0.",40,7,"delimiter // create function SUM_OF_MID_DIGITS(number int) returns int deterministic begin   declare pos int default 1;   declare dig int default substring(number, 1, 1);   declare res int default 0;      while pos < (char_length(number)-1) do   set pos := pos + 1;   set dig := substring(number, pos, 1);   set res := res + dig;   end while;      return res; end // delimiter;                                         ",DELIMITER // CREATE FUNCTION SUM_OF_MID_DIGITS(number INT)     RETURNS INT     DETERMINISTIC BEGIN     DECLARE total INT DEFAULT 0;     WHILE number > 99 DO         SET number := number DIV 10;         SET total := total + number % 10;     END WHILE;             RETURN total; END // DELIMITER ;,
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию COMPARE_TWO_NUMBERS(), которая принимает два аргумента в следующем порядке:  a — целое число b — целое число Функция должна выполнять сравнение чисел a и b и возвращать:  строку вида <число a> < <число b>, если число a меньше числа b строку вида <число a> > <число b>, если число a больше числа b строку вида <число a> = <число b>, если число a равно числу b",25,4,"delimiter // create function COMPARE_TWO_NUMBERS(a int, b int) returns text deterministic begin   if a < b   then return concat(a, ' < ', b);   elseif a > b   then return concat(a, ' > ', b);   elseif a = b   then return concat(a, ' = ', b);   end if; end // delimiter;","CREATE FUNCTION COMPARE_TWO_NUMBERS(a INT,b INT) RETURNS TEXT DETERMINISTIC RETURN CASE           WHEN a > b THEN CONCAT(a,' > ',b)           WHEN a = b THEN CONCAT(a,' = ',b)           ELSE CONCAT(a,' < ',b) END;",
10.3 Пользовательские функции. Часть 2 ,,"Реализуйте функцию DIGITAL_ROOT(), которая принимает один аргумент:  number — положительное целое число Функция должна возвращать цифровой корень числа number.",60,8,"delimiter // create function DIGITAL_ROOT(number int) returns int deterministic begin    declare pos int default 1;   declare res int default substring(number, 1, 1);   while pos <= char_length(number) do   set pos := pos + 1;   set res := res + substring(number, pos, 1);   end while;   set res := substring(res, 1, 1) + substring(res, 2, 1);   if res < 10    then return res;    else return (substring(res, 1, 1) + substring(res, 2, 1));     end if;   end // delimiter;",DELIMITER // CREATE FUNCTION DIGITAL_ROOT(number INT) RETURNS INT DETERMINISTIC BEGIN     DECLARE result INT DEFAULT 0;     WHILE number > 0 DO         SET result := result + number MOD 10;         SET number := number DIV 10;         IF number = 0 AND result >= 10 THEN             SET number := result;             SET result := 0;         END IF;     END WHILE;     RETURN result; END // DELIMITER ; ,
10.3 Пользовательские функции. Часть 2 ,," Реализуйте функцию REPEAT_AFTER_ME(), которая принимает два аргумента в следующем порядке:  delimiter — строка n — положительное целое число Функция должна возвращать строку, сформированную следующим образом:  0 <delimiter> 1 <delimiter> 2 <delimiter> 3 <delimiter> ... <delimiter> n Строка должна содержать последовательные целые числа от 0 до n, между которыми заключена строка delimiter.",60,7,"delimiter // create function REPEAT_AFTER_ME(delimiter text, n int) returns text deterministic comment 'как вс_конкат' begin   declare num int default 0;   declare res text default '0';   while num < n do    set num := num + 1;    set res := concat(res,  ' ', delimiter, ' ', num);   end while;   return res; end // delimiter;",,
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325),        ('Gloria Jeans', 811),        ('Mvideo', 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        ('Gloria Jeans', 1500),        ('Ozon', 242),        ('PCUniverse', 679),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', 42),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 522),        ('Mvideo', 10),        ('Gloria Jeans', 400); ","Реализуйте процедуру SHOW_TOP_SELLERS(), которая не принимает никаких аргументов. Процедура должна извлекать из предложенной базы данных названия трех магазинов с наибольшей общей суммой продаж.",20,3,delimiter // create procedure SHOW_TOP_SELLERS() not deterministic begin   select store from Orders   group by store   order by sum(amount) desc   limit 3; end // delimiter; call SHOW_TOP_SELLERS,DELIMITER // CREATE PROCEDURE SHOW_TOP_SELLERS() BEGIN     SELECT store     FROM Orders     GROUP BY store     ORDER BY SUM(amount) DESC     LIMIT 3; END // DELIMITER ;,CREATE PROCEDURE SHOW_TOP_SELLERS()         SELECT store     FROM Orders     GROUP BY store     ORDER BY SUM(amount) DESC     LIMIT 3;
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', NULL),        (NULL, NULL),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', NULL),        (NULL, 458),        ('Ozon', 801),        (NULL, 325),        ('Gloria Jeans', 811),        (NULL, 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        (NULL, 1500),        ('Ozon', 242),        ('PCUniverse', NULL),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', NULL),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 822),        (NULL, 10),        ('Gloria Jeans', 400); "," Реализуйте процедуру DELETE_UNKNOWN_ORDERS(), которая не принимает никаких аргументов. Процедура должна удалять из таблицы Orders заказы, которые были совершены в неизвестном магазине или на неизвестную сумму.",20,2,delimiter // create procedure DELETE_UNKNOWN_ORDERS() not deterministic begin   delete from Orders   where store is null or amount is null; end // delimiter; call DELETE_UNKNOWN_ORDERS;,CREATE PROCEDURE DELETE_UNKNOWN_ORDERS()     DELETE FROM Orders     WHERE store IS NULL OR amount IS NULL;,
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325),        ('Gloria Jeans', 811),        ('Mvideo', 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        ('Gloria Jeans', 1500),        ('Ozon', 242),        ('PCUniverse', 679),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', 42),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 822),        ('Mvideo', 10),        ('Gloria Jeans', 400); "," Реализуйте процедуру ORDERS_STATISTICS(), которая не принимает никаких аргументов. Процедура должна определять количество совершенных на маркетплейсе заказов, а также среднюю сумму заказа и указывать полученные значения в полях с псевдонимами orders_count и avg_order_amount соответственно.",15,2,"delimiter // create procedure ORDERS_STATISTICS() not deterministic begin   select count(*) as orders_count, avg(amount) as avg_order_amount from Orders   ; end // delimiter; call ORDERS_STATISTICS()","CREATE PROCEDURE ORDERS_STATISTICS() select count(*) ""orders_count"", avg(amount) ""avg_order_amount"" from Orders;",
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id         INT PRIMARY KEY AUTO_INCREMENT,     store      VARCHAR(40),     order_date DATE,     amount     INT );  INSERT INTO Orders (store, order_date, amount) VALUES ('Ozon', '2023-11-05', 101),        ('PCUniverse', '2023-06-08', 799),        ('PCUniverse', '2023-08-21', 99),        ('DarkStore', '2023-11-17', 99),        ('DarkStore', '2023-06-25', 1015),        ('Ozon', '2023-10-10', 678),        ('PCUniverse', '2023-06-06', 858),        ('Ozon', '2023-10-26', 458),        ('Ozon', '2023-10-23', 801),        ('DarkStore', '2023-08-02', 325),        ('Gloria Jeans', '2023-07-03', 811),        ('Mvideo', '2023-10-06', 422),        ('Mvideo', '2023-04-20', 667),        ('Gloria Jeans', '2023-03-18', 83),        ('Gloria Jeans', '2023-02-24', 1500),        ('Ozon', '2023-02-12', 242),        ('PCUniverse', '2023-02-19', 679),        ('Gloria Jeans', '2023-04-30', 328),        ('Ozon', '2023-03-26', 1),        ('DarkStore', '2023-03-04', 42),        ('PCUniverse', '2023-02-28', 189),        ('Gloria Jeans', '2023-04-17', 317),        ('DarkStore', '2023-12-23', 822),        ('Mvideo', '2023-01-03', 10),        ('Gloria Jeans', '2023-02-08', 400); ","Реализуйте процедуру ORDERS_FROM_TO(), которая принимает два аргумента в следующем порядке:  start_date — начальная дата end_date — конечная дата Процедура должна извлекать из предложенной базы данных всю информацию о заказах, которые были сделаны со start_date по end_date включительно.",20,3,"delimiter // create procedure ORDERS_FROM_TO(start_date text, end_date text) begin   select * from Orders   where order_date <= end_date and order_date >= start_date; end // delimiter; call ORDERS_FROM_TO('2023-02-01', '2023-04-01');","DELIMITER // CREATE PROCEDURE ORDERS_FROM_TO(IN start_date DATE, IN end_date DATE) BEGIN     SELECT *     FROM Orders     WHERE order_date BETWEEN start_date AND end_date; END // DELIMITER ;",
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325),        ('Gloria Jeans', 811),        ('Mvideo', 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        ('Gloria Jeans', 1500),        ('Ozon', 242),        ('PCUniverse', 679),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', 42),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 822),        ('Mvideo', 10),        ('Gloria Jeans', 400); ","Реализуйте процедуру STORE_STATISTICS(), которая принимает четыре аргумента в следующем порядке:  store_name — строка, название магазина avg_order_amount — пользовательская переменная min_order_amount — пользовательская переменная max_order_amount — пользовательская переменная Процедура должна определять для магазина store_name среднюю сумму заказа, минимальную сумму заказа и максимальную сумму заказа, а затем записывать полученные значения в переменные avg_order_amount, min_order_amount и max_order_amount соответственно.",35,5,"delimiter // create procedure STORE_STATISTICS(store_name text, out avg_order_amount double, out min_order_amount int, out max_order_amount int) begin   set avg_order_amount := (select avg(amount) from Orders                            where store = store_name),       min_order_amount := (select min(amount) from Orders                            where store = store_name),       max_order_amount := (select max(amount) from Orders                            where store = store_name); end // delimiter;","DELIMITER // CREATE PROCEDURE STORE_STATISTICS(IN store_name TEXT, OUT avg_order_amount DECIMAL(10, 4), OUT min_order_amount INT, OUT max_order_amount INT) BEGIN     SELECT AVG(amount), MIN(amount), MAX(amount) INTO avg_order_amount, min_order_amount, max_order_amount     FROM Orders     WHERE store = store_name; END // DELIMITER ;","CREATE PROCEDURE STORE_STATISTICS(store_name TEXT, OUT avg_order_amount FLOAT,                                    OUT min_order_amount INT, OUT max_order_amount INT)        SELECT AVG(amount),      MIN(amount),      MAX(amount)            INTO avg_order_amount, min_order_amount, max_order_amount          FROM Orders         WHERE store = store_name;"
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT,     status VARCHAR(40) );  INSERT INTO Orders (store, amount, status) VALUES ('Ozon', 101, 'Created'),        ('PCUniverse', 799, 'Shipped'),        ('PCUniverse', 99, 'Delivered'),        ('DarkStore', 99, 'Created'),        ('DarkStore', 1015, 'Shipped'),        ('Ozon', 678, 'Delivered'),        ('PCUniverse', 858, 'Delivered'),        ('Ozon', 458, 'Created'),        ('Ozon', 801, 'Shipped'),        ('DarkStore', 325, 'Delivered'),        ('Gloria Jeans', 811, 'Delivered'),        ('Mvideo', 422, 'Created'),        ('Mvideo', 667, 'Shipped'),        ('Gloria Jeans', 83, 'Delivered'),        ('Gloria Jeans', 1500, 'Shipped'),        ('Ozon', 242, 'Delivered'),        ('PCUniverse', 679, 'Created'),        ('Gloria Jeans', 328, 'Delivered'),        ('Ozon', 1, 'Delivered'),        ('DarkStore', 42, 'Shipped'),        ('PCUniverse', 189, 'Delivered'),        ('Gloria Jeans', 317, 'Shipped'),        ('DarkStore', 822, 'Delivered'),        ('Mvideo', 10, 'Created'),        ('Gloria Jeans', 400, 'Delivered'); "," Реализуйте процедуру UPDATE_ORDER_STATUS(), которая принимает два аргумента в следующем порядке:  order_id — целое число, идентификатор заказа updated_status — пользовательская переменная Процедура должна обновлять в таблице Orders статус заказа с идентификатором order_id согласно следующему правилу:  если статус заказа равен Created, он должен быть изменен на Shipped если статус заказа равен Shipped, он должен быть изменен на Delivered если статус заказа равен Delivered, он должен быть изменен на Completed Помимо этого, процедура должна записывать обновленный статус заказа в переменную updated_status.",40,6,"delimiter // create procedure UPDATE_ORDER_STATUS(order_id int,                                       out updated_status text) begin    update Orders   set status =   case    when status = 'Created' then 'Shipped'   when status = 'Shipped' then 'Delivered'   when status = 'Delivered' then 'Completed'     end   where id = order_id;   set updated_status := (select status from Orders                          where id = order_id); end // delimiter;","create procedure UPDATE_ORDER_STATUS(in order_id int, out updated_status text) begin      update Orders      set status = if (status = 'Created', 'Shipped', if (status = 'Shipped', 'Delivered', 'Completed'))      where id = order_id;      set updated_status := (select status from Orders where id = order_id); end;","  DELIMITER // CREATE PROCEDURE UPDATE_ORDER_STATUS(IN order_id INT, OUT updated_status CHAR(50)) BEGIN     SET updated_status := (SELECT CASE status                                   WHEN 'Created' THEN 'Shipped'                                   WHEN 'Shipped' THEN 'Delivered'                                   WHEN 'Delivered' THEN 'Completed'                                   END                                   FROM Orders                                   WHERE id = order_id);     UPDATE Orders     SET status = updated_status     WHERE id = order_id; END // DELIMITER ;"
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325),        ('Gloria Jeans', 811),        ('Mvideo', 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        ('Gloria Jeans', 1500),        ('Ozon', 242),        ('PCUniverse', 679),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', 42),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 822),        ('Mvideo', 10),        ('Gloria Jeans', 400); ","Реализуйте процедуру ORDERS_COUNT(), которая принимает один аргумент:  store_name — строка, название магазина, или значение NULL Если значение store_name является строкой, процедура должна определить общее количество совершенных заказов в магазине store_name.  Если же значение store_name равняется NULL, процедура должна извлечь из предложенной базы данных названия всех магазинов и указать общее количество совершенных заказов в каждом из них. Поле с общим количеством совершенных заказов должно иметь псевдоним orders_count.",30,5,"delimiter // create procedure ORDERS_COUNT(store_name text) begin   if store_name = any(select store from Orders)          then select count(*) as orders_count from Orders              where store_name = store;   elseif store_name is null          then select store, count(*) as orders_count from Orders              group by store;   end if; end // delimiter;",,
10.4 Хранимые процедуры ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id     INT PRIMARY KEY AUTO_INCREMENT,     store  VARCHAR(40),     amount INT );  INSERT INTO Orders (store, amount) VALUES ('Ozon', 101),        ('PCUniverse', 799),        ('PCUniverse', 99),        ('DarkStore', 99),        ('DarkStore', 1015),        ('Ozon', 678),        ('PCUniverse', 858),        ('Ozon', 458),        ('Ozon', 801),        ('DarkStore', 325),        ('Gloria Jeans', 811),        ('Mvideo', 422),        ('Mvideo', 667),        ('Gloria Jeans', 83),        ('Gloria Jeans', 1500),        ('Ozon', 242),        ('PCUniverse', 679),        ('Gloria Jeans', 328),        ('Ozon', 1),        ('DarkStore', 42),        ('PCUniverse', 189),        ('Gloria Jeans', 317),        ('DarkStore', 822),        ('Mvideo', 10),        ('Gloria Jeans', 400); "," Реализуйте процедуру ADD_ORDER(), которая принимает два аргумента в следующем порядке:  store_name — строка, название магазина, или значение NULL order_amount — целое число, сумма заказа, или значение NULL Если значение store_name является строкой, а значение order_amount — положительным числом, процедура должна добавить в таблицу Orders информацию о заказе, совершенном в магазине store_name на сумму order_amount, а затем извлечь таблицу следующего вида:  +------------------------+ | Success                | +------------------------+ | Заказ успешно добавлен | +------------------------+ Если значение store_name является строкой, а значение order_amount — отрицательным числом или нулем, процедура должна всего лишь извлечь таблицу следующего вида:  +---------------------------+ | Error                     | +---------------------------+ | Некорректная сумма заказа | +---------------------------+ Если же одно или оба значения store_name и order_amount равняются NULL, процедура должна всего лишь извлечь таблицу следующего вида:  +------------------------------+ | Error                        | +------------------------------+ | Недостаточно данных о заказе | +------------------------------+",50,5,"delimiter // create procedure ADD_ORDER(store_name text, order_amount int) begin   if store_name is not null and order_amount > 0      then select 'Заказ успешно добавлен' as 'Success';          insert into Orders (store, amount)          values (store_name, order_amount)          ;   elseif store_name is not null and order_amount <= 0      then select 'Некорректная сумма заказа' as 'Error';   elseif store_name is null or order_amount is null      then select 'Недостаточно данных о заказе' as 'Error';      end if;  end // delimiter;","DELIMITER // CREATE PROCEDURE ADD_ORDER(store_name TEXT, order_amount INT) BEGIN  IF CHAR_LENGTH(store_name) > 0 AND order_amount > 0 THEN     INSERT INTO Orders     SET   store = store_name,         amount = order_amount;  SET @Success := 'Заказ успешно добавлен';     SELECT @Success AS Success;     END IF;          IF CHAR_LENGTH(store_name) > 0 AND order_amount <= 0 THEN     SET @Error := 'Некорректная сумма заказа';     SELECT @Error AS Error;     END IF;          IF store_name IS NULL OR order_amount IS NULL THEN     SET @Error := 'Недостаточно данных о заказе';     SELECT @Error AS Error;     END IF;    END // DELIMITER ;",
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', 1999),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', 2012),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', 1995),        ('The Incredibles', 'Brad Bird', 2004); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, имя и фамилия режиссера, год выхода), а также пронумеровывает их, начиная с 1, в порядке возрастания года выхода.  Поле с номером фильма должно располагаться на первом месте и иметь псевдоним num.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля num.",15,3,"SELECT row_number() over (order by release_year) as num, title, director, release_year FROM Films order by release_year desc","SELECT ROW_NUMBER() OVER (ORDER BY release_year) AS num,        title, director, release_year FROM Films ORDER BY num DESC;",
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', 1999),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', 2012),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', 1995),        ('The Incredibles', 'Brad Bird', 2004); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, имя и фамилия режиссера, год выхода), а также пронумеровывает их, начиная с 0 с шагом 5 (0, 5, 10, ...), в порядке убывания года выхода.  Поле с номером фильма должно располагаться на первом месте и иметь псевдоним num.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля num.",20,4,"select ((row_number() over (order by release_year desc))-1)*5 as num,         title,         director,         release_year from Films order by num desc","WITH temp AS (SELECT ROW_NUMBER() OVER (ORDER BY release_year DESC) as num, title, director, release_year    FROM Films WINDOW pixar_fims AS () ORDER BY num DESC)  SELECT num * 5 - 5 AS num, title, director, release_year FROM temp",
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', 1999),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', 2012),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', 1995),        ('The Incredibles', 'Brad Bird', 2004); "," Напишите запрос, который извлекает из предложенной базы данных информацию о фильмах (название, имя и фамилия режиссера, год выхода), а также пронумеровывает их, начиная с 1, в рамках режиссера в порядке возрастания года выхода.  Поле с номером фильма должно располагаться на первом месте и иметь псевдоним num.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля director, при совпадении — в порядке убывания значения поля num.",15,3,"select row_number() over (partition by director order by release_year) as num,        title,         director,        release_year  from Films order by director, num desc",,
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS PrimeNumbers; CREATE TABLE PrimeNumbers (     num INT );  TRUNCATE PrimeNumbers; INSERT INTO PrimeNumbers (num) VALUES (19),        (7),        (2),        (5),        (23),        (13),        (3),        (17),        (29),        (11); ","Напишите запрос, который извлекает из предложенной базы данных все простые числа, а также пронумеровывает их латинскими буквами, начиная с A, в порядке возрастания.  Поле с буквенным номером числа должно располагаться на первом месте и иметь псевдоним letter.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля num.",25,5,"select CONVERT(CHAR(((row_number() over (order by num))+64)), CHAR) as letter, num from PrimeNumbers order by letter desc",,
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', 1999),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', 2012),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', 1995),        ('The Incredibles', 'Brad Bird', 2004); ","Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех режиссеров, а также указывает для каждого режиссера название его самого раннего фильма.",30,5,"with T as ( select director,         title,         release_year,         row_number() over (partition by director order by release_year) as num from Films ) select director, title from T where num = 1","SELECT director, title FROM     (SELECT ROW_NUMBER() OVER (PARTITION BY director ORDER BY release_year) AS num,            title, director     FROM Films) AS tbl WHERE num = 1",
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id INT AUTO_INCREMENT PRIMARY KEY,     title VARCHAR(50),     director VARCHAR(50),     release_year INT );  TRUNCATE Films; INSERT INTO Films (title, director, release_year) VALUES ('The Incredibles', 'Brad Bird', 2004),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('The Incredibles', 'Brad Bird', 2004),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('WALL-E', 'Andrew Stanton', 2008),        ('Up', 'Pete Docter', 2009),        ('The Incredibles', 'Brad Bird', 2004); ","Напишите запрос, который извлекает из предложенной базы данных информацию об уникальных фильмах (название, имя и фамилия режиссера, год выхода), а также пронумеровывает их, начиная с 1, в порядке возрастания года выхода.  Поле с номером фильма должно располагаться на первом месте и иметь псевдоним num.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля num.",15,4,"select row_number() over () as num,        title,        director,         release_year from (select distinct title, director, release_year from Films       order by 3) as T  order by num desc","WITH UniqueFilms AS (     SELECT DISTINCT title, director, release_year     FROM Films ) SELECT ROW_NUMBER() OVER (ORDER BY release_year) AS num,        UniqueFilms.* FROM UniqueFilms ORDER BY num DESC;","SELECT ROW_NUMBER() OVER (ORDER BY release_year) AS num, title, director, release_year FROM Films GROUP BY title, director, release_year ORDER BY num DESC"
11.1 Окна. Ранжирующие функции. Часть 1 ,"DROP TABLE IF EXISTS Numbers; CREATE TABLE Numbers (     num INT );  INSERT INTO Numbers (num)  VALUES (1),        (2),        (3),        (5),        (10),        (11),        (15),        (16),        (17),        (18),        (20); ","В рамках упорядоченной последовательности целых чисел будем называть островком любую подпоследовательность наибольшей длины, разница между членами которой равна единице. Первое число в подпоследовательности обозначим началом островка, последнее — концом. Например, последовательность чисел из таблицы Numbers содержит островки 1-3, 5-5, 10-11, 15-18 и 20-20. Обратите внимание, что если островок состоит из одного числа, то это число является как началом островка, так и его концом.  Напишите запрос, который находит все островки, содержащиеся в последовательности чисел из таблицы Numbers, и отображает полученный результат в виде таблицы из двух полей:  start — начало островка end — конец островка",60,8,"with R as (select min(num) as start, max(num) as end, num-n as t  from (select row_number() over () as n, num from Numbers) as T group by t) select start, end from R",,
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id        INT PRIMARY KEY AUTO_INCREMENT,     full_name VARCHAR(40),     country   VARCHAR(40),     rating    INT );  INSERT INTO Directors (full_name, country, rating) VALUES ('Christopher Nolan', 'England', 90),        ('Steven Spielberg', 'USA', 79),        ('Quentin Tarantino', 'USA', 100),        ('Martin Scorsese', 'USA', 41),        ('David Fincher', 'USA', 100),        ('Ridley Scott', 'England', 54),        ('Stanley Kubrick', 'USA', 79),        ('Clint Eastwood', 'USA', 74),        ('James Cameron', 'Canada', 8),        ('Tim Burton', 'USA', 100); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех режиссерах (имя и фамилия, страна рождения, рейтинг), а также пронумеровывает их, начиная с 1, в рамках страны рождения в порядке убывания рейтинга. При этом если два режиссера из одной страны имеют равные рейтинги, то их номера также должны совпадать.  Поле с номером режиссера должно располагаться на первом месте и иметь псевдоним rank_in_country.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля country, при совпадении — в порядке убывания значения поля rank_in_country, при совпадении — в порядке убывания значения поля id.",15,3,"select dense_rank() over (partition by country order by rating desc) as rank_in_country,        full_name,         country,        rating  from Directors order by country, rank_in_country desc, id desc",,
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id        INT PRIMARY KEY AUTO_INCREMENT,     full_name VARCHAR(40),     country   VARCHAR(40),     rating    INT );  TRUNCATE Directors; INSERT INTO Directors (full_name, country, rating) VALUES ('Christopher Nolan', 'England', 90),        ('Steven Spielberg', 'USA', 79),        ('Quentin Tarantino', 'USA', 100),        ('Martin Scorsese', 'USA', 41),        ('David Fincher', 'USA', 100),        ('Ridley Scott', 'England', 54),        ('Stanley Kubrick', 'USA', 79),        ('Clint Eastwood', 'USA', 74),        ('James Cameron', 'Canada', 90),        ('Tim Burton', 'USA', 100); ","Напишите запрос, который извлекает из предложенной базы данных информацию о режиссерах (имя и фамилия, рейтинг) со вторым по величине наибольшим рейтингом.",15,3,"with T as (select dense_rank() over(order by rating desc) as r, full_name, rating from Directors) select full_name, rating from T where r = 2 order by full_name","select full_name, rating from (select dense_rank() over (order by rating desc) as num,  full_name, rating     from Directors) as directors_with_groups where num = 2 order by full_name",
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id        INT PRIMARY KEY AUTO_INCREMENT,     full_name VARCHAR(40),     country   VARCHAR(40),     rating    INT );  INSERT INTO Directors (full_name, country, rating) VALUES ('Christopher Nolan', 'England', 90),        ('Steven Spielberg', 'USA', 79),        ('Quentin Tarantino', 'USA', 100),        ('Martin Scorsese', 'USA', 41),        ('David Fincher', 'USA', 100),        ('Ridley Scott', 'England', 54),        ('Stanley Kubrick', 'USA', 79),        ('Clint Eastwood', 'USA', 74),        ('James Cameron', 'Canada', 8),        ('Tim Burton', 'USA', 100); ","Напишите запрос, который извлекает из предложенной таблицы Directors всю информацию обо всех режиссерах, сначала указывая режиссеров из второй половины таблицы (идентификаторы с 6 по 10), а затем — из первой (идентификаторы с 1 по 5). В рамках каждой половины режиссеры должны быть расположены в порядке убывания рейтинга, при совпадении — в порядке возрастания идентификатора.",20,4,"select         id,        full_name,        country,        rating from Directors        order by (ntile(2) over (order by id desc)), rating desc, id","select id, full_name, country, rating  from(select id, full_name, country, rating, ntile(2) over addiction as addict_rating      from Directors      window addiction as (order by id)) as addict order by addict_rating desc, rating desc, id",
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id        INT PRIMARY KEY AUTO_INCREMENT,     full_name VARCHAR(40),     country   VARCHAR(40),     rating    INT );  INSERT INTO Directors (full_name, country, rating) VALUES ('Christopher Nolan', 'England', 90),        ('Steven Spielberg', 'USA', 79),        ('Quentin Tarantino', 'USA', 100),        ('Martin Scorsese', 'USA', 41),        ('David Fincher', 'USA', 100),        ('Ridley Scott', 'England', 54),        ('Stanley Kubrick', 'USA', 79),        ('Clint Eastwood', 'USA', 74),        ('James Cameron', 'Canada', 8),        ('Tim Burton', 'USA', 100); ","Напишите запрос, который извлекает из предложенной базы данных информацию о режиссерах (имя и фамилия, страна рождения, рейтинг), которые в рамках своей страны имеют самый высокий рейтинг. Если в стране несколько режиссеров с самым высоким рейтингом, то в результирующую таблицу должны быть добавлены они все.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля country, при совпадении — в порядке возрастания значения поля full_name.",20,3,"with R as ( select full_name,        country,        rating,        dense_rank() over (partition by country order by rating desc) as d from Directors) select full_name,        country,        rating  from R where d = 1 order by country, full_name","select full_name, country, rating from (select full_name, country, rating, dense_rank() over addiction as addict_rating       from Directors       window addiction as (partition by country order by rating desc)) as addict where addict_rating = 1 order by country, full_name",
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', 1999),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', 2012),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', 1995),        ('The Incredibles', 'Brad Bird', 2004); "," Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех режиссеров, а также указывает для каждого режиссера количество снятых им фильмов. Помимо этого, режиссеры должны быть пронумерованы, начиная с 1, в порядке убывания количества снятых фильмов. При этом если два режиссера имеют равное количество снятых фильмов, то их номера также должны совпадать.  Поле с номером режиссера должно располагаться на первом месте и иметь псевдоним place, в то время как поле с количеством снятых фильмов должно располагаться на последнем месте и иметь псевдоним number_of_films.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля place, при совпадении — в порядке возрастания значения поля director.",15,3,"with T as ( select director,        count(*) as s from Films        group by director) select dense_rank() over (order by s desc) as place,        director,        s as number_of_films from T        order by place, director","SELECT DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) AS place,        director,        COUNT(*) AS number_of_films FROM Films GROUP BY director ORDER BY place, director;",
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id        INT PRIMARY KEY AUTO_INCREMENT,     full_name VARCHAR(40),     country   VARCHAR(40),     rating    INT );  TRUNCATE Directors; INSERT INTO Directors (full_name, country, rating) VALUES ('Christopher Nolan', 'England', 90),        ('Steven Spielberg', 'USA', 79),        ('Quentin Tarantino', 'USA', 100),        ('Martin Scorsese', 'USA', 41),        ('David Fincher', 'USA', 100),        ('Ridley Scott', 'England', 54),        ('Stanley Kubrick', 'USA', 79),        ('Clint Eastwood', 'USA', 74),        ('James Cameron', 'Canada', 8); ","Напишите запрос, который разбивает режиссеров на группы по три человека (первый-второй-третий, четвертый-пятый-шестой, и так далее), определяет средний рейтинг режиссеров каждой группы и отображает полученный результат в виде таблицы из двух полей:  group_number — номер группы avg_rating — средний рейтинг режиссеров группы Записи в результирующей таблице должны быть расположены в порядке убывания значения поля group_number.",30,6,"set @id := (select count(*) div 3 from Directors);  with T  as (     select ntile(@id) over (order by id) as group_number,        rating from Directors) select group_number, avg(rating) as avg_rating from T group by group_number order by group_number desc","SELECT count(*) DIV 3 INTO @Num_Groups FROM Directors; SELECT group_number, AVG(rating) ""avg_rating"" FROM (SELECT NTILE(@Num_Groups) OVER (ORDER BY id) ""group_number"", rating FROM Directors) Z GROUP BY group_number ORDER BY group_number DESC;",
11.2 Окна. Ранжирующие функции. Часть 2 ,"DROP TABLE IF EXISTS Directors; CREATE TABLE Directors (     id        INT PRIMARY KEY AUTO_INCREMENT,     full_name VARCHAR(40),     country   VARCHAR(40),     rating    INT );  TRUNCATE Directors; INSERT INTO Directors (full_name, country, rating) VALUES ('Christopher Nolan', 'England', 90),        ('Steven Spielberg', 'USA', 79),        ('Quentin Tarantino', 'USA', 100),        ('Martin Scorsese', 'USA', 41),        ('David Fincher', 'USA', 100),        ('Ridley Scott', 'England', 54),        ('Stanley Kubrick', 'USA', 79),        ('Clint Eastwood', 'USA', 74),        ('James Cameron', 'Canada', 8),        ('Tim Burton', 'USA', 100); ","Напишите запрос, который разбивает режиссеров на пары (первый-второй, третий-четвертый, и так далее) и определяет, родились ли режиссеры каждой пары в одной и той же стране. Запрос должен отобразить полученный результат в виде таблицы из двух полей:  pair — имя и фамилия обоих режиссеров пары в следующем формате: <имя и фамилия первого режиссера>, <имя и фамилия второго режиссера> from_same_country — значение yes, если режиссеры родились в одной и той же стране, или no в противном случае",30,4,"set @p := (select max(id) div 2 from Directors); with T as ( select ntile(@p) over () as p,        full_name,        country,        id from Directors) select concat(T1.full_name, ', ', T2.full_name) as pair,        case          when T1.country = T2.country then 'yes'          else 'no'        end as from_same_country from T T1 join T T2 on T1.p = T2.p and T1.full_name != T2.full_name and T1.id+1 = T2.id","SELECT COUNT(*) DIV 2 INTO @count_of_groups FROM Directors;  WITH GroupDirectors AS (     SELECT Directors.*,            NTILE(@count_of_groups) OVER (ORDER BY id) AS group_director     FROM Directors )  SELECT GROUP_CONCAT(full_name SEPARATOR ', ') AS pair,        IF(COUNT(DISTINCT country) = 1, 'yes', 'no') AS from_same_country FROM GroupDirectors GROUP BY group_director;",
11.3 Оконные функции. Агрегатные функции ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     rating INT );  INSERT INTO Films (title, director, release_year, rating)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 99),        ('WALL-E', 'Andrew Stanton', 2008, 100),        ('Ratatouille', 'Brad Bird', 2007, 87),        ('Up', 'Pete Docter', 2009, 100),        ('Brave', 'Brenda Chapman', 2012, 50),        ('Monsters University', 'Dan Scanlon', 2013, 65),        ('Cars 2', 'John Lasseter', 2011, 90),        ('Finding Nemo', 'Andrew Stanton', 2003, 50),        ('Toy Story', 'John Lasseter', 1995, 78),        ('The Incredibles', 'Brad Bird', 2004, 81); "," Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, имя и фамилия режиссера, рейтинг), а также указывает для каждого фильма, какой средний рейтинг имеют все фильмы режиссера, снявшего этот фильм.  Поле со средним рейтингом фильмов режиссера должно иметь псевдоним avg_rating_by_director.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля director, при совпадении — в порядке возрастания значения поля rating.  ",15,2,"select title,         director,        rating,        avg(rating) over (partition by director) as avg_rating_by_director from Films order by director, rating",,
11.3 Оконные функции. Агрегатные функции ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', 1999),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', 2007),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', 2012),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', 1995),        ('The Incredibles', 'Brad Bird', 2004); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, имя и фамилия режиссера), а также указывает для каждого фильма, сколько фильмов среди всех остальных сняты тем же самым режиссером.  Поле с количеством фильмов, снятых тем же самым режиссером, должно иметь псевдоним films_with_same_director.",15,2,"select title,        director,        (count(*) over (partition by director))-1 as films_with_same_director from Films",,
11.3 Оконные функции. Агрегатные функции ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT );  INSERT INTO Films (title, director, release_year)  VALUES ('Toy Story 2', 'John Lasseter', NULL),        ('WALL-E', 'Andrew Stanton', 2008),        ('Ratatouille', 'Brad Bird', NULL),        ('Up', 'Pete Docter', 2009),        ('Brave', 'Brenda Chapman', NULL),        ('Monsters University', 'Dan Scanlon', 2013),        ('Cars 2', 'John Lasseter', 2011),        ('Finding Nemo', 'Andrew Stanton', 2003),        ('Toy Story', 'John Lasseter', NULL),        ('The Incredibles', 'Brad Bird', NULL); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, имя и фамилия режиссера), а также указывает для каждого фильма, сколько фильмов среди всех остальных не имеют года выхода.  Поле с количеством фильмов без года выхода должно иметь псевдоним other_films_without_release_year.  ",25,4,"SELECT title, director,        SUM(release_year IS NULL) OVER () - (release_year IS NULL) AS other_films_without_release_year FROM Films;",,
11.3 Оконные функции. Агрегатные функции ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     rating INT );  INSERT INTO Films (title, director, release_year, rating)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 99),        ('WALL-E', 'Andrew Stanton', 2008, 100),        ('Ratatouille', 'Brad Bird', 2007, 87),        ('Up', 'Pete Docter', 2009, 100),        ('Brave', 'Brenda Chapman', 2012, 50),        ('Monsters University', 'Dan Scanlon', 2013, 65),        ('Cars 2', 'John Lasseter', 2011, 90),        ('Finding Nemo', 'Andrew Stanton', 2003, 50),        ('Toy Story', 'John Lasseter', 1995, 78),        ('The Incredibles', 'Brad Bird', 2004, 81); "," Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, рейтинг), а также указывает для каждого фильма средний рейтинг среди всех остальных фильмов.  Поле со средним рейтингом всех остальных фильмов должно иметь псевдоним other_films_avg_rating. Значения в этом поле должны быть округлены до целого числа.",20,4,"select title,        rating,        round((sum(rating) over () - rating)/(count(*) over () - 1), 0) as other_films_avg_rating from Films","select title, rating, round((summary - rating) / amount, 0) as other_films_avg_rating from (select title, rating, sum(rating) over () as summary, count(*) over() - 1 as amount       from Films) as addition",
11.3 Оконные функции. Агрегатные функции ,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(20),     director     VARCHAR(20),     release_year INT,     rating INT );  INSERT INTO Films (title, director, release_year, rating)  VALUES ('Toy Story 2', 'John Lasseter', 1999, 99),        ('WALL-E', 'Andrew Stanton', 2008, 100),        ('Ratatouille', 'Brad Bird', 2007, 87),        ('Up', 'Pete Docter', 2009, 100),        ('Brave', 'Brenda Chapman', 2012, 50),        ('Monsters University', 'Dan Scanlon', 2013, 65),        ('Cars 2', 'John Lasseter', 2011, 90),        ('Finding Nemo', 'Andrew Stanton', 2003, 50),        ('Toy Story', 'John Lasseter', 1995, 78),        ('The Incredibles', 'Brad Bird', 2004, 81); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех фильмах (название, рейтинг), а также указывает для каждого фильма, на сколько процентов его рейтинг больше, чем рейтинг самого низко оцененного фильма.  При этом в результирующей таблице разница между рейтингами фильмов должна быть округлена до целого числа и указана в поле c псевдонимом better_than_low_rated_film в следующем формате:  <разница между рейтингами фильмов>% Записи в результирующей таблице должны быть расположены в порядке убывания разницы между рейтингами фильмов.",20,6,"select title,        rating,        concat(round((rating - min(rating) over ()) /  min(rating) over () * 100), '%') as               better_than_low_rated_film from Films order by rating desc","WITH AddedMinRating AS      (SELECT Films.*,             MIN(rating) OVER () AS min_rating      FROM Films)       SELECT title, rating,        CONCAT(ROUND((rating * 100 / min_rating) - 100), ""%"") AS better_than_low_rated_film FROM AddedMinRating ORDER BY rating DESC;",
11.4 Границы окон ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     month INT,     quantity INT );  INSERT INTO Sales (month, quantity) VALUES (1, 180000),        (2, 210000),        (3, 195000),        (4, 245000),        (5, 200000),        (6, 230000),        (7, 275000),        (8, 215000),        (9, 250000),        (10, 265000),        (11, 220000),        (12, 290000); ","Напишите запрос, который извлекает из предложенной базы данных номера всех месяцев, а также указывает для каждого месяца среднее количество проданных товаров, учитывая лишь предыдущий, текущий и следующий месяцы.  Поле со средним количеством проданных товаров за месяц должно иметь псевдоним avg_quantity. ",10,2,"select month,        avg(quantity) over (rows between 1 preceding and 1 following) as avg_quantity from Sales","SELECT month,        AVG(quantity) OVER (ORDER BY month ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS avg_quantity FROM Sales;",
11.4 Границы окон ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     month INT,     quantity INT );  INSERT INTO Sales (month, quantity) VALUES (1, 180000),        (2, 210000),        (3, 195000),        (4, 245000),        (5, 200000),        (6, 230000),        (7, 275000),        (8, 215000),        (9, 250000),        (10, 265000),        (11, 220000),        (12, 290000); ","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за каждый месяц, а также указывает для каждого месяца количество проданных товаров за предыдущий месяц.  Поле с количеством проданных товаров за предыдущий месяц должно иметь псевдоним prev_month_quantity.",15,3,"select month,        quantity,         ifnull(sum(quantity) over (rows between 1 preceding and 1 preceding), 0) as prev_month_quantity from Sales",,
11.4 Границы окон ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     month INT,     quantity INT );  INSERT INTO Sales (month, quantity) VALUES (1, 180000),        (2, 210000),        (3, 195000),        (4, 245000),        (5, 200000),        (6, 230000),        (7, 275000),        (8, 215000),        (9, 250000),        (10, 265000),        (11, 220000),        (12, 290000); "," Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за каждый месяц, а также указывает для каждого месяца суммарное количество проданных товаров за текущий и все предыдущие месяцы.  Поле с суммарным количеством проданных товаров за текущий и все предыдущие месяцы должно иметь псевдоним",10,2,"select month,        quantity,        sum(quantity) over (rows between unbounded preceding and current row) as total_quantity from Sales","SELECT month, quantity,        SUM(quantity) OVER (ORDER BY month                            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS total_quantity FROM Sales;",
11.4 Границы окон ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     month INT,     quantity INT );  INSERT INTO Sales (month, quantity) VALUES (1, 180000),        (2, 210000),        (3, 195000),        (4, 245000),        (5, 200000),        (6, 230000),        (7, 275000),        (8, 215000),        (9, 250000),        (10, 265000),        (11, 220000),        (12, 290000); ","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за каждый месяц, начиная с третьего, а также указывает для каждого месяца среднее количество проданных товаров за два предыдущих месяца.  Поле со средним количеством проданных товаров за два предыдущих месяца должно иметь псевдоним two_prev_months_avg_quantity.",20,4,"with S as ( select month,        quantity,        avg(quantity) over (rows between 2 preceding and 1 preceding) as two_prev_months_avg_quantity from Sales) select * from S where month > 2","SELECT month, quantity, AVG(quantity) OVER(ORDER BY month ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING) AS two_prev_months_avg_quantity FROM Sales LIMIT 10 OFFSET 2",
11.4 Границы окон ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     month INT,     quantity INT );  INSERT INTO Sales (month, quantity) VALUES (1, 180000),        (2, 210000),        (3, 195000),        (4, 245000),        (5, 200000),        (6, 230000),        (7, 275000),        (8, 215000),        (9, 250000),        (10, 265000),        (11, 220000),        (12, 290000); ","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за каждый месяц, а также указывает для каждого месяца суммарное количество проданных товаров за текущий и все предыдущие месяцы в рамках квартала.  Поле с суммарным количеством проданных товаров за текущий и все предыдущие месяцы в рамках квартала должно иметь псевдоним total_quantity_within_quarter.",20,4,"with S as (     select month,         quantity,        ntile(4) over (order by month) as q         from Sales) select month,         quantity,        sum(quantity) over (partition by q order by month rows between unbounded preceding and current row) as total_quantity_within_quarter from S","SELECT *        , SUM(quantity) OVER windowByQarters            AS total_quantity_within_quarter   FROM Sales  WINDOW windowByQarters AS (      PARTITION BY (month + 2) DIV 3          ORDER BY month           ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);",
11.4 Границы окон ,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id INT PRIMARY KEY AUTO_INCREMENT,     date DATE,     amount INT );  INSERT INTO Orders (date, amount) VALUES  ('2024-01-01', 100),         ('2024-01-02', 200),         ('2024-01-02', 150),         ('2024-01-03', 300),         ('2024-01-04', 75),         ('2024-01-05', 120),         ('2024-01-05', 250),         ('2024-01-05', 180),         ('2024-01-06', 90),         ('2024-01-07', 210); "," Напишите запрос, который извлекает из предложенной базы данных всю информацию обо всех заказах, а также указывает для каждого заказа среднюю сумму заказа, учитывая лишь все предыдущие дни, а также тот день, в который был совершен заказ.  Поле со средней суммой заказа за текущий и все предыдущие дни должно иметь псевдоним avg_amount.",15,3,"select id, date, amount,         avg(amount) over (order by date range between unbounded preceding and current row) as avg_amount from Orders",,
11.4 Границы окон ,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     day DATE,     quantity INT );  INSERT INTO Sales (day, quantity) VALUES ('2024-01-01', 180000),        ('2024-01-02', 210000),        ('2024-01-03', 195000),        ('2024-01-04', 195000),        ('2024-01-07', 200000),        ('2024-01-08', 190000),        ('2024-01-09', 275000),        ('2024-01-12', 215000),        ('2024-01-14', 250000),        ('2024-01-15', 215000); ","Напишите запрос, который извлекает из предложенной базы данных всю информацию, а также указывает для каждого дня (даты), было ли продано в этот день товаров больше, чем в предыдущий день:  yes, если товаров было продано больше no, если товаров было продано столько же или меньше unknown, если информация о продажах за предыдущий день отсутствует Поле с оценкой продаж за день должно иметь псевдоним sales_better_than_yesterday.",30,6,"SELECT day, quantity,        IF(SUM(quantity) OVER yesterday IS NULL, 'unknown',           IF(SUM(quantity) OVER yesterday < quantity, 'yes', 'no')) AS sales_better_than_yesterday FROM Sales WINDOW yesterday AS (ORDER BY day                      RANGE BETWEEN INTERVAL 1 DAY PRECEDING                                 AND INTERVAL 1 DAY PRECEDING);","with S as ( select day, quantity,        sum(quantity) over (order by day range between interval 1 day preceding and current row) as p from Sales) select day, quantity,        case when p = quantity then 'unknown'             when quantity > (p - quantity) then 'yes'             else 'no'        end as sales_better_than_yesterday from S","SELECT day, quantity,        CASE SUM(quantity) OVER (            ORDER BY day            RANGE BETWEEN INTERVAL 1 DAY PRECEDING AND INTERVAL 1 DAY PRECEDING) < quantity            WHEN TRUE THEN 'yes'            WHEN FALSE THEN 'no'            ELSE 'unknown'        END AS sales_better_than_yesterday FROM Sales;        "
11.5. Оконные функции. Функции смещения.,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders ( id INT PRIMARY KEY AUTO_INCREMENT, date DATE, amount INT ); INSERT INTO Orders (date, amount) VALUES ('2024-01-01', 100), ('2024-01-01', 200), ('2024-01-02', 150), ('2024-01-03', 300), ('2024-01-03', 75), ('2024-01-03', 120), ('2024-01-04', 250), ('2024-01-05', 180), ('2024-01-05', 90), ('2024-01-05', 210);","Напишите запрос, который извлекает из предложенной базы данных все дни (даты), в которые было совершено хотя бы два заказа, и указывает для каждого дня разницу в суммах между первым и вторым заказами, совершенными в этот день.",30,3,"with O as (select id, date, amount, abs(nth_value(amount, 1) over a - nth_value(amount, 2) over a) as two_first_orders_amount_diff from Orders window a as (partition by date order by id)) select distinct date, two_first_orders_amount_diff from O where two_first_orders_amount_diff is not null ","select distinct O1.date, abs(first_value(O1.amount) over (partition by O1.date order by O1.id) -first_value(O2.amount) over (partition by O2.date order by O2.id)) as two_first_orders_amount_diff          from  Orders O1 join Orders O2 on O1.date = O2.date and O1.id = O2.id - 1",
11.5. Оконные функции. Функции смещения.,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales ( month INT, quantity INT ); INSERT INTO Sales (month, quantity) VALUES (1, 180000), (2, 210000), (3, 195000), (4, 245000), (5, 200000), (6, 230000), (7, 295000), (8, 215000), (9, 250000), (10, 265000), (11, 220000), (12, 290000);","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за каждый месяц, а также указывает для каждого месяца количество проданных товаров за предыдущий и предпредыдущий месяцы.",5,1,"select month,        quantity,        lag(quantity, 1, 0) over () as prev_month_sales,        lag(quantity, 2, 0) over () as second_prev_month_sales from Sales",,
11.5. Оконные функции. Функции смещения.,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales ( month INT, quantity INT ); INSERT INTO Sales (month, quantity) VALUES (1, 180000), (2, 210000), (3, 195000), (4, 245000), (5, 200000), (6, 230000), (7, 295000), (8, 215000), (9, 250000), (10, 265000), (11, 220000), (12, 290000);","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за каждый месяц, а также указывает для каждого месяца количество проданных товаров в соответствующем месяце предыдущего квартала: для первого месяца квартала соответствующим месяцем является первый месяц предыдущего квартала, для второго — второй, для третьего — третий.",5,1,"select month,        quantity,        lag(quantity, 3, 0) over () as prev_quarter_month_sales from Sales",,
11.5. Оконные функции. Функции смещения.,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales ( month INT, quantity INT ); INSERT INTO Sales (month, quantity) VALUES (1, 180000), (2, 210000), (3, 195000), (4, 245000), (5, 200000), (6, 230000), (7, 295000), (8, 215000), (9, 250000), (10, 265000), (11, 220000), (12, 290000);","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за те месяцы, в которые товаров было продано больше чем в предыдущем месяце.",10,2,"with S as (select month,        quantity,        lag(quantity, 1, 0) over () as q from Sales) select month,        quantity from S where q<quantity",,
11.5. Оконные функции. Функции смещения.,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales ( month INT, quantity INT ); INSERT INTO Sales (month, quantity) VALUES (1, 180000), (2, 210000), (3, 195000), (4, 245000), (5, 200000), (6, 230000), (7, 295000), (8, 215000), (9, 250000), (10, 265000), (11, 220000), (12, 290000);","Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах за все месяцы, кроме последнего, а также указывает для каждого месяца разницу в количестве проданных товаров между текущим месяцем и следующим.",10,2,"select month,        quantity,        abs(quantity - lead(quantity, 1) over ()) as next_month_sales_diff from Sales limit 11","WITH Difference AS (     SELECT Sales.*,            ABS(quantity - LEAD(quantity) OVER (ORDER BY month)) AS next_month_sales_diff     FROM Sales ) SELECT * FROM Difference WHERE next_month_sales_diff IS NOT NULL;",
11.5. Оконные функции. Функции смещения.,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales ( month INT, quantity INT ); INSERT INTO Sales (month, quantity) VALUES (1, 180000), (2, 210000), (3, 195000), (4, 245000), (5, 200000), (6, 230000), (7, 295000), (8, 215000), (9, 250000), (10, 265000), (11, 220000), (12, 290000);","Интернет-магазин Amazon в рамках каждого квартала определяет среднее изменение количества проданных товаров, складывая разницу между продажами первого и второго месяцев квартала с разницей между продажами второго и третьего месяцев квартала и деля ее пополам. Например, среднее изменение количества проданных товаров в первом квартале вычисляется следующим образом:∣180000−210000∣+∣210000−195000∣2=30000+150002=225002∣180000−210000∣+∣210000−195000∣​=230000+15000​=22500     Напишите запрос, который разбивает все месяцы по кварталам, определяет среднее изменение количества проданных товаров в каждом квартале и отображает полученный результат в виде таблицы из двух полей:",40,4,"WITH QuarterSales AS (     SELECT Sales.*,            NTILE(4) OVER (ORDER BY month) AS quarter     FROM Sales ), Difference AS (     SELECT quarter,            ABS(LAG(quantity) OVER (PARTITION BY quarter ORDER BY month) - quantity) AS difference     FROM QuarterSales ) SELECT quarter,        AVG(difference) AS sales_avg_diff FROM Difference GROUP BY quarter;","select distinct (month+2) div 3 as quarter,        (abs(first_value(quantity) over win - nth_value(quantity,2) over win) + abs(nth_value(quantity,2) over win - last_value(quantity) over win))/2 as sales_avg_diff from Sales window win as (partition by (month+2) div 3 order by month rows between unbounded preceding and unbounded following)",
11.6. Задачи,"DROP TABLE IF EXISTS Rides; CREATE TABLE Rides (     passenger_id INT,     amount INT,     requested_on DATETIME );  INSERT INTO Rides (passenger_id, amount, requested_on) VALUES (1, 30, '2024-01-01 15:45:00'),        (2, 25, '2024-02-12 07:00:00'),        (3, 15, '2024-01-13 10:30:00'),        (1, 15, '2024-02-08 18:15:00'),        (1, 35, '2024-02-05 12:15:00'),        (4, 70, '2024-01-20 11:55:00'),        (4, 110, '2024-01-01 12:40:00'),        (4, 25, '2024-02-01 21:30:00'),        (3, 80, '2024-01-10 23:00:00'),        (1, 10, '2024-01-02 18:10:00');","Напишите запрос, который извлекает из предложенной базы данных всю информацию о третьей по счету поездке каждого пассажира.",15,2,"with C as (select passenger_id, amount, requested_on,       row_number() over (partition by passenger_id order by requested_on) as num from Rides) select passenger_id, amount, requested_on from C where num = 3","with cte as (select passenger_id, amount, requested_on,        nth_value(amount, 3) over (partition by passenger_id order by requested_on) as 3rd from Rides) select passenger_id, amount, requested_on  from cte where 3rd = amount",
11.6. Задачи,"DROP TABLE IF EXISTS Posts; CREATE TABLE Posts ( user_id INT, day DATE, quantity INT ); INSERT INTO Posts (user_id, day, quantity) VALUES (1, '2023-01-01', 5), (2, '2023-01-01', 8), (3, '2023-01-01', 3), (4, '2023-01-01', 12), (1, '2023-01-02', 6), (3, '2023-01-02', 9), (4, '2023-01-02', 4), (1, '2023-01-03', 7), (4, '2023-01-03', 10), (1, '2023-01-04', 2), (1, '2023-01-05', 1), (4, '2023-01-07', 11), (1, '2023-01-07', 8);","Напишите запрос, который извлекает из предложенной базы данных всю информацию о количестве постов, опубликованных каждым пользователем в каждый из дней, а также указывает для каждого дня среднее количество опубликованных пользователем постов, учитывая лишь текущий день и два предыдущих.",30,3,"select Posts.*,        avg(quantity) over (partition by user_id order by day range between interval 2 day preceding and current row) as three_day_moving_avg_quantity from Posts",,
11.6. Задачи,"DROP TABLE IF EXISTS BoxOffice; CREATE TABLE BoxOffice ( month INT, movie VARCHAR(40), amount INT ); INSERT INTO BoxOffice (month, movie, amount) VALUES (1, 'Scott Pilgrim Vs. The World', 1500), (2, 'Scott Pilgrim Vs. The World', 1400), (2, 'Logan', 1100), (3, 'Scott Pilgrim Vs. The World', 1700), (3, 'Logan', 1200), (4, 'Scott Pilgrim Vs. The World', 1600), (4, 'Spider-Man: Into The Spider-Verse', 2000), (4, 'La La Land', 1300), (5, 'Spider-Man: Into The Spider-Verse', 2100), (6, 'Spider-Man: Into The Spider-Verse', 1800);","Напишите запрос, который определяет кассовые сборы каждого фильма в первый месяц показа и отображает полученный результат в виде таблицы из двух полей:",10,2,"with B as (select BoxOffice.*,        row_number() over (partition by movie order by month) as r from BoxOffice) select movie, amount as first_month_box_office from B where r = 1","SELECT DISTINCT movie,        FIRST_VALUE(amount) OVER(            PARTITION BY movie             ORDER BY month        ) AS first_month_box_office FROM BoxOffice",
11.6. Задачи,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders ( id INT PRIMARY KEY AUTO_INCREMENT, customer_id INT, amount INT, purchased_on DATETIME ); INSERT INTO Orders (customer_id, amount, purchased_on) VALUES (2, 10, '2024-01-01 08:40:00'), (2, 90, '2024-01-01 10:10:00'), (1, 500, '2024-01-07 12:00:00'), (1, 100, '2024-01-07 18:45:00'), (1, 350, '2024-01-07 20:00:00'), (3, 110, '2024-02-05 09:00:00'), (3, 100, '2024-02-12 08:00:00'), (2, 900, '2024-02-12 10:00:00'), (3, 1600, '2024-02-12 12:10:00'), (3, 75, '2024-02-12 12:20:00');","Напишите запрос, который определяет, в какой день каждый из покупателей совершил свой последний заказ, вычисляет количество совершенных заказов в этот день и отображает полученный результат в виде таблицы из трех полей:",25,4,"with O as (select customer_id, amount, purchased_on,        date(last_value(purchased_on) over (partition by customer_id order by purchased_on rows between unbounded preceding and unbounded following)) as last_order_day from Orders) select customer_id, last_order_day, count(*) as orders_count from O where last_order_day = date(purchased_on) group by customer_id, last_order_day","WITH CTE AS (     SELECT customer_id, DATE(purchased_on) AS purchased_on,            LAST_VALUE(DATE(purchased_on)) OVER (PARTITION BY customer_id) AS last_order_day     FROM Orders ) SELECT customer_id, last_order_day, COUNT(*) AS orders_count FROM CTE WHERE purchased_on = last_order_day GROUP BY customer_id, last_order_day;",
11.6. Задачи,"DROP TABLE IF EXISTS Payments; CREATE TABLE Payments ( id INT PRIMARY KEY AUTO_INCREMENT, user_id INT, card_id INT, amount INT, completed_on DATETIME ); INSERT INTO Payments (user_id, card_id, amount, completed_on) VALUES (1, 1, 100, '2024-01-01 12:00:00'), (1, 1, 100, '2024-01-01 12:06:00'), (2, 2, 250, '2024-01-02 18:00:00'), (3, 1, 50, '2024-01-02 18:05:00'), (2, 2, 250, '2024-01-02 18:08:00'), (3, 1, 10, '2024-01-03 10:00:00'), (3, 1, 10, '2024-01-03 10:10:00'), (1, 2, 80, '2024-01-03 10:00:00'), (1, 2, 80, '2024-01-03 10:10:01'), (4, 1, 200, '2024-01-03 13:00:00');","Иногда в результате различных сбоев банковские платежи случайно совершаются повторно, что приводит к двойному списанию денежных средств с банковской карты. Банк HSBC считает, что платеж по ошибке совершен повторно в том случае, если в течение 10 минут до него был совершен платеж от того же клиента, с той же карты и на ту же сумму. Например, платеж с идентификатором 2 считается совершенным повторно случайно, поскольку 6 минут назад был совершен ровно такой же платеж. Аналогичное справедливо для платежей с идентификаторами 5 и 7. Напишите запрос, который извлекает из предложенной базы данных идентификаторы платежей, по ошибке совершенных повторно.",60,6,"with P as (select Payments.*,        dense_rank() over (partition by user_id, card_id, amount order by completed_on) as t from Payments) select id as repeat_payment_id from P where timestampdiff(second, (select completed_on from P as P1                                            where P.t = P1.t+1 and P.user_id = P1.user_id and P.card_id = P1.card_id and P.amount = P1.amount), completed_on) <= 600 order by repeat_payment_id","WITH PrevPayments AS (     SELECT Payments.*,            LAG(completed_on) OVER samePayment AS prev_completed_on     FROM Payments     WINDOW samePayment AS (PARTITION BY user_id, card_id, amount                            ORDER BY completed_on) ) SELECT id AS repeat_payment_id FROM PrevPayments WHERE TIMEDIFF(completed_on, prev_completed_on) <= '00:10:00' ORDER BY repeat_payment_id;",
11.6. Задачи,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders ( id INT PRIMARY KEY AUTO_INCREMENT, category VARCHAR(50), product VARCHAR(50), amount INT ); INSERT INTO Orders (category, product, amount) VALUES ('Electronics', 'iPhone 15', 1000), ('Clothing', 'Jeans', 80), ('Electronics', 'iPhone 15', 1010), ('Electronics', 'iPad Air', 350), ('Clothing', 'Sweater', 55), ('Electronics', 'iPhone 15', 1050), ('Electronics', 'MacBook Pro 14', 1300), ('Clothing', 'Sweater', 60), ('Electronics', 'iPad Air', 300), ('Electronics', 'iPad Air', 300);","Напишите запрос, определяющий в каждой категории два товара, продажи которых принесли наибольшую суммарную прибыль, и отображающий полученный результат в виде таблицы из трех полей:",30,4,"with O as (select distinct category, product,                   sum(amount) over (partition by category, product) as total_amount                   from Orders                   order by total_amount desc, product), O2 as (select O.*,               row_number() over (partition by category) as num        from O) select category, product, total_amount from O2 where num in (1,2)","WITH PreResult AS (     SELECT category, product,             SUM(amount) AS total_amount,            ROW_NUMBER() OVER (PARTITION BY category ORDER BY SUM(amount) DESC, category) AS row_num     FROM Orders     GROUP BY category, product ) SELECT category, product, total_amount FROM PreResult WHERE row_num IN (1, 2);",
11.6. Задачи,"DROP TABLE IF EXISTS ServerUtilization; CREATE TABLE ServerUtilization ( server_id INT, session_status VARCHAR(5), status_time DATETIME ); INSERT INTO ServerUtilization (server_id, session_status, status_time) VALUES (1, 'start', '2024-01-01 08:00:00'), (2, 'start', '2024-01-01 08:00:00'), (3, 'start', '2024-01-01 08:00:00'), (3, 'stop', '2024-01-02 01:00:00'), (1, 'stop', '2024-01-05 07:00:00'), (2, 'stop', '2024-01-10 09:00:00'), (1, 'start', '2024-01-11 10:00:00'), (3, 'start', '2024-01-11 10:00:00'), (3, 'stop', '2024-01-11 17:00:00'), (1, 'stop', '2024-01-15 10:00:00');","Каждый сервер компании может включаться и выключаться несколько раз. Если в результате всех включений и выключений суммарная наработка сервера находится в диапазоне от 24 часов (включительно) до 48 часов (не включительно), то компания Google считает, что сервер проработал 1 день, если в диапазоне от 48 часов (включительно) до 72 часов (не включительно) — 2 дня, и так далее. Напишите запрос, определяющий количество дней, которое проработал каждый сервер, и отображающий полученный результат в виде таблицы из двух полей: ",60,7,"WITH WorkTime AS (   SELECT ServerUtilization.*,          TIMESTAMPDIFF(SECOND,                        status_time,                        LEAD(status_time) OVER (PARTITION BY server_id                                                ORDER BY status_time)) AS uptime_hours   FROM ServerUtilization )  SELECT server_id, SUM(uptime_hours) DIV (60 * 60 * 24) AS total_uptime_days FROM WorkTime WHERE session_status = 'start' GROUP BY server_id;","with S as (select ServerUtilization.*,                   row_number() over (partition by server_id order by status_time) as num from ServerUtilization),       SU as (select S1.server_id,                    timestampdiff(second, S1.status_time, S2.status_time) as hours             from S as S1 join S as S2 on             S1.num = S2.num - 1 and S1.server_id = S2.server_id             where S1.session_status = 'start') select distinct server_id,         sum(hours) over (partition by server_id) div (24*60*60) as total_uptime_days from SU",
11.6. Задачи,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders ( id INT PRIMARY KEY AUTO_INCREMENT, product VARCHAR(50), amount INT, purchased_on DATE ); INSERT INTO Orders (product, amount, purchased_on) VALUES ('iPad Air', 350, '2024-01-01'), ('MacBook Pro 14', 2100, '2024-01-01'), ('iPhone 15', 1000, '2024-01-12'), ('MacBook Pro 14', 2050, '2024-01-20'), ('iPad Air', 300, '2024-02-10'), ('iPad Air', 400, '2024-02-22'), ('MacBook Pro 14', 2000, '2024-04-20'), ('MacBook Pro 14', 1900, '2024-04-20'), ('iPhone 15', 1000, '2024-05-28'), ('iPhone 15', 900, '2024-06-25');","Напишите запрос, который группирует одинаковые товары в зависимости от месяца, в который они были проданы, вычисляет в рамках каждой группы суммарную прибыль, которую принесли продажи товара, и отображает полученный результат в виде таблицы из четырех полей:",40,5,"with O as ( select month(purchased_on) as m,        monthname(purchased_on) as month,        product,        sum(amount) as total_amount from Orders group by month(purchased_on),           monthname(purchased_on),           product) select month,         product,         total_amount,         lag(total_amount) over (partition by product order by m range between 2 preceding and current row) as nearest_prev_month_total_amount from O","SELECT MONTHNAME(purchased_on) AS month,        product,        SUM(amount) AS total_amount,        LAG(SUM(amount)) OVER (PARTITION BY product                               ORDER BY MONTH(purchased_on)) AS nearest_prev_month_total_amount FROM Orders GROUP BY month, product, MONTH(purchased_on);",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Emails; CREATE TABLE Emails ( id INT PRIMARY KEY AUTO_INCREMENT, email VARCHAR(100) ); TRUNCATE Emails; INSERT INTO Emails (email) VALUES ('ugibson@hotmail.com'), ('dbuchanan@yahoo.com'), ('mayerrachel@hotmail.com'), ('loganlee@gmail.com'), ('ugibson@hotmail.com'), ('loganlee@gmail.com'), ('alexandracardenas@gmail.com'), ('johnfigueroa@yahoo.com'), ('rachel40@hotmail.com'), ('loganlee@gmail.com'), ('ugibson@hotmail.com'), ('alexandracardenas@gmail.com'), ('hjordan@yahoo.com'), ('katherine22@yahoo.com'), ('ugibson@hotmail.com'), ('loganlee@gmail.com'), ('katherine22@yahoo.com'), ('alexandracardenas@gmail.com'), ('rodriguezsteven@yahoo.com'), ('jmorgan@yahoo.com');","Напишите запрос, который извлекает из предложенной базы данных уникальные адреса электронных почт студентов.",1,1,select distinct email from Emails,,
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Products; CREATE TABLE Products (     id       INT PRIMARY KEY AUTO_INCREMENT,     name     VARCHAR(50),     category VARCHAR(40),     price    INT );  TRUNCATE Products; INSERT INTO Products (name, category, price) VALUES ('Apple iPhone 13 Pro', 'Electronics', 1099),        ('Samsung Galaxy S21', 'Electronics', 999),        ('Sony WH-1000XM4 Headphones', 'Electronics', 299),        ('Nike Air Zoom Pegasus 38', 'Footwear', 120),        ('Adidas Ultraboost 21', 'Footwear', 180),        ('Lenovo ThinkPad X1 Carbon', 'Electronics', 1499),        ('Dell XPS 13 Laptop', 'Electronics', 1199),        ('Canon EOS R6 Camera', 'Electronics', 2499),        ('Bose QuietComfort 35 II', 'Electronics', 299),        ('Samsung 65-inch QLED TV', 'Electronics', 1499),        ('LG OLED55CXPUA TV', 'Electronics', 1799),        ('Apple AirPods Pro', 'Electronics', 249),        ('Fitbit Versa 3', 'Electronics', 199),        ('PlayStation 5', 'Electronics', 499),        ('Xbox Series X', 'Electronics', 499),        ('Amazon Echo Dot (4th Gen)', 'Electronics', 49),        ('GoPro HERO9 Black', 'Electronics', 349),        ('Samsung Galaxy Tab S7', 'Electronics', 649),        ('Dyson V11 Animal Vacuum', 'Appliances', 599),        ('Instant Pot Duo 7-in-1', 'Appliances', 89); ","Напишите запрос, извлекающий из предложенной базы данных названия товаров, которые принадлежат категории Electronics и цена которых не превышает 999 долларов.",5,1,select name from Products where category = 'Electronics' and price < 1000,,
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Patients; CREATE TABLE Patients (     id         INT PRIMARY KEY AUTO_INCREMENT,     name       VARCHAR(50),     surname    VARCHAR(50),     conditions VARCHAR(50) DEFAULT NULL );  INSERT INTO Patients (name, surname, conditions) VALUES      ('George', 'Clooney', 'YFEV COUGH'),     ('Paul', 'Krugman', NULL),     ('Wright', 'BrothersOrville', 'DIAB100 MYOP'),     ('Ernest', 'Hemingway', 'ACNE DIAB100'),     ('Roman', 'Abramovich', 'DIAB201'),     ('Tom', 'Cruise', NULL),     ('Lech', 'Walesa', 'DIAB100 MYOP'),     ('Tim', 'Berners', 'ACNE DIAB100'),     ('Aung', 'San', NULL),     ('Lance', 'Armstrong', 'YFEV COUGH'),     ('Shakira', 'Curie', 'DIAB100 MYOP'),     ('Jon', 'Stewart', 'DIAB201'),     ('Julie', 'Andrews', 'ACNE DIAB100'),     ('Florence', 'Nightingale', 'YFEV COUGH'),     ('Marie', 'Curie', 'DIAB201'),     ('Stephen', 'Hawking', NULL),     ('Jimmy', 'Wales', NULL),     ('Rupert', 'Murdoch', NULL),     ('Al', 'Gore', 'DIAB100 MYOP'),     ('Sacha', 'Baron', 'YFEV COUGH');","Диагноз пациентов, болеющих диабетом первого типа, всегда содержит подстроку DIAB1.  Напишите запрос, извлекающий из предложенной базы данных информацию о пациентах (имя, фамилия, диагноз), которые болеют диабетом первого типа.",5,1,"select name, surname, conditions from Patients where conditions like ('%DIAB1%')",,
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Users; CREATE TABLE Users (     id           INT PRIMARY KEY AUTO_INCREMENT,     name         VARCHAR(50),     surname      VARCHAR(50),     referee_id   INT );  INSERT INTO Users (name, surname, referee_id) VALUES ('Lech', 'Walesa', NULL),        ('Julie', 'Andrews', NULL),        ('Florence', 'Nightingale', NULL),        ('Marie', 'Curie', 10),        ('Stephen', 'Hawking', 3),        ('Tim', 'Berners', 2),        ('Aung', 'San', 5),        ('Lance', 'Armstrong', NULL),        ('Shakira', 'Curie', 14),        ('Jon', 'Stewart', NULL),        ('Wright', 'BrothersOrville', 2),        ('Ernest', 'Hemingway', 20),        ('Roman', 'Abramovich', 1),        ('Tom', 'Cruise', 3),        ('Rupert', 'Murdoch', 2),        ('Al', 'Gore', NULL),        ('Sacha', 'Baron', 2),        ('George', 'Clooney', NULL),        ('Paul', 'Krugman', 2),        ('Jimmy', 'Wales', 2);","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии пользователей, которых пригласил не пользователь с идентификатором 2 или которые не были приглашены кем-либо.",5,2,"select name, surname from Users where referee_id != 2 or referee_id is null","SELECT name, surname FROM Users WHERE IFNULL(referee_id, 0) != 2",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Countries;  CREATE TABLE Countries (     id         INTEGER PRIMARY KEY AUTO_INCREMENT,     name       VARCHAR(50),     continent  VARCHAR(50),     area       INT,     population INT );  INSERT INTO Countries (name, continent, area, population) VALUES ('Russia', 'Europe', 2259755, 20217194),        ('Iceland', 'Europe', 2000000, 4899198),        ('India', 'Asia', 977388, 15006874),        ('Indonesia', 'Asia', 1978388, 29990280),        ('Iran', 'Asia', 154116, 5159120),        ('Iraq', 'Asia', 316347, 14528805),        ('Ireland', 'Europe', 848972, 35421289),        ('Israel', 'Asia', 1686278, 17751549),        ('Italy', 'Europe', 829713, 6163666),        ('Jamaica', 'Americas', 906750, 15000000),        ('Japan', 'Asia', 1927404, 6591379),        ('Jersey', 'Europe', 2117703, 35592399),        ('Jordan', 'Asia', 2066759, 28566620),        ('Kazakhstan', 'Asia', 2045815, 12355207),        ('Kenya', 'Africa', 1405874, 20828713),        ('Kiribati', 'Oceania', 1772875, 21869997),        ('Kosovo', 'Europe', 280612, 9969562),        ('Kuwait', 'Asia', 140155, 29354166),        ('Kyrgyzstan', 'Asia', 291254, 33522371),        ('Laos', 'Asia', 1489182, 11008866); ","Напишите запрос, извлекающий из предложенной базы данных информацию о странах (название, континент), площадь которых больше 2000000 квадратных километров или население которых больше 15000000 человек.",5,1,"select name, continent from Countries where area > 2000000 or population > 15000000",,
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Views; CREATE TABLE Views (     article_id INT,     author_id  INT,     viewer_id  INT,     view_date  DATE );  TRUNCATE Views; INSERT INTO Views (article_id, author_id, viewer_id, view_date) VALUES (1, 5, 1, '2023-08-01'),        (1, 5, 6, '2023-08-02'),        (1, 5, 3, '2023-08-03'),        (1, 5, 2, '2023-08-04'),        (2, 3, 1, '2023-08-04'),        (2, 3, 6, '2023-08-04'),        (2, 3, 7, '2023-08-07'),        (3, 7, 8, '2023-08-08'),        (4, 7, 1, '2023-08-09'),        (5, 7, 10, '2023-08-10'),        (6, 7, 2, '2023-08-10'),        (7, 5, 4, '2023-08-10'),        (7, 5, 2, '2023-08-10'),        (8, 1, 10, '2023-08-14'),        (8, 1, 3, '2023-08-15'),        (8, 1, 1, '2023-08-16'),        (9, 3, 3, '2023-08-17'),        (9, 3, 10, '2023-08-18'),        (10, 5, 2, '2023-08-19'),        (10, 5, 4, '2023-08-20'),        (10, 5, 10, '2023-08-21'),        (10, 5, 5, '2023-08-22');","Напишите запрос, извлекающий из предложенной базы данных уникальные идентификаторы пользователей, которые просмотрели хотя бы одну из своих статей.",5,1,select distinct author_id from Views where author_id = viewer_id,,
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Tweets; CREATE TABLE Tweets (     id      INT PRIMARY KEY AUTO_INCREMENT,     content VARCHAR(100) );  TRUNCATE Tweets; INSERT INTO Tweets (content) VALUES ('Vote for Biden'),        ('Let us make America great again!'),        ('Happy New Year to all those AWS instances of ours!'),        ('K. Will ligo then off to somewhere. Hahaha aws'),        ('We are hiring: Technical Lead'),        ('That’s one small step for man. One giant leap for mankind'),        ('It is not the strongest species that survive, nor the most intelligent'),        ('I have a dream!'),        ('Let`s dance!'),        ('Time is a waste of money'),        ('Always forgive your enemies; nothing annoys them so much'),        ('To live is the rarest thing in the world. Most people exist, that is all'),        ('I am not young enough to know everything'),        ('A little sincerity is a dangerous thing, and a great deal of it is absolutely fatal'),        ('The work is not a wolf, only a wolf, a wolf!'),        ('Coffee fuels my day.'),        ('The memory warms you up inside, but it also breaks your soul apart'),        ('When you start thinking a lot about your past, it becomes your present and you can’t'),        ('Memories take us back, dreams take us forward'),        ('Be careful with your thoughts. — they are the beginning of deeds'),        ('Be careful what you wish for Parker'); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы твитов, содержание которых состоит из 20 и менее символов.",5,1,select id from Tweets where char_length(content) <=20,"SELECT sale_date,        ABS(SUM(IF(fruit = 'orange', sold_num, -sold_num))) AS diff FROM Sales GROUP BY sale_date",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     sale_date DATE,     fruit     VARCHAR(10),     sold_num  INT );  TRUNCATE Sales; INSERT INTO Sales VALUES ('2023-01-01', 'apple', 12),        ('2023-01-01', 'orange', 10),        ('2023-01-02', 'apple', 15),        ('2023-01-02', 'orange', 18),        ('2023-01-03', 'apple', 20),        ('2023-01-03', 'orange', 5),        ('2023-01-04', 'apple', 14),        ('2023-01-04', 'orange', 16),        ('2023-01-05', 'apple', 18),        ('2023-01-05', 'orange', 20),        ('2023-01-06', 'apple', 10),        ('2023-01-06', 'orange', 12),        ('2023-01-07', 'apple', 16),        ('2023-01-07', 'orange', 8),        ('2023-01-08', 'apple', 12),        ('2023-01-08', 'orange', 10),        ('2023-01-09', 'apple', 14),        ('2023-01-09', 'orange', 6),        ('2023-01-10', 'apple', 20),        ('2023-01-10', 'orange', 22); "," Напишите запрос, который извлекает из предложенной базы данных все даты продаж, а также для каждой даты определяет разницу между количеством проданных апельсинов и количеством проданных яблок.  Поле с разницей между количествами проданных фруктов должно иметь псевдоним diff.",100,7," select distinct S.sale_date, abs(ifnull(So.sold_num, 0) - ifnull(Sa.sold_num, 0)) as diff from Sales S left join (select sale_date, sold_num from Sales                     where fruit = 'orange') as So on S.sale_date = So.sale_date left join (select sale_date, sold_num from Sales                     where fruit = 'apple') as Sa on S.sale_date = Sa.sale_date  ",,"select   sale_date,  if(count(fruit) > 1, max(sold_num) - min(sold_num), max(sold_num)) as diff from  Sales group by sale_date"
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50),     salary  INT );  INSERT INTO Employees (name, surname, salary) VALUES ('Lech', 'Walesa', 8923),        ('Julie', 'Andrews', 4580),        ('Florence', 'Nightingale', 7546),        ('Marie', 'Curie', 4839),        ('Stephen', 'Hawking', 8195),        ('Tim', 'Berners', 7037),        ('Aung', 'San', 3162),        ('Lance', 'Armstrong', 9886),        ('Shakira', 'Curie', 8056),        ('Jon', 'Stewart', 6718),        ('Wright', 'BrothersOrville', 7253),        ('Ernest', 'Hemingway', 7811),        ('Roman', 'Abramovich', 8825),        ('Tom', 'Cruise', 7381),        ('Rupert', 'Murdoch', 3947),        ('Al', 'Gore', 3059),        ('Sacha', 'Baron', 3331),        ('George', 'Clooney', 3373),        ('Paul', 'Krugman', 7741),        ('Jimmy', 'Wales', 3153);","Премия каждого сотрудника в компании Microsoft составляет 100% от его зарплаты, если идентификатор сотрудника является четным числом и если имя сотрудника начинается на букву A. В противном случае премия сотрудника равна 50% от его зарплаты.  Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех сотрудников компании, а также определяет премию каждого сотрудника.",10,3,"SELECT name, surname,        IF(id % 2 = 0 AND name LIKE 'A%', salary , salary * 0.5) AS bonus FROM Employees","select name, surname,        case        when id mod 2 = 0 and name like ('A%') then  salary*1        else salary * 0.5        end as bonus from Employees",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Films; CREATE TABLE Films (     id          INT PRIMARY KEY,     title       VARCHAR(50),     description VARCHAR(100),     rating      DECIMAL(3, 1) );  TRUNCATE Films; INSERT INTO Films (id, title, description, rating) VALUES (6, 'The Matrix', 'boring', 8.7),        (7, 'Inception', 'A mind-bending heist movie', 8.8),        (8, 'Pulp Fiction', 'A crime masterpiece', 9.0),        (9, 'The Shawshank', 'A tale of hope and friendship', 9.3),        (10, 'The Godfather', 'boring', 9.2),        (11, 'Interstellar', 'A journey through space and time', 8.6),        (12, 'The Dark Knight', 'The iconic Batman sequel', 9.0),        (13, 'Fight Club', 'boring', 8.8),        (14, 'Avatar', 'boring', 7.8),        (15, 'Gladiator', 'A Roman general seeks revenge', 8.5),        (16, 'Forrest Gump', 'boring', 8.8),        (17, 'The Silence', 'boring', 8.6),        (18, 'The Green Mile', 'boring', 8.6),        (19, 'The Lord of the Rings', 'Epic fantasy adventure', 8.9),        (20, 'The Great Gatsby', 'A tale of excess and obsession', 7.2),        (21, 'Casablanca', 'Classic wartime romance', 8.5),        (22, 'Eternal Sunshine', 'boring', 8.3),        (23, 'Shutter Island', 'A mystery thriller', 8.1),        (24, 'The Grand Budapest Hotel', 'boring', 8.1),        (25, 'Inglourious Basterds', 'World War II', 8.3);","Напишите запрос, извлекающий из предложенной базы данных названия фильмов, которые имеют нечетный идентификатор и краткое описание которых отлично от boring.",5,2,select title from Films where id mod 2 = 1 and description not like ('boring') order by id desc,,
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Students; CREATE TABLE Students (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Students (name, surname) values ('Rupert', 'murdoch'),        ('Al', 'Gore'),        ('saCHa', 'BarON'),        ('GEORGE', 'clooney'),        ('paUl', 'KrugGan'),        ('wright', 'brothersOrville'),        ('Ernest', 'Hemingway'),        ('roman', 'Abramovich'),        ('TOM', 'cruise'),        ('LecH', 'WAlESA'),        ('TIM', 'BernERS'),        ('aung', 'san'),        ('lance', 'Armstrong'),        ('ShaKIra', 'cuRie'),        ('JoN', 'SteWArt'),        ('juLIE', 'Andrews'),        ('floRENce', 'NigHTIngale'),        ('Marie', 'curie'),        ('Stephen', 'Hawking'),        ('JiMMy', 'WalESA');","Напишите запрос, извлекающий из предложенной базы данных всю информацию о каждом студенте. При этом имена и фамилии студентов в результирующей таблице должны быть отформатированы так, чтобы первая буква была заглавная, а остальные — строчные.",10,2,"select id,        concat(upper(left(name, 1)), lower(substring(name, 2))) as name,        concat(upper(left(surname, 1)), lower(substring(surname, 2))) as surname         from Students","SELECT id      , CONCAT(UPPER(SUBSTRING(name, 1, 1)),                LOWER(SUBSTRING(name, 2, CHAR_LENGTH(name) - 1))) AS name      , CONCAT(UPPER(SUBSTRING(surname, 1, 1)),                LOWER(SUBSTRING(surname, 2, CHAR_LENGTH(surname) - 1))) AS surname   FROM Students  ORDER BY id;",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Triangles; CREATE TABLE Triangles (     x INT,     y INT,     z INT );  INSERT INTO Triangles (x, y, z) VALUES (31, 12, 68),        (3, 8, 31),        (32, 65, 31),        (57, 92, 90),        (72, 89, 28),        (72, 77, 69),        (0, 0, 0),        (15, 66, 84),        (23, 62, 40),        (14, 50, 7),        (84, 97, 33),        (73, 67, 14),        (67, 96, 75),        (90, 23, 44),        (52, 28, 84),        (33, 14, 71),        (14, 54, 29),        (80, 15, 35),        (28, 34, 85),        (27, 33, 86);","Напишите запрос, который извлекает из предложенной базы данных стороны всех потенциальных треугольников и для каждой тройки сторон указывает, существует ли треугольник с такими сторонами: yes, если существует, или no в противном случае.",10,2,"select x, y, z,        case        when x + y > z and y + z > x and z + x > y then 'yes'        else 'no'        end as triangle from Triangles","select x, y, z,        if(x + y > z and y + z > x and z + x > y, 'yes', 'no') as triangle from Triangles",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE IF NOT EXISTS Customers (     id           INT PRIMARY KEY AUTO_INCREMENT,     name         VARCHAR(50),     surname      VARCHAR(50) );  INSERT INTO Customers (name, surname) VALUES ('Lech', 'Walesa'),        ('Julie', 'Andrews'),        ('Florence', 'Nightingale'),        ('Marie', 'Curie'),        ('Stephen', 'Hawking'),        ('Tim', 'Berners'),        ('Aung', 'San'),        ('Lance', 'Armstrong'),        ('Shakira', 'Curie'),        ('Jon', 'Stewart'),        ('Wright', 'BrothersOrville'),        ('Ernest', 'Hemingway'),        ('Roman', 'Abramovich'),        ('Tom', 'Cruise'),        ('Rupert', 'Murdoch'),        ('Al', 'Gore'),        ('Sacha', 'Baron'),        ('George', 'Clooney'),        ('Paul', 'Krugman'),        ('Jimmy', 'Wales');  -- Создание таблицы Orders CREATE TABLE IF NOT EXISTS Orders (     id           INT PRIMARY KEY AUTO_INCREMENT,     customer_id  INT,     FOREIGN KEY (customer_id)      REFERENCES Customers(id) );  TRUNCATE Orders; INSERT INTO Orders (customer_id) VALUES (16),        (16),        (7),        (15),        (16),        (1),        (3),        (16),        (17),        (18),        (14),        (18),        (7),        (20),        (19),        (17),        (19),        (14),        (10),        (5); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии пользователей, которые не совершили ни одного заказа.",15,3,"select name, surname from Customers C left join Orders O on O.customer_id = C.id where customer_id is null","select name, surname from Customers where id not in (select customer_id from Orders)",
12. Задачи. Выборка и фильтрация,"DROP TABLE IF EXISTS Prices;  CREATE TABLE Prices (     id         INT PRIMARY KEY AUTO_INCREMENT,     product    VARCHAR(100),     aliexpress DECIMAL(8, 2),     amazon     DECIMAL(8, 2),     ebay       DECIMAL(8, 2) );  INSERT INTO Prices (product, aliexpress, amazon, ebay) VALUES ('Sony PlayStation 4', 95.00, 100.00, 105.00),        ('LG 55-inch OLED TV', 70.00, NULL, 80.00),        ('Nike Air Max 270', 120.00, 115.50, 125.00),        ('Bose SoundSport Wireless Earbuds', 45.50, 50.00, NULL),        ('Dell Inspiron 15 Laptop', 60.00, NULL, 62.50),        ('Canon EOS Rebel T7 DSLR Camera', NULL, 75.00, 78.00),        ('Apple iPad Air', 88.50, 90.00, 92.00),        ('Samsung 75-inch QLED TV', 105.00, NULL, 110.50),        ('Fitbit Charge 4 Fitness Tracker', NULL, 40.00, 42.50),        ('Sony 65-inch 4K OLED TV', 35.00, NULL, 38.00),        ('Bose SoundLink Revolve+ Bluetooth Speak', 95.50, 100.50, 97.00),        ('Amazon Kindle Paperwhite', 80.00, NULL, 85.00),        ('Sony WH-1000XM3 Noise-Canceling Headpho', 112.00, 115.00, NULL),        ('Microsoft Surface Laptop 4', 58.50, NULL, 60.00),        ('Logitech G Pro X Gaming Headset', 72.00, 74.50, 75.50),        ('Apple Watch Series 6', NULL, 90.00, 92.50),        ('Sony Xperia 1 III Smartphone', 102.00, NULL, 105.00),        ('Xbox One X', 38.50, 40.00, 42.00),        ('Samsung Galaxy Watch 4', 28.00, NULL, 30.50),        ('DJI Mavic Air 2 Drone', 67.00, 69.50, NULL); ","Напишите запрос, определяющий цену каждого товара в каждом магазине, в котором он продается. Запись с информацией о цене товара должна включать название товара, название магазина и цену товара в этом магазине.",15,3,"select product, 'aliexpress' as store, aliexpress as price from Prices where aliexpress is not null union  select product, 'amazon' as store, amazon as price from Prices where amazon is not null union  select product, 'ebay' as store, ebay as price from Prices where ebay is not null","SELECT DISTINCT P1.product,         IF(P1.aliexpress IS NOT NULL AND ABS(P2.id - P1.id) = 0,           'aliexpress',            IF(P1.amazon IS NOT NULL AND ABS(P2.id - P1.id) = 1,               'amazon',               'ebay')) AS store,        IF(P1.aliexpress IS NOT NULL AND ABS(P2.id - P1.id) = 0,           P1.aliexpress,            IF(P1.amazon IS NOT NULL AND ABS(P2.id - P1.id) = 1,               P1.amazon,               P1.ebay)) AS price                                FROM Prices AS P1 INNER JOIN Prices AS P2 ON ABS(P2.id - P1.id) BETWEEN 0 AND 2 GROUP BY ABS(P2.id - P1.id), P1.product, store, price HAVING price IS NOT NULL ORDER BY store;",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Salary; DROP TABLE IF EXISTS Employees;  -- Создание таблицы Employees CREATE TABLE Employees (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Employees (name, surname) VALUES ('Lech', 'Walesa'),        ('Julie', 'Andrews'),        ('Florence', 'Nightingale'),        ('Marie', 'Curie'),        ('Stephen', 'Hawking'),        ('Tim', 'Berners'),        ('Aung', 'San'),        ('Lance', 'Armstrong'),        ('Shakira', 'Curie'),        ('Jon', 'Stewart'),        ('Wright', 'BrothersOrville'),        ('Ernest', 'Hemingway'),        ('Roman', 'Abramovich'),        ('Tom', 'Cruise'),        ('Rupert', 'Murdoch'),        ('Al', 'Gore'),        ('Sacha', 'Baron'),        ('George', 'Clooney'),        ('Paul', 'Krugman'),        ('Jimmy', 'Wales');  -- Создание таблицы Salary CREATE TABLE Salary (     employee_id INT,     salary      INT,     FOREIGN KEY (employee_id) REFERENCES Employees (id) );  INSERT INTO Salary (employee_id, salary) VALUES (3, 1500),        (1, 1800),        (8, 3200),        (2, 1100),        (5, 2400),        (14, 3800),        (11, 1200),        (20, 5000),        (6, 3000),        (9, 1900),        (17, 5400);","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех сотрудниках компании: имя, фамилия, зарплата. Если зарплата сотрудника неизвестна, она считается равной NULL.",5,2,"select name, surname, salary from Employees E left join Salary S on id = employee_id",,
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Visits;  -- Создание таблицы Visits CREATE TABLE Visits (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT );  INSERT INTO Visits (id, customer_id) VALUES (1, 23),        (2, 9),        (4, 30),        (5, 54),        (6, 96),        (7, 54),        (8, 54),        (9, 23),        (10, 9),        (11, 30),        (12, 54),        (13, 96),        (14, 54),        (15, 54),        (16, 23),        (17, 9),        (18, 30),        (19, 54),        (20, 54);  -- Создание таблицы Sales CREATE TABLE Sales (     id       INT PRIMARY KEY,     visit_id INT,     amount   INT,     FOREIGN KEY (visit_id) REFERENCES Visits (id) );  TRUNCATE Sales; INSERT INTO Sales (id, visit_id, amount) VALUES (3, 5, 300),        (9, 5, 200),        (13, 2, 970),        (21, 5, 150),        (23, 7, 350),        (24, 8, 200),        (25, 9, 310),        (28, 12, 650),        (30, 14, 590),        (31, 15, 390),        (32, 16, 270),        (33, 17, 150),        (34, 18, 420),        (35, 19, 330); ","Напишите запрос, который извлекает из предложенной базы данных идентификаторы пользователей, посетивших сайт магазина без единой покупки, а также для каждого пользователя указывает количество таких посещений.",10,2,"select customer_id, count(*) as count_no_trans from Visits V left join Sales S on V.id = S.visit_id where amount is null group by customer_id",,
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Weather; CREATE TABLE Weather (     record_date DATE,     temperature INT );  TRUNCATE Weather; INSERT INTO Weather (record_date, temperature) VALUES ('2023-08-31', 14),        ('2023-08-16', 10),        ('2023-08-17', 22),        ('2023-09-04', 19),        ('2023-08-21', 28),        ('2023-09-08', 13),        ('2023-08-20', 26),        ('2023-08-30', 16),        ('2023-08-23', 20),        ('2023-08-26', 13),        ('2023-09-10', 19),        ('2023-09-07', 18),        ('2023-08-12', 11),        ('2023-09-05', 15),        ('2023-08-13', 16),        ('2023-08-19', 27),        ('2023-09-03', 15),        ('2023-09-09', 30),        ('2023-08-18', 17),        ('2023-09-06', 23),        ('2023-08-25', 26),        ('2023-08-29', 29),        ('2023-08-14', 17),        ('2023-08-24', 21),        ('2023-09-02', 10),        ('2023-08-15', 15),        ('2023-08-22', 25),        ('2023-09-01', 17),        ('2023-08-28', 29),        ('2023-08-27', 26);"," Напишите запрос, извлекающий из предложенной базы данных даты, в которые ожидаемая температура превышает ожидаемую температуру в предыдущий день.",15,3,select W2.record_date from Weather W1 join Weather W2       on W1.temperature < W2.temperature      and W1.record_date = W2.record_date - interval 1 day ,"WITH Temperatures AS (   SELECT      *,      FIRST_VALUE(temperature) OVER (       ORDER BY record_date        RANGE BETWEEN          INTERVAL 1 DAY PRECEDING AND         INTERVAL 1 DAY PRECEDING     ) AS previous_temperature FROM Weather ) SELECT record_date FROM Temperatures WHERE temperature > previous_temperature;",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Salary; DROP TABLE IF EXISTS Employees;  -- Создание таблицы Employees CREATE TABLE Employees (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Employees (name, surname) VALUES ('Lech', 'Walesa'),        ('Julie', 'Andrews'),        ('Florence', 'Nightingale'),        ('Marie', 'Curie'),        ('Stephen', 'Hawking'),        ('Tim', 'Berners'),        ('Aung', 'San'),        ('Lance', 'Armstrong'),        ('Shakira', 'Curie'),        ('Jon', 'Stewart'),        ('Wright', 'BrothersOrville'),        ('Ernest', 'Hemingway'),        ('Roman', 'Abramovich'),        ('Tom', 'Cruise'),        ('Rupert', 'Murdoch'),        ('Al', 'Gore'),        ('Sacha', 'Baron'),        ('George', 'Clooney'),        ('Paul', 'Krugman'),        ('Jimmy', 'Wales');  -- Создание таблицы Salary CREATE TABLE Salary (     employee_id INT,     salary      INT,     FOREIGN KEY (employee_id) REFERENCES Employees (id) );  INSERT INTO Salary (employee_id, salary) VALUES (3, 1500),        (1, 1800),        (8, 3200),        (2, 1100),        (5, 2400),        (14, 3800),        (11, 1200),        (20, 5000),        (6, 2000),        (9, 1900),        (17, 5400);","Напишите запрос, извлекающий из предложенной базы данных информацию о сотрудниках организации (имя, фамилия, зарлата), зарплата которых меньше 2000 долларов. Если зарплата сотрудника неизвестна, она считается равной NULL и меньше 2000.",10,2,"select name, surname, salary from Employees  left join Salary  on id = employee_id where salary < 2000 or salary is null",,
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS TVProgram; DROP TABLE IF EXISTS Content;  -- Создание таблицы Content CREATE TABLE Content (     id           INT PRIMARY KEY AUTO_INCREMENT,     title        VARCHAR(50),     kids_content VARCHAR(20),     content_type VARCHAR(20) );  INSERT INTO Content (title, kids_content, content_type) VALUES ('Hells Kitchen', 'no', 'tv-show'),        ('The last Hero', 'no', 'tv-show'),        ('Brave', 'yes', 'movie'),        ('Toy Story 2', 'yes', 'movie'),        ('News', 'no', 'news'),        ('The Simpsons', 'yes', 'series'),        ('Irish', 'no', 'movie'),        ('The Incredibles', 'yes', 'movie'),        ('Buzz Lightyear', 'yes', 'movie');  -- Создание таблицы TVProgram CREATE TABLE TVProgram (     program_date DATETIME,     content_id   INT,     channel      VARCHAR(40),     FOREIGN KEY (content_id) REFERENCES Content (id) );  TRUNCATE TVProgram; INSERT INTO TVProgram VALUES ('2023-08-01 08:00', 6, 'NTV'),        ('2022-09-23 23:00', 2, 'Disney'),        ('2023-09-18 12:00', 1, 'NTV'),        ('2023-09-03 16:00', 2, 'Disney'),        ('2023-08-01 00:00', 9, 'Disney'),        ('2023-08-17 19:00', 7, 'NTV'),        ('2022-10-27 08:00', 5, 'NTV'),        ('2022-08-14 00:00', 4, 'Disney'),        ('2023-10-04 13:00', 6, 'Disney'),        ('2023-09-19 10:00', 2, 'NTV'),        ('2023-08-30 03:00', 6, 'NTV'),        ('2023-12-13 04:00', 1, 'Disney'),        ('2023-09-01 00:00', 8, 'Disney'),        ('2023-10-26 19:00', 6, 'NTV'),        ('2022-10-02 14:00', 2, 'Disney'),        ('2023-08-31 16:00', 3, 'NTV'),        ('2022-10-21 20:00', 2, 'Disney'),        ('2023-09-28 13:00', 1, 'NTV'),        ('2022-08-17 08:00', 4, 'NTV'),        ('2023-08-04 09:00', 5, 'Disney'),        ('2022-09-26 07:00', 4, 'NTV'),        ('2023-08-17 01:00', 7, 'Disney');","Напишите запрос, который извлекает из предложенной базы данных названия фильмов для детей, транслируемых в августе 2023 года.",15,3,select title from TVProgram left join Content  on TVProgram.content_id = Content.id where kids_content = 'yes'  and year(program_date) = 2023  and content_type = 'movie' and month(program_date) = 8,"SELECT title FROM TVProgram JOIN Content ON Content.id = content_id WHERE (YEAR(program_date), MONTH(program_date), kids_content, content_type) = (2023, 8, 'yes', 'movie');",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Addresses; DROP TABLE IF EXISTS Persons;  -- Создание таблицы Persons CREATE TABLE Persons (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(20),     surname VARCHAR(20) );  INSERT INTO Persons (name, surname) VALUES ('Steven', 'Randall'),        ('Veronica', 'Lee'),        ('Mark', 'Smith'),        ('Monica', 'Clark'),        ('Michelle', 'Barnett'),        ('Jessica', 'Garcia'),        ('Raymond', 'Andrews'),        ('Patrick', 'Garcia'),        ('Nancy', 'Harris'),        ('Kristina', 'Mcneil'),        ('Norma', 'Hansen'),        ('Eduardo', 'Garcia'),        ('Jonathan', 'Kemp'),        ('James', 'Garcia'),        ('Sherry', 'Chase'),        ('Christopher', 'Davis'),        ('Earl', 'Collins'),        ('Eric', 'Mclaughlin'),        ('Rhonda', 'Sanchez'),        ('Alexandria', 'Brown');  -- Создание таблицы Addresses CREATE TABLE Addresses (     person_id INT,     city      VARCHAR(20),     state     VARCHAR(20),     FOREIGN KEY (person_id) REFERENCES Persons (id) );  INSERT INTO Addresses (person_id, city, state) VALUES (1, 'New York city', 'New York'),        (3, 'London', 'Greater London'),        (4, 'North Ericland', 'Texas'),        (5, 'Tokyo', 'Tokyo'),        (8, 'Paris', 'Ile-de-France'),        (16, 'Sydney', 'New South Wales'),        (17, 'Rome', 'Lazio'),        (18, 'Moscow', 'Moscow region'),        (19, 'Dubai', 'Dubai Emirate'),        (20, 'Rio de Janeiro', 'Rio de Janeiro');","Напишите запрос, который извлекает из предложенной базы данных следующую информацию обо всех сотрудниках компании: имя, фамилия, город проживания, штат проживания.",5,1,"select name, surname, city, state from Persons left join Addresses on id = person_id",,
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Sellers; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id   INT PRIMARY KEY,     name VARCHAR(20) );  INSERT INTO Customers (id, name) VALUES (101, 'Steven'),        (102, 'Laura'),        (103, 'Jordan'),        (104, 'Thomas'),        (105, 'Anne'),        (106, 'Robin'),        (107, 'Sean'),        (108, 'Michael'),        (109, 'Raymond'),        (110, 'Chad');  -- Создание таблицы Sellers CREATE TABLE Sellers  (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Sellers (name) VALUES ('Deanna'),        ('Danielle'),        ('Jennifer'),        ('Matthew'),        ('Bonnie'),        ('John');  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     sale_date   DATE,     order_cost  DECIMAL,     customer_id INT,     seller_id   INT,     FOREIGN KEY (customer_id) REFERENCES Customers (id),     FOREIGN KEY (seller_id) REFERENCES Sellers (id) );  TRUNCATE Orders; INSERT INTO Orders (sale_date, order_cost, customer_id, seller_id) VALUES ('2023-01-15', 100, 101, 1),        ('2023-02-20', 75, 102, 2),        ('2023-03-10', 200, 103, 1),        ('2022-04-05', 50, 104, 3),        ('2023-05-12', 300, 105, 4),        ('2022-06-25', 120, 106, 5),        ('2023-07-08', 80, 107, 2),        ('2022-08-15', 150, 108, 3),        ('2022-09-20', 90, 109, 4),        ('2022-10-10', 70, 110, 1),        ('2022-11-30', 180, 101, 2),        ('2022-12-15', 40, 102, 3),        ('2023-01-25', 250, 103, 4),        ('2022-02-10', 110, 104, 5),        ('2023-03-08', 65, 105, 1),        ('2023-04-14', 95, 106, 2),        ('2022-05-02', 140, 107, 3),        ('2023-06-19', 75, 108, 4),        ('2022-07-27', 220, 109, 5),        ('2023-08-05', 180, 110, 1); ","Напишите запрос, извлекающий из предложенной базы данных имена продавцов, которые в 2023 году не продали ни одного товара.  Записи в результирующей таблице должны быть расположены в лексикографическом порядке имени продавца.",10,3,select name   from Sellers S   left join Orders O     on S.id = seller_id    and year(sale_date) = 2023  where seller_id is null  order by name,SELECT name FROM Sellers WHERE id NOT IN (SELECT seller_id                  FROM Orders                  WHERE YEAR(sale_date) = 2023) ORDER BY 1,
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Rides; DROP TABLE IF EXISTS Users;  -- Создание таблицы Users CREATE TABLE Users (     id       INT PRIMARY KEY AUTO_INCREMENT,     username VARCHAR(20) );  INSERT INTO Users (username) VALUES ('wwalker'),        ('william56'),        ('johnsonmichael'),        ('matthew86'),        ('phillipstimothy'),        ('mtrujillo'),        ('amanda32'),        ('sampsonkimberly'),        ('tammy53'),        ('cartervictoria');  -- Создание таблицы Rides CREATE TABLE Rides (     id       INT PRIMARY KEY AUTO_INCREMENT,     user_id  INT,     distance INT );  INSERT INTO Rides (user_id, distance) VALUES (4, 4544),        (1, 3330),        (5, 1149),        (9, 3480),        (4, 1830),        (8, 4239),        (1, 1773),        (8, 4063),        (2, 1361),        (4, 4503),        (5, 2420),        (2, 3006),        (1, 3724),        (4, 1554),        (8, 3917),        (6, 1377),        (5, 4593),        (1, 4511),        (1, 3640),        (6, 2556),        (6, 2285),        (1, 2977),        (8, 2007),        (9, 2629);","Напишите запрос, который извлекает из предложенной базы данных псевдонимы всех пользователей, а также определяет суммарное расстояние, пройденное каждым пользователем.  Поле с суммарным расстоянием, пройденным пользователем, должно иметь псевдоним travelled_distance.  Данные в результирующей таблице должны быть расположены в порядке убывания значения поля travelled_distance, при совпадении — порядке возрастания значения поля username.",15,3,"select username, ifnull(sum(distance), 0) as travelled_distance from Users U  left join Rides R on U.id = user_id group by username order by travelled_distance desc, username","SELECT U1.username, COALESCE(SUM(distance), 0) travelled_distance FROM Users U1 LEFT JOIN Rides R1 ON U1.id = R1.user_id GROUP BY U1.id ORDER BY 2 DESC, 1",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Sellers; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id   INT PRIMARY KEY,     name VARCHAR(20) );  INSERT INTO Customers (id, name) VALUES (101, 'Steven'),        (102, 'Laura'),        (103, 'Jordan'),        (104, 'Thomas'),        (105, 'Anne'),        (106, 'Robin'),        (107, 'Sean'),        (108, 'Michael'),        (109, 'Raymond'),        (110, 'Chad');  -- Создание таблицы Sellers CREATE TABLE Sellers (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(20) );  INSERT INTO Sellers (name) VALUES ('Deanna'),        ('Danielle'),        ('Bonnie'),        ('Matthew'),        ('Jennifer'),        ('John');  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     order_cost  DECIMAL,     customer_id INT,     seller_id   INT,     FOREIGN KEY (customer_id) REFERENCES Customers (id),     FOREIGN KEY (seller_id) REFERENCES Sellers (id) );  TRUNCATE Orders; INSERT INTO Orders (order_cost, customer_id, seller_id) VALUES (100, 101, 1),        (75, 102, 2),        (200, 103, 1),        (50, 104, 3),        (300, 105, 4),        (120, 106, 5),        (80, 107, 2),        (150, 108, 3),        (90, 109, 4),        (70, 110, 1),        (180, 101, 2),        (40, 102, 3),        (250, 103, 4),        (110, 104, 5),        (65, 105, 1),        (95, 106, 2),        (140, 107, 3),        (75, 108, 4),        (220, 109, 5),        (180, 110, 1);","Напишите запрос, извлекающий из предложенной базы данных имена покупателей, которые не приобрели ни одного товара у продавца с именем Bonnie.",30,5,select name from Customers where id != all (select customer_id                     from Orders O                    join Sellers S                      on seller_id = S.id                   where name = 'Bonnie'),SELECT Customers.name FROM Orders JOIN Sellers ON Orders.seller_id = Sellers.id AND Sellers.name = 'Bonnie'             RIGHT JOIN Customers ON Customers.id = Orders.customer_id WHERE seller_id IS NULL,
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Confirmations; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id   INT PRIMARY KEY,     name VARCHAR(20) );  INSERT INTO Customers (id, name) VALUES (101, 'Steven'),        (102, 'Laura'),        (103, 'Jordan'),        (104, 'Thomas'),        (105, 'Anne'),        (106, 'Robin'),        (107, 'Sean'),        (108, 'Michael'),        (109, 'Raymond'),        (110, 'Chad');  -- Создание таблицы Confirmations CREATE TABLE Confirmations (     customer_id INT,     order_id    INT,     status      ENUM ('confirmed', 'declined') );  TRUNCATE Confirmations; INSERT INTO Confirmations (customer_id, order_id, status) VALUES (102, 3, 'confirmed'),        (107, 8, 'confirmed'),        (102, 1, 'confirmed'),        (106, 6, 'declined'),        (103, 7, 'confirmed'),        (102, 9, 'confirmed'),        (109, 1, 'confirmed'),        (105, 4, 'declined'),        (106, 1, 'confirmed'),        (109, 10, 'confirmed'),        (104, 4, 'confirmed'),        (106, 2, 'declined'),        (104, 5, 'declined'),        (105, 4, 'confirmed'),        (110, 8, 'confirmed'),        (104, 3, 'declined'),        (105, 5, 'confirmed'),        (109, 7, 'confirmed'),        (109, 3, 'declined'),        (110, 2, 'declined'),        (104, 6, 'confirmed'),        (107, 9, 'confirmed'),        (110, 9, 'confirmed'),        (110, 5, 'declined'),        (103, 5, 'declined'),        (109, 4, 'confirmed'),        (103, 4, 'confirmed'),        (110, 4, 'declined'),        (103, 4, 'declined'),        (105, 7, 'confirmed');","Рейтингом подтверждения покупателя называется отношение его подтвержденных заказов к числу всех заказов. Если покупатель не сделал ни одного заказа, его рейтинг подтверждения считается равным 0.  Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех покупателей, а также определяет рейтинг подтверждения каждого покупателя.  Поле с рейтингом подтверждения покупателя должно иметь псевдоним confirmation_rate. Значения в поле confirmation_rate должны быть округлены до 2 знаков после запятой.",20,5,"SELECt C.id, round((select count(*) from Confirmations                     where C.id = customer_id                      and status = 'confirmed')/count(*), 2) as confirmation_rate from Customers C left join Confirmations on C.id = customer_id group by C.id","SELECT Customers.id,        IFNULL(ROUND(SUM(status='confirmed') / COUNT(status), 2), 0) AS confirmation_rate FROM Customers LEFT JOIN Confirmations ON customer_id = Customers.id GROUP BY Customers.id",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     machine_id    INT,     process_id    INT,     activity_type ENUM ('start','end'),     timestamp     FLOAT );  TRUNCATE Activity; INSERT INTO Activity (machine_id, process_id, activity_type, timestamp) VALUES (1, 2, 'start', 0.712),        (1, 2, 'end', 1.520),        (1, 3, 'start', 3.140),        (1, 3, 'end', 4.120),        (2, 4, 'start', 0.550),        (2, 4, 'end', 1.550),        (2, 5, 'start', 0.430),        (2, 5, 'end', 1.420),        (3, 6, 'start', 4.100),        (3, 6, 'end', 4.512),        (4, 7, 'start', 2.500),        (4, 7, 'end', 5.000),        (4, 8, 'start', 1.200),        (4, 8, 'end', 3.800),        (4, 9, 'start', 0.900),        (4, 9, 'end', 2.300),        (5, 10, 'start', 0.750),        (5, 10, 'end', 3.750),        (6, 11, 'start', 2.300),        (6, 11, 'end', 4.900);","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех машин, а также определяет среднее время, затрачиваемое каждой машиной на выполнение процесса.",25,5,"select A1.machine_id, round(avg(A2.timestamp — A1.timestamp), 3) as d from Activity A1 cross join Activity A2 on A1.machine_id = A2.machine_id and A1.process_id = A2.process_id and A1.timestamp < A2.timestamp group by machine_id","with A as (select A1.machine_id, round(A2.timestamp - A1.timestamp, 3) as d from Activity A1 cross join Activity A2 on A1.machine_id = A2.machine_id and A1.process_id = A2.process_id and A1.timestamp < A2.timestamp) select machine_id, round(sum(d)/count(*), 3) as processing_time from A group by machine_id",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Expressions; DROP TABLE IF EXISTS Variables;  -- Создание таблицы Variables CREATE TABLE Variables (     name  CHAR(1),     value INT );  INSERT INTO Variables (name, value) VALUES ('a', 1348),        ('b', 842);   -- Создание таблицы Expressions CREATE TABLE Expressions (     left_operand  CHAR(1),     operator      CHAR(1),     right_operand CHAR(1) );  INSERT INTO Expressions (left_operand, operator, right_operand) VALUES ('a', '<', 'b'),        ('a', '>', 'b'),        ('a', '=', 'b'),        ('b', '>', 'a'),        ('b', '=', 'a'),        ('b', '<', 'a'),        ('a', '=', 'a'),        ('b', '=', 'b'),        ('b', '>', 'b'),        ('a', '<', 'a');","Напишите запрос, который извлекает из предложенной базы данных всю информацию обо всех логических выражениях, а также определяет значение каждого выражения: true, если оно истинно, или false в противном случае.",40,7,"select left_operand, operator, right_operand,  case   when operator = '<' and V1.value < V2.value then 'true'  when operator = '>' and V1.value > V2.value then 'true'  when operator = '=' and V1.value = V2.value then 'true'  else 'false'  end as value from Expressions E left join Variables V1 on left_operand = V1.name left join Variables V2 on right_operand = V2.name ","SELECT left_operand, operator, right_operand,     IF(         CASE             WHEN operator = '>' THEN v1.value > v2.value             WHEN operator = '<' THEN v1.value < v2.value             ELSE v1.value = v2.value         END = 0, 'false', 'true'     ) AS value FROM Expressions AS e     JOIN Variables AS v1 ON v1.name = e.left_operand     JOIN Variables AS v2 ON v2.name = e.right_operand",
12.2. Задачи. Базовые соединения,"DROP TABLE IF EXISTS Matches; DROP TABLE IF EXISTS Teams;  -- Создание таблицы Teams CREATE TABLE Teams (     id   INT PRIMARY KEY,     name VARCHAR(30) );  INSERT INTO Teams (id, name) VALUES (10, 'Manchester United'),        (20, 'Liverpool FC'),        (30, 'Chelsea FC'),        (40, 'Arsenal FC'),        (50, 'Manchester City'),        (60, 'Tottenham Hotspur'),        (70, 'Everton FC'),        (80, 'Leicester City'),        (90, 'West Ham United'),        (100,'Aston Villa FC');  -- Создание таблицы Matches CREATE TABLE Matches (     id          INT PRIMARY KEY,     host_team   INT,     guest_team  INT,     host_goals  INT,     guest_goals INT );  TRUNCATE Matches; INSERT INTO Matches (id, host_team, guest_team, host_goals, guest_goals) VALUES (11, 10, 20, 2, 4),        (5, 10, 30, 4, 4),        (19, 20, 80, 2, 1),        (21, 20, 40, 3, 4),        (22, 20, 10, 1, 4),        (1, 30, 60, 0, 2),        (14, 30, 80, 4, 2),        (4, 40, 50, 4, 3),        (12, 40, 60, 2, 3),        (7, 50, 60, 2, 0),        (10, 50, 30, 4, 0),        (3, 50, 20, 4, 1),        (13, 60, 80, 0, 3),        (16, 60, 70, 2, 1),        (17, 60, 90, 2, 0),        (24, 70, 10, 0, 2),        (2, 70, 30, 0, 4),        (9, 70, 90, 3, 4),        (18, 80, 10, 0, 2),        (15, 80, 30, 0, 1),        (8, 80, 60, 2, 2),        (23, 80, 70, 4, 0),        (20, 90, 60, 3, 3),        (6, 100, 80, 3, 2),        (25, 100, 40, 3, 2);","За каждый матч футбольная команда может получить определенное количество очков. Если команда выигрывает матч, она получает 3 очка, если играет в ничью — 1 очко. Если команда проигрывает матч, она не получает ни одного очка. Напишите запрос, который извлекает из предложенной базы данных названия футбольных команд, а также определяет количество очков, набранное каждой командой в результате всех сыгранных матчей. При этом в результирующую таблицу должна быть добавлена информация только о тех футбольных командах, которые сыграли хотя бы один матч. ",40,7,"WITH NormalizeGoals AS (     SELECT host_team AS team_id, host_goals, guest_goals     FROM Matches      UNION ALL      SELECT guest_team, guest_goals, host_goals     FROM Matches ) SELECT name, SUM(CASE                      WHEN host_goals > guest_goals THEN 3                      WHEN host_goals = guest_goals THEN 1                      ELSE 0                  END) AS num_points FROM Teams INNER JOIN NormalizeGoals ON team_id = Teams.id GROUP BY name ORDER BY num_points DESC, name","with T as (select host_team as h_t, T1.name,         case          when host_goals > guest_goals then 3         when host_goals = guest_goals then 1         else 0         end as h_p from Matches M left join Teams T1 on host_team = T1.id      union all    select guest_team as g_t, T2.name,        case          when host_goals < guest_goals then 3         when host_goals = guest_goals then 1         else 0         end as g_p from Matches M left join Teams T2 on guest_team = T2.id) select name, sum(h_p) as num_points  from T group by name order by num_points desc, name",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Tree; CREATE TABLE Tree (     id   INT PRIMARY KEY,     p_id INT );  TRUNCATE Tree; INSERT INTO Tree (id, p_id) VALUES (8, NULL),        (3, 8),        (10, 8),        (1, 3),        (6, 3),        (14, 10),        (4, 6),        (7, 6),        (13, 14);","Элементы дерева называются узлами. На рисунке выше узлами являются значения 8, 3, 1, 6, 4, 7, 10, 14 и 13. Узлы без потомков называются листьями. На рисунке выше листьями являются значения 1, 4, 7 и 13. Узел без родителя называется корнем. На рисунке выше корнем является значение 8.  Вам доступна база данных, принадлежащая математическому ресурсу CleverStudents. Она включает таблицу Tree, которая хранит информацию об узлах определенного дерева.  Таблица Tree Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех узлов дерева, а также определяет тип каждого узла:  Root, если узел является корнем дерева Leaf, если узел является листом дерева Inner, если узел не является ни корнем, ни листом",20,5,"select id, case  when p_id is null then 'Root'  when id in (select p_id                  from Tree) then 'Inner'  else 'Leaf' end as type   from Tree",,
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Students; DROP TABLE IF EXISTS Departments;  -- Создание таблицы Departments CREATE TABLE Departments (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(100) NOT NULL );  INSERT INTO Departments (name) VALUES ('Electrical Engineering'),        ('Computer Engineering'),        ('Business Administration'),        ('Physics'),        ('Mathematics'),        ('Chemistry'),        ('Biology'),        ('History'),        ('Psychology'),        ('Sociology'),        ('Economics'),        ('Political Science'),        ('Literature'),        ('Fine Arts'),        ('Music'),        ('Physical Education'),        ('Philosophy'),        ('Languages'),        ('Geography'),        ('Environmental Science');  -- Создание таблицы Students CREATE TABLE Students (     id            INT PRIMARY KEY AUTO_INCREMENT,     name          VARCHAR(50) NOT NULL,     surname       VARCHAR(50) NOT NULL,     department_id INT );  TRUNCATE Students; INSERT INTO Students (name, surname, department_id) VALUES ('Alice', 'Johnson', 1),        ('Bob', 'Smith', 2),        ('Carol', 'Williams', 1),        ('David', 'Brown', 4),        ('Eve', 'Jones', 2),        ('Frank', 'Davis', 6),        ('Grace', 'Miller', 3),        ('Henry', 'Wilson', 8),        ('Irene', 'Lee', 2),        ('Jack', 'Hall', 10),        ('Kate', 'Harris', 1),        ('Leo', 'White', 2),        ('Mary', 'Clark', 1),        ('Nathan', 'Turner', 3),        ('Olivia', 'King', 2),        ('Peter', 'Scott', 1),        ('Rachel', 'Green', 3),        ('Sam', 'Taylor', 1332),        ('Tom', 'Wood', 2),        ('Vanessa', 'Baker', 777);","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии студентов, у которых в качестве факультета указан несуществующий факультет.",5,1,"select name, surname from Students where department_id not in (select id from Departments)",,
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Salaries; CREATE TABLE Salaries (     id     INT PRIMARY KEY AUTO_INCREMENT,     salary INT );  TRUNCATE Salaries; INSERT INTO Salaries (salary) VALUES (100),        (200),        (300),        (150),        (250),        (350),        (120),        (220),        (320),        (180),        (280),        (380),        (130),        (390),        (330),        (190),        (290),        (390),        (110),        (210); ","Напишите запрос, который определяет вторую по величине зарплату и указывает полученное значение в поле с псевдонимом second_highest_salary.",15,3,select distinct salary as second_highest_salary from Salaries         order by salary desc         limit 1         offset 1,select (select distinct salary from Salaries         order by salary desc         limit 1         offset 1)         as second_highest_salary from Salaries limit 1,SELECT MAX(salary) AS second_highest_salary FROM Salaries WHERE salary < (SELECT MAX(salary) FROM Salaries)
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     product_id INT,     year       YEAR,     quantity   VARCHAR(40),     price      INT );  TRUNCATE Sales; INSERT INTO Sales VALUES (1, 2018, 11, 9880),        (1, 2023, 30, 3050),        (3, 2023, 28, 3330),        (4, 2023, 47, 3373),        (1, 2022, 23, 7741),        (6, 2021, 48, 8825),        (5, 2018, 18, 7381),        (5, 2017, 16, 8923),        (6, 2018, 27, 4580),        (6, 2016, 45, 7546),        (6, 2019, 10, 4839),        (3, 2016, 40, 8195),        (3, 2021, 35, 7037),        (3, 2019, 25, 3162),        (2, 2016, 11, 3947),        (2, 2019, 18, 8056),        (5, 2016, 40, 6718),        (4, 2021, 49, 7253),        (4, 2018, 46, 7811),        (3, 2018, 11, 3153); "," Напишите запрос, который извлекает из предложенной базы данных всю информацию о продажах каждого товара. При этом в результирующую таблицу должна быть добавлена информация только за первый год продаж.",30,5,"select product_id, year as first_year, quantity, price from Sales where (product_id, year) in (select product_id, min(year) from Sales as S               where product_id = S.product_id               group by product_id)","SELECT product_id, year AS first_year, quantity, price FROM Sales AS OuterSales WHERE year = (SELECT MIN(year)               FROM Sales               WHERE product_id = OuterSales.product_id)",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id         INT PRIMARY KEY,     name       VARCHAR(50),     surname    VARCHAR(50),     manager_id INT,     salary     INT );  TRUNCATE Employees; INSERT INTO Employees (id, name, surname, manager_id, salary) VALUES (1, 'John', 'Doe', NULL, 50000.00),        (2, 'Jane', 'Smith', 12, 21000.00),        (3, 'Michael', 'Johnson', 1, 48000.00),        (4, 'Emily', 'Brown', NULL, 15000.00),        (6, 'Sophia', 'Davis', NULL, 49000.00),        (7, 'Oliver', 'Miller', 4, 23000.00),        (8, 'Emma', 'Anderson', NULL, 15000.00),        (9, 'Liam', 'Martinez', NULL, 30000.00),        (10, 'Ava', 'Garcia', 5, 11000.00),        (11, 'Lucas', 'Lopez', 6, 45000.00),        (13, 'Ethan', 'Clark', 8, 46000.00),        (14, 'Isabella', 'Lewis', 9, 49000.00),        (15, 'Noah', 'Young', 12, 48000.00),        (16, 'Sophia', 'Allen', NULL, 15000.00),        (18, 'Olivia', 'Wright', 16, 44000.00),        (19, 'Aiden', 'Green', 17, 25000.00),        (20, 'Chloe', 'Turner', 17, 20000.00);","Когда сотрудник покидает организацию, запись о нем удаляется из таблицы Employees. Однако если он являлся чьим-либо руководителем, его идентификатор сохраняется в поле manager_id.  Напишите запрос, извлекающий из предложенной базы данных имена и фамилии сотрудников, зарплата которых меньше 25000 и руководитель которых покинул компанию.",5,1,"select name, surname from Employees where manager_id not in (select id from Employees) and salary < 25000",,
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id      INT PRIMARY KEY AUTO_INCREMENT,     team_id INT );  TRUNCATE Employees; INSERT INTO Employees (team_id) VALUES (8),        (6),        (8),        (7),        (9),        (6),        (7),        (7),        (3),        (9),        (3),        (8),        (3),        (7),        (9),        (9),        (7),        (8),        (8),        (7); ","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех сотрудников, а также определяет размер команды каждого сотрудника.",20,3,"select id as employee_id, (select count(*) from Employees                            where team_id = E.team_id                            ) as team_size from Employees as E"," SELECT e.id AS employee_id, sub.team_size FROM Employees e JOIN (SELECT team_id, COUNT(*) AS team_size FROM Employees GROUP BY team_id) AS sub ON e.team_id = sub.team_id;",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     player_id    INT,     device_id    INT,     event_date   DATE,     games_played INT );  TRUNCATE Activity; INSERT INTO Activity (player_id, device_id, event_date, games_played) VALUES (1, 2, '2022-01-15', 4),        (1, 2, '2022-01-16', 5),        (2, 3, '2022-02-22', 3),        (2, 4, '2022-02-20', 2),        (3, 1, '2022-03-10', 1),        (3, 2, '2022-03-12', 0),        (4, 3, '2022-04-15', 6),        (4, 4, '2022-04-07', 7),        (5, 1, '2022-05-01', 2),        (5, 2, '2022-05-03', 3),        (6, 3, '2022-06-12', 1),        (6, 4, '2022-06-15', 0),        (7, 1, '2022-07-24', 5),        (7, 2, '2022-07-07', 4),        (8, 3, '2022-08-22', 3),        (8, 4, '2022-08-25', 4),        (9, 1, '2022-09-19', 2),        (9, 2, '2022-09-12', 3),        (10, 3, '2022-10-05', 6),        (10, 4, '2022-10-08', 7); ","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех игроков, а также для каждого пользователя определяет идентификатор устройства, с которого был выполнен первый вход.",20,5,"select player_id, device_id as first_device_id from Activity as A where event_date = (select min(event_date) from Activity                     where player_id = A.player_id)","SELECT DISTINCT player_id,        (SELECT device_id         FROM Activity         WHERE player_id = A.player_id         ORDER BY event_date         LIMIT 1) AS first_device_id FROM Activity AS A",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Products; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id      INT AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50),     PRIMARY KEY (id) );  INSERT INTO Customers (name, surname) VALUES ('Rupert', 'Murdoch'),        ('Al', 'Gore'),        ('Sacha', 'Baron'),        ('George', 'Clooney'),        ('Paul', 'Krugman'),        ('Wright', 'BrothersOrville'),        ('Ernest', 'Hemingway'),        ('Roman', 'Abramovich'),        ('Tom', 'Cruise'),        ('Lech', 'Walesa'),        ('Tim', 'Berners'),        ('Aung', 'San'),        ('Lance', 'Armstrong'),        ('Shakira', 'Curie'),        ('Jon', 'Stewart'),        ('Julie', 'Andrews'),        ('Florence', 'Nightingale'),        ('Marie', 'Curie'),        ('Stephen', 'Hawking'),        ('Jimmy', 'Wales');  -- Создание таблицы Products CREATE TABLE Products (     id    INT AUTO_INCREMENT,     name  VARCHAR(50),     price INT,     PRIMARY KEY (id) );  INSERT INTO Products VALUES (10, 'Instant Pot Duo 7-in-1', 9880),        (20, 'Dyson V11 Animal Vacuum', 8923),        (30, 'GoPro HERO9 Black', 8825),        (40, 'Amazon Echo Dot (4th Gen)', 8195),        (50, 'Xbox Series X', 8056),        (60, 'PlayStation 5', 7811),        (70, 'Fitbit Versa 3', 7741),        (80, 'Apple AirPods Pro', 7546),        (90, 'LG OLED55CXPUA TV', 7381),        (100, 'Samsung 65-inch QLED TV', 7253);  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT AUTO_INCREMENT,     customer_id INT,     product_id  INT,     order_date  DATE,     quantity    INT,     PRIMARY KEY (id),     FOREIGN KEY (customer_id)         REFERENCES Customers (id),     FOREIGN KEY (product_id)         REFERENCES Products (id) );  TRUNCATE Orders; INSERT INTO Orders (customer_id, product_id, order_date, quantity) VALUES (15, 90, '2023-10-24', 1),        (7, 10, '2023-09-11', 8),        (6, 10, '2023-06-07', 10),        (11, 20, '2023-08-17', 8),        (14, 20, '2023-08-15', 6),        (4, 10, '2023-07-24', 6),        (19, 30, '2023-05-19', 3),        (4, 30, '2023-05-11', 1),        (18, 40, '2023-06-18', 10),        (6, 20, '2023-06-14', 8),        (2, 90, '2023-08-13', 10),        (13, 70, '2023-06-05', 9),        (14, 100, '2023-10-19', 2),        (17, 100, '2023-05-18', 1),        (16, 100, '2023-07-19', 2),        (8, 20, '2023-05-01', 6),        (7, 10, '2023-10-17', 1),        (7, 10, '2023-08-23', 2),        (17, 50, '2023-07-16', 8),        (18, 40, '2023-09-12', 6);","Напишите запрос, извлекающий из предложенной базы данных названия товаров, которые были куплены хотя бы раз, и указывающий для каждого товара дату, когда этот товар был куплен в последний раз.",20,4,"select name as product_name, (select max(order_date) from Orders                               where product_id = Products.id)  as last_purchase_date  from Products where (select max(order_date) from Orders                               where product_id = Products.id) is not null order by product_name","select name as product_name, order_date as last_purchase_date from Products P join Orders O on P.id = product_id where order_date = (select max(order_date) from Orders                     where product_id = O.product_id) order by product_name",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Transactions; CREATE TABLE Transactions (     id     INT PRIMARY KEY AUTO_INCREMENT,     day    TIMESTAMP,     amount DECIMAL(10, 2) );  TRUNCATE Transactions; INSERT INTO Transactions (day, amount) VALUES ('2023-09-14 09:00:00', 100.50),        ('2023-09-11 10:15:30', 75.25),        ('2023-09-12 14:30:45', 150.00),        ('2023-09-12 16:45:15', 25.75),        ('2023-09-13 08:20:10', 300.20),        ('2023-10-03 12:00:00', 50.00),        ('2023-10-03 15:30:20', 45.60),        ('2023-10-07 17:10:55', 90.75),        ('2023-10-07 11:45:30', 200.00),        ('2023-10-10 14:55:40', 120.40),        ('2023-10-11 09:30:15', 75.60),        ('2023-11-01 10:45:00', 30.25),        ('2023-11-02 13:20:30', 60.75),        ('2023-11-02 15:10:10', 180.90),        ('2023-11-02 08:15:25', 25.00),        ('2023-12-03 12:30:45', 90.20),        ('2023-12-03 14:40:00', 150.50),        ('2023-12-06 16:55:30', 45.75),        ('2023-12-23 09:10:15', 110.30),        ('2023-12-03 11:25:50', 70.75);","Напишите запрос, извлекающий из предложенной базы данных идентификаторы переводов, которые имеют наибольшую сумму среди всех остальных переводов, выполненных в тот же день. Если в рамках одного дня несколько переводов имеют наибольшую сумму, в результирующую таблицу должен добавлен идентификатор каждого такого перевода.",40,5,select id from Transactions where amount in (select max(amount) from Transactions                  group by date(day)) order by id desc,SELECT id FROM Transactions T WHERE amount = (SELECT MAX(amount)                 FROM Transactions                 WHERE DATE(day) = DATE(T.day)) ORDER BY id DESC,
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     product_id INT PRIMARY KEY AUTO_INCREMENT,     income     INT );  TRUNCATE Sales; INSERT INTO Sales (income) VALUES (15000),        (28000),        (3500),        (60000),        (42000),        (95000),        (18000),        (7500),        (3000),        (12000),        (55000),        (49000),        (8000),        (4200),        (36000),        (48000),        (11000),        (62000),        (52000),        (25000);","Все товары, в зависимости от суммы, на которую они были проданы, попадают в одну из следующих категорий:  Low Sales, если продажи меньше 20000 долларов Average Sales, если продажи в диапазоне [20000; 50000] High Sales, если продажи больше 50000 долларов Напишите запрос, который разбивает товары магазина на категории, согласно их продажам, и определяет количество товаров в каждой категории.",40,7,"SELECT ""Low Sales"" AS category, (SELECT COUNT(*)                                  FROM Sales                                  WHERE income < 20000) AS products_count  UNION ALL  SELECT ""Average Sales"" , (SELECT COUNT(*)                           FROM Sales                           WHERE income >= 20000 AND income <= 50000)  UNION ALL   SELECT ""High Sales"", (SELECT COUNT(*)                       FROM Sales                       WHERE income > 50000)","select     Cat.category,  count(product_id) as products_count from (     select 'Low Sales' as category, 0 as low, 19999 as hi     union all     select 'Average Sales' as category, 20000 as low, 50000 as hi     union all     select 'High Sales' as category, 50001 as low, 2147483647 as hi     ) as Cat     left join Sales on         Sales.income between Cat.low and Cat.hi group by Cat.category",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS RequestsAccepted; CREATE TABLE RequestsAccepted (     requester_id INT,     accepter_id  INT,     accept_date  DATE );  TRUNCATE RequestsAccepted; INSERT INTO RequestsAccepted (requester_id, accepter_id, accept_date) VALUES (1, 2, '2022-01-10'),        (1, 3, '2022-02-15'),        (2, 3, '2022-02-20'),        (3, 4, '2022-03-05'),        (4, 1, '2022-03-10'),        (2, 4, '2022-04-12'),        (5, 6, '2022-04-20'),        (6, 7, '2022-05-03'),        (7, 8, '2022-05-15'),        (8, 9, '2022-05-20'),        (10, 11, '2022-06-02'),        (11, 12, '2022-06-10'),        (12, 13, '2022-07-05'),        (14, 15, '2022-07-10'),        (15, 16, '2022-07-15'),        (17, 18, '2022-08-03'),        (18, 19, '2022-08-15'),        (19, 20, '2022-09-05'),        (20, 1, '2022-09-12'),        (9, 10, '2022-09-20');","Напишите запрос, извлекающий из предложенной базы данных идентификатор пользователя, который имеет наибольшее количество друзей. Помимо идентификатора пользователя, должно быть извлечено и само количество этих друзей.",60,8,"SELECT id, COUNT(*) AS friends FROM (     SELECT requester_id AS id, accepter_id FROM RequestsAccepted     UNION     SELECT accepter_id, requester_id FROM RequestsAccepted ) AS all_users GROUP BY id ORDER BY friends DESC LIMIT 1","with R as( select distinct accepter_id, (select count(*) from RequestsAccepted                       where accepter_id = A.accepter_id) as a from RequestsAccepted as A union all select distinct requester_id, (select count(*) from RequestsAccepted                       where requester_id = A.requester_id) as a from RequestsAccepted as A) select accepter_id as id, sum(a) as friends from R group by id order by friends desc limit 1",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Queue; CREATE TABLE Queue (     person_id   INT PRIMARY KEY AUTO_INCREMENT,     person_name VARCHAR(255),     weight      INT,     turn        INT );  TRUNCATE Queue; INSERT INTO Queue (person_name, weight, turn) VALUES ('Eva', 300, 1),        ('Michael', 180, 2),        ('Sophia', 400, 3),        ('Liam', 220, 4),        ('Olivia', 350, 5),        ('James', 500, 6),        ('Emma', 280, 7),        ('Noah', 380, 8),        ('Ava', 450, 9),        ('William', 280, 10),        ('Mia', 300, 11),        ('Benjamin', 220, 12),        ('Isabella', 180, 13),        ('Daniel', 420, 14),        ('Sophia', 270, 15),        ('Elijah', 370, 16),        ('Charlotte', 320, 17),        ('Henry', 240, 18),        ('Amelia', 290, 19),        ('Alexander', 260, 20);","Пассажиры садятся в автобус согласно своей очереди. Однако автобус имеет ограничение по весу в 1000 килограмм, поэтому не все пассажиры смогут сесть в автобус.  Напишите запрос, извлекающий из предложенной базы данных имя последнего пассажира, который сможет сесть в автобус и не превысить ограничение по весу.",70,8,"select person_name from Queue                                                        where weight + ifnull((select sum(weight) from Queue as Q                 where Q.turn < Queue.turn), 0) <= 1000 order by weight + ifnull((select sum(weight) from Queue as Q                    where Q.turn < Queue.turn), 0) desc limit 1","select person_name from Queue                                                        where weight + ifnull((select sum(weight) from Queue as Q                 where Q.turn < Queue.turn), 0) <= 1000 order by weight + ifnull((select sum(weight) from Queue as Q                    where Q.turn < Queue.turn), 0) desc limit 1",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(255) );  INSERT INTO Customers (name) VALUES ('Alice'),        ('Bob'),        ('Charlie'),        ('David'),        ('Eve'),        ('Frank'),        ('Grace'),        ('Henry'),        ('Ivy'),        ('Jack'),        ('Kate'),        ('Leo'),        ('Mia'),        ('Nina'),        ('Oliver'),        ('Paul'),        ('Quinn'),        ('Rose'),        ('Sam'),        ('Tom');  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     order_date  DATE,     customer_id INT,     cost        DECIMAL(10, 2) );  TRUNCATE Orders; INSERT INTO Orders (order_date, customer_id, cost) VALUES ('2023-01-15', 1, 25.99),        ('2023-01-18', 3, 55.50),        ('2023-02-02', 2, 38.75),        ('2023-02-05', 1, 42.00),        ('2023-02-10', 4, 75.20),        ('2023-02-20', 3, 29.99),        ('2023-03-05', 2, 16.50),        ('2023-03-12', 1, 49.99),        ('2023-03-18', 4, 62.30),        ('2023-03-25', 3, 33.75),        ('2023-04-01', 2, 45.00),        ('2023-04-08', 1, 19.99),        ('2023-04-15', 5, 82.50),        ('2023-04-22', 3, 27.75),        ('2023-04-29', 2, 69.90),        ('2023-05-06', 1, 12.99),        ('2023-05-13', 4, 18.25),        ('2023-05-20', 2, 50.00),        ('2023-05-27', 1, 22.50),        ('2023-06-03', 3, 39.99); ","Напишите запрос, извлекающий из предложенной базы данных информацию о трех последних заказах каждого покупателя. Запись с информацией о заказе должна включать имя покупателя, идентификатор заказа и дату заказа. Если у покупателя менее трех заказов, в результирующую таблицу должна быть добавлена информация о каждом заказе покупателя.  Поле с идентификатором заказа должно иметь псевдоним order_id.",100,9,"SELECT      (SELECT name      FROM Customers      WHERE id = Orders.customer_id) AS name,      id AS order_id,      order_date FROM     Orders WHERE order_date IN (SELECT order_date                      FROM (SELECT order_date                            FROM Orders AS Last_three_orders                            WHERE Last_three_orders.customer_id = Orders.customer_id                            ORDER BY order_date DESC                            LIMIT 3) AS Last_three_dates) ORDER BY      name,      order_id DESC","with A as ( select customer_id, id, order_date  , row_number() over (partition by customer_id order by order_date desc) as n from Orders ) select (select name from Customers         where id = A.customer_id) as name         , id as order_id         , order_date from A where n <= 3",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Employees; DROP TABLE IF EXISTS Departments;  -- Создание таблицы Departments CREATE TABLE Departments (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(100) NOT NULL );  INSERT INTO Departments (name) VALUES     ('Engineering'),     ('Sales'),     ('Marketing'),     ('Human Resources'),     ('Finance');  -- Создание таблицы Employees CREATE TABLE Employees (     id            INT PRIMARY KEY AUTO_INCREMENT,     name          VARCHAR(50) NOT NULL,     surname       VARCHAR(50) NOT NULL,     salary        INT,     department_id INT,     FOREIGN KEY (department_id) REFERENCES Departments(id) );  TRUNCATE Employees; INSERT INTO Employees (name, surname, salary, department_id) VALUES     ('Alice', 'Johnson', 90000, 1),     ('Bob', 'Smith', 80000, 2),     ('Carol', 'Williams', 75000, 2),     ('David', 'Brown', 95000, 1),     ('Eve', 'Jones', 70000, 1),     ('Frank', 'Davis', 85000, 1),     ('Grace', 'Miller', 72000, 1),     ('Harry', 'Wilson', 93000, 2),     ('Irene', 'Lee', 72000, 2),     ('Jack', 'Hall', 98000, 1),     ('Kelly', 'Harris', 71000, 1),     ('Larry', 'White', 81000, 2),     ('Mary', 'Clark', 85000, 1),     ('Nancy', 'Turner', 70000, 2),     ('Oscar', 'King', 92000, 1),     ('Peter', 'Scott', 76000, 2),     ('Queen', 'Green', 99000, 1),     ('Rachel', 'Adams', 73000, 1),     ('Steve', 'Martin', 80000, 2),     ('Tom', 'Wood', 91000, 1); ","Напишите запрос, извлекающий из предложенной базы данных информацию о сотрудниках (название отдела, имя, фамилия, заработная плата), которые имеют самую высокую зарплату внутри своего отдела. Если внутри отдела несколько сотрудников имеют самую высокую зарплату, в результирующую таблицу должна быть добавлена информация о каждом таком сотруднике.",15,5,"select (select name from Departments         where id = Employees.department_id) as department,         name, surname, salary from Employees where (salary, department_id) in (select max(salary) as s, department_id from Employees as E                                  group by department_id)","SELECT Departments.name AS department, Employees.name, Employees.surname, salary FROM Employees INNER JOIN Departments ON department_id = Departments.id WHERE salary = (SELECT MAX(salary)                 FROM Employees                 WHERE department_id = Departments.id)","SELECT name, Orders.id AS order_id, order_date FROM Customers INNER JOIN Orders ON customer_id = Customers.id WHERE (SELECT COUNT(*)        FROM Orders AS InnerOrders        WHERE customer_id = Customers.id AND order_date >= Orders.order_date) <= 3 ORDER BY name, order_date DESC"
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Employees; DROP TABLE IF EXISTS Departments;  -- Создание таблицы Departments CREATE TABLE Departments (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(100) NOT NULL );  INSERT INTO Departments (name) VALUES ('Engineering'),        ('Sales'),        ('Marketing'),        ('Human Resources'),        ('Finance');  -- Создание таблицы Employees CREATE TABLE Employees (     id            INT PRIMARY KEY AUTO_INCREMENT,     name          VARCHAR(50) NOT NULL,     surname       VARCHAR(50) NOT NULL,     salary        INT,     department_id INT,     FOREIGN KEY (department_id) REFERENCES Departments(id) );  TRUNCATE Employees; INSERT INTO Employees (name, surname, salary, department_id) VALUES     ('Alice', 'Johnson', 90000, 1),     ('Bob', 'Smith', 80000, 2),     ('Carol', 'Williams', 75000, 2),     ('David', 'Brown', 95000, 1),     ('Eve', 'Jones', 70000, 1),     ('Frank', 'Davis', 85000, 1),     ('Grace', 'Miller', 72000, 1),     ('Harry', 'Wilson', 93000, 2),     ('Irene', 'Lee', 72000, 2),     ('Jack', 'Hall', 98000, 1),     ('Kelly', 'Harris', 71000, 1),     ('Larry', 'White', 81000, 2),     ('Mary', 'Clark', 85000, 1),     ('Nancy', 'Turner', 70000, 2),     ('Oscar', 'King', 92000, 1),     ('Peter', 'Scott', 76000, 2),     ('Queen', 'Green', 99000, 1),     ('Rachel', 'Adams', 73000, 1),     ('Steve', 'Martin', 80000, 2),     ('Tom', 'Wood', 91000, 1);","В каждом отделе организации имеются высокооплачиваемые сотрудники. Сотрудник отдела называется высокооплачиваемым, если его зарплата входит в тройку самых высоких зарплат внутри этого отдела.  Напишите запрос, извлекающий из предложенной базы данных информацию о сотрудниках (название отдела, имя, фамилия, зарплата), которые являются высокооплачиваемыми.",30,7,"with T as ( select (select name from Departments         where id = Employees.department_id) as department, department_id,        name, surname, salary  from Employees  ) select department,         name, surname, salary from T where salary in (select salary from (select salary from Employees as S3                                      where S3.department_id = T.department_id                                      group by salary                                      order by salary desc                                      limit 3) as S) order by department, salary desc","SELECT Departments.name AS department, Employees.name, Employees.surname, salary FROM Employees LEFT JOIN Departments ON department_id = Departments.id WHERE (SELECT COUNT(DISTINCT salary)          FROM Employees AS InnerEmployees         WHERE department_id = Employees.department_id           AND salary >= Employees.salary) <= 3",
12.3. Задачи. Подзапросы,"DROP TABLE IF EXISTS Visits; CREATE TABLE Visits (     customer_id INT PRIMARY KEY AUTO_INCREMENT,     name        VARCHAR(50),     visited_on  DATE,     amount      DECIMAL(10, 2) );  TRUNCATE Visits; INSERT INTO Visits (name, visited_on, amount) VALUES ('Alice', '2023-01-11', 90.00),        ('Bob', '2023-01-12', 120.00),        ('Eva', '2023-01-13', 100.00),        ('Chris', '2023-01-14', 110.00),        ('Sophia', '2023-01-15', 130.00),        ('David', '2023-01-16', 140.00),        ('Olivia', '2023-01-17', 120.00),        ('Michael', '2023-01-18', 110.00),        ('Emma', '2023-01-19', 90.00),        ('Liam', '2023-01-20', 80.00),        ('Bob', '2023-01-20', 150.00),        ('Ava', '2023-01-21', 150.00),        ('William', '2023-01-22', 130.00),        ('Mia', '2023-01-23', 110.00),        ('James', '2023-01-24', 120.00),        ('Charlotte', '2023-01-25', 140.00),        ('Benjamin', '2023-01-26', 110.00),        ('Amelia', '2023-01-27', 90.00),        ('Lucas', '2023-01-28', 80.00),        ('Harper', '2023-01-29', 150.00),        ('Henry', '2023-01-29', 130.00); ","Каждый день в ресторан приходит как минимум один посетитель, поэтому дни посещения ресторана могут быть объединены в периоды. Периоды обозначаются одной датой — самой последней. Например, семидневный период, обозначаемый датой 2023-01-08, включает 7 последовательных дат от 2023-01-02 до 2023-01-08 включительно.  Напишите запрос, который определяет следующую информацию для каждого возможного семидневного периода:  amount — общая сумма, потраченная посетителями average_amount — средний дневной заработок ресторана Поле с датой, обозначающей период, должно иметь псевдоним period. Значения в поле average_amount должны быть округлены до 2 знаков после запятой.  ",60,9,"with dat as (     select v1.visited_on as period         , (select sum(v3.amount)             from Visits v3             where v3.visited_on between v1.visited_on - 6 and v1.visited_on            ) amount     from Visits v1     where 7 <= (         select count(distinct(visited_on))         from Visits v2         where v2.visited_on <= v1.visited_on     )     group by visited_on ) select period     , amount     , ROUND (amount / 7, 2) as average_amount from dat",,
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Teachers; CREATE TABLE Teachers (     id         INT,     subject_id INT,     dept_id    INT );  TRUNCATE Teachers; INSERT INTO Teachers (id, subject_id, dept_id) VALUES (3, 1, 1),        (1, 1, 5),        (5, 1, 2),        (4, 1, 1),        (2, 2, 1),        (1, 2, 1),        (5, 1, 5),        (3, 2, 1),        (5, 2, 3),        (1, 3, 1),        (4, 2, 1),        (4, 3, 4),        (1, 4, 3),        (4, 4, 5),        (5, 3, 3),        (3, 1, 4),        (2, 3, 1),        (3, 4, 1),        (2, 4, 5),        (5, 4, 4);","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех педагогов, а также определяет количество уникальных предметов, преподаваемых каждым педагогом.",5,2,"select id as teacher_id, count(distinct subject_id) as subjects_num from Teachers group by teacher_id","SELECT DISTINCT visited_on AS period,        (SELECT SUM(amount)         FROM Visits         WHERE DATEDIFF(V.visited_on, visited_on) BETWEEN 0 AND 6) AS amount,        (SELECT ROUND(SUM(amount) / 7, 2)         FROM Visits         WHERE DATEDIFF(V.visited_on, visited_on) BETWEEN 0 AND 6) AS average_amount FROM Visits AS V WHERE (SELECT COUNT(DISTINCT visited_on)        FROM Visits        WHERE visited_on <= V.visited_on) >= 7;",
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     user_id       INT,     session_id    INT,     activity_date DATE,     activity_type VARCHAR(50) );  TRUNCATE Activity; INSERT INTO Activity (user_id, session_id, activity_date, activity_type) VALUES (2, 4, '2023-09-01', 'open_session'),        (1, 2, '2023-09-01', 'open_session'),        (5, 1, '2023-09-01', 'open_session'),        (3, 5, '2023-09-02', 'open_session'),        (5, 3, '2023-09-02', 'scroll_down'),        (1, 5, '2023-09-02', 'send_message'),        (4, 1, '2023-09-02', 'open_session'),        (4, 4, '2023-09-02', 'end_session'),        (3, 4, '2023-09-02', 'end_session'),        (1, 1, '2023-09-02', 'scroll_down'),        (2, 2, '2023-09-02', 'scroll_down'),        (4, 4, '2023-09-03', 'open_session'),        (1, 1, '2023-09-03', 'end_session'),        (4, 4, '2023-09-03', 'end_session'),        (5, 5, '2023-09-03', 'scroll_down'),        (3, 5, '2023-09-04', 'open_session'),        (2, 3, '2023-09-04', 'send_message'),        (3, 5, '2023-09-04', 'end_session'),        (2, 1, '2023-09-04', 'end_session'),        (5, 4, '2023-09-04', 'end_session'); ","Напишите запрос, который разбивает совершенные на сайте действия на группы в зависимости от их даты, определяет количество уникальных пользователей в каждой группе и отображает полученный результат в виде таблицы из двух полей:",5,1,"select activity_date, count(distinct user_id) as active_users from Activity group by activity_date",,
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Classes; CREATE TABLE Classes (     student_id INT AUTO_INCREMENT,     class      VARCHAR(50),     PRIMARY KEY (student_id) );  TRUNCATE Classes; INSERT INTO Classes (class) VALUES ('Math'),        ('English'),        ('Computer'),        ('Math'),        ('English'),        ('Computer'),        ('Computer'),        ('Math'),        ('Math'),        ('Biology'),        ('Computer'),        ('Computer'),        ('Math'),        ('Math'),        ('English'),        ('Math'),        ('Math'),        ('Computer'),        ('Biology'),        ('Computer'); ","Напишите запрос, извлекающий из предложенной базы данных названия предметов, которые любимы как минимум тремя студентами.",10,2,select class from Classes group by class having count(*) >= 3,,
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Followers; CREATE TABLE Followers (     user_id     INT,     follower_id INT );  TRUNCATE Followers; INSERT INTO Followers VALUES (1, 1),        (1, 2),        (1, 3),        (1, 4),        (2, 1),        (2, 2),        (2, 5),        (2, 6),        (3, 2),        (3, 1),        (3, 7),        (3, 10),        (4, 4),        (4, 5),        (4, 2),        (4, 8),        (5, 6),        (5, 7),        (5, 8),        (6, 1),        (7, 1),        (8, 2),        (9, 3),        (10, 4);","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех пользователей, а также определяет количество подписчиков у каждого пользователя.",10,2,"select user_id, count(*) followers_num from Followers group by user_id order by followers_num , user_id",,
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Numbers; CREATE TABLE Numbers (     num INT );  TRUNCATE Numbers; INSERT INTO Numbers VALUES (2),        (4),        (8),        (8),        (3),        (9),        (7),        (1),        (9),        (3),        (6),        (8),        (8),        (9),        (8),        (8),        (3),        (2),        (4),        (4),        (5),        (8),        (8),        (8),        (5),        (5),        (4);","Число, которое встречается в таблице Numbers только один раз, называется одиночным числом.  Напишите запрос, который извлекает из предложенной базы данных наибольшее одиночное число.",10,3,select num from Numbers group by num having count(*) = 1 order by num desc limit 1,SELECT MAX(num) num FROM (SELECT num FROM Numbers GROUP BY num HAVING COUNT(num) = 1) vvvvv,
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id   INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(100) );  INSERT INTO Products (name) VALUES ('Apple iPhone 13 Pro'),        ('Samsung Galaxy S21'),        ('Sony WH-1000XM4 Headphones'),        ('Nike Air Zoom Pegasus 38'),        ('Adidas Ultraboost 21'),        ('Lenovo ThinkPad X1 Carbon'),        ('Dell XPS 13 Laptop'),        ('Canon EOS R6 Camera'),        ('Bose QuietComfort 35 II');  -- Создание таблицы Sales CREATE TABLE Sales (     customer_id INT,     product_id  INT );  TRUNCATE Sales; INSERT INTO Sales (customer_id, product_id) VALUES (1, 1),        (2, 7),        (3, 2),        (4, 3),        (2, 3),        (1, 4),        (5, 9),        (4, 2),        (4, 5),        (4, 9),        (5, 4),        (3, 6),        (2, 4),        (1, 2),        (4, 8),        (5, 4),        (6, 4),        (5, 2),        (5, 2),        (6, 4),        (4, 4),        (1, 3),        (1, 5),        (1, 6),        (4, 6),        (1, 9),        (1, 7),        (4, 7),        (1, 8),        (2, 7),        (2, 7),        (2, 3),        (4, 1),        (2, 4),        (2, 3),        (2, 4); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы пользователей, которые приобрели все доступные в магазине товары.",30,6,select customer_id from Sales  group by customer_id having count(distinct product_id) = (select max(id) from Products),SELECT customer_id FROM Sales GROUP BY customer_id HAVING GROUP_CONCAT(product_id ORDER BY product_id) = (SELECT GROUP_CONCAT(id ORDER BY id) FROM Products),
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Transactions; DROP TABLE IF EXISTS Users;  -- Создание таблицы Users CREATE TABLE Users (     account INT AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50),     PRIMARY KEY (account) );  INSERT INTO Users (account, name, surname) VALUES (60001, 'Rupert', 'Murdoch'),        (60002, 'Al', 'Gore'),        (60003, 'Sacha', 'Baron'),        (60004, 'George', 'Clooney'),        (60005, 'Paul', 'Krugman'),        (60006, 'Wright', 'BrothersOrville'),        (60007, 'Ernest', 'Hemingway'),        (60008, 'Roman', 'Abramovich'),        (60009, 'Tom', 'Cruise'),        (60010, 'Lech', 'Walesa'),        (60011, 'Tim', 'Berners'),        (60012, 'Aung', 'San'),        (60013, 'Lance', 'Armstrong'),        (60014, 'Shakira', 'Curie'),        (60015, 'Jon', 'Stewart'),        (60016, 'Julie', 'Andrews'),        (60017, 'Florence', 'Nightingale'),        (60018, 'Marie', 'Curie'),        (60019, 'Stephen', 'Hawking'),        (60020, 'Jimmy', 'Wales');  -- Создание таблицы Transactions CREATE TABLE Transactions (     id            INT PRIMARY KEY AUTO_INCREMENT,     account       INT,     amount        INT,     transacted_on DATE,     FOREIGN KEY (account) REFERENCES Users (account) );  TRUNCATE Transactions; INSERT INTO Transactions (account, amount, transacted_on) VALUES (60014, 8561, '2023-09-01'),        (60017, 6533, '2023-09-02'),        (60016, 1067, '2023-09-03'),        (60015, 3184, '2023-09-04'),        (60010, 5072, '2023-09-07'),        (60008, 9085, '2023-09-08'),        (60013, 1253, '2023-09-10'),        (60007, 6061, '2023-09-11'),        (60015, -6058, '2023-09-15'),        (60011, 205, '2023-09-20'),        (60001, 178, '2023-10-01'),        (60014, 4908, '2023-10-02'),        (60014, 2812, '2023-10-10'),        (60002, 458, '2023-10-14'),        (60019, 4047, '2023-11-02'),        (60015, -8595, '2023-11-06'),        (60017, 2057, '2023-11-17'),        (60008, 8442, '2023-11-22'),        (60008, -1905, '2023-11-22'),        (60010, -72, '2023-09-07'),        (60011, -338, '2023-12-03');","Баланс каждого банковского счета до выполнения с ним каких-либо операций равен 0. Баланс банковского счета, полученный в результате всех совершенных с ним операций, называется актуальным балансом.  Напишите запрос, извлекающий из предложенной базы данных информацию о пользователях банка (имя, фамилия, актуальный баланс), актуальный баланс которых больше 5000.",10,2,"select name, surname, sum(amount) as balance from Users U join Transactions T on U.account = T.account group by U.account having balance > 5000","select name, surname, sum(amount) balance from Users  join Transactions using (account) group by account having(balance) > 5000","SELECT name, surname, SUM(amount) balance FROM Users JOIN Transactions USING(account) GROUP BY 1, 2 HAVING balance > 5000;"
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS ActorsDirectors; CREATE TABLE ActorsDirectors (     film_id     INT,     actor_id    INT,     director_id INT );  TRUNCATE ActorsDirectors; INSERT INTO ActorsDirectors (film_id, actor_id, director_id) VALUES (4, 1, 5),        (5, 3, 1),        (2, 2, 5),        (6, 4, 1),        (2, 6, 5),        (8, 5, 4),        (2, 9, 5),        (7, 5, 4),        (8, 4, 1),        (5, 8, 1),        (2, 10, 5),        (8, 6, 4),        (3, 5, 3),        (3, 4, 1),        (1, 5, 4),        (3, 3, 3),        (3, 2, 3),        (1, 8, 4),        (8, 4, 1),        (3, 6, 3),        (4, 8, 5),        (4, 7, 5),        (6, 5, 1),        (6, 4, 1),        (7, 2, 4),        (7, 8, 4),        (9, 5, 4),        (9, 8, 4);","Напишите запрос, извлекающий из предложенной базы данных пары (идентификатор актера, идентификатор режиссера), которые работали вместе как минимум над 3 фильмами.",5,2,"select actor_id, director_id  from ActorsDirectors group by actor_id, director_id  having count(*) >= 3",,
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id         INT PRIMARY KEY AUTO_INCREMENT,     name       VARCHAR(50),     surname    VARCHAR(50),     manager_id INT );  TRUNCATE Employees; INSERT INTO Employees (name, surname, manager_id) VALUES ('John', 'Anderson', NULL),        ('Alice', 'Smith', 1),        ('Bob', 'Johnson', 1),        ('Eva', 'Williams', 1),        ('Michael', 'Brown', 1),        ('Olivia', 'Davis', 1),        ('William', 'Wilson', 2),        ('Sophia', 'Lee', 2),        ('James', 'Anderson', 2),        ('Emily', 'Martinez', 2),        ('Daniel', 'Taylor', 2),        ('Emma', 'Garcia', 3),        ('Benjamin', 'Harris', 3),        ('Mia', 'Lopez', 3),        ('Aiden', 'Jackson', 3),        ('Sophia', 'Moore', 4),        ('Liam', 'Clark', 4),        ('Ava', 'Young', 4),        ('Henry', 'Walker', 4),        ('Isabella', 'Lewis', 4),        ('Ethan', 'Hall', 4),        ('Olivia', 'Green', 5),        ('Amelia', 'Turner', 5),        ('Lucas', 'Hernandez', 5),        ('Mia', 'Adams', 6),        ('Noah', 'Carter', 6),        ('Harper', 'White', 7),        ('Liam', 'Perez', 7),        ('Ella', 'Smith', 8),        ('Oliver', 'Johnson', 8),        ('Charlotte', 'Clark', 8);","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии сотрудников, которые имеют как минимум 5 подчиненных.",10,3,"select name, surname  from (select manager_id, count(*) from Employees       group by manager_id       having count(*) >= 5) as E join Employees E2 on E.manager_id = E2.id","SELECT Bosses.name, Bosses.surname FROM Employees AS Bosses JOIN Employees ON Bosses.id = Employees.manager_id GROUP BY Bosses.id HAVING COUNT(*) >= 5;",
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS FilmRatings; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id    INT PRIMARY KEY AUTO_INCREMENT,     title VARCHAR(150) );  INSERT INTO Films (title) VALUES ('The Matrix'),        ('Inception'),        ('Interstellar'),        ('Pulp Fiction'),        ('The Shawshank Redemption'),        ('Fight Club'),        ('Forrest Gump'),        ('The Dark Knight'),        ('Gladiator'),        ('The Godfather'),        ('The Lord of the Rings'),        ('The Avengers'),        ('Titanic'),        ('Jurassic Park'),        ('Avatar'),        ('The Silence of the Lambs'),        ('Braveheart'),        ('The Departed'),        ('Schindler''s List'),        ('The Shawshank Redemption');  -- Создание таблицы Users CREATE TABLE Users (     id       INT PRIMARY KEY AUTO_INCREMENT,     username VARCHAR(100) );  INSERT INTO Users (username) VALUES ('JohnDoe'),        ('JaneSmith'),        ('MichaelJohnson'),        ('EmilyBrown'),        ('DavidWilson'),        ('SophiaDavis'),        ('OliverMiller'),        ('EmmaAnderson'),        ('LiamMartinez'),        ('AvaGarcia'),        ('LucasLopez'),        ('MilaHarris'),        ('EthanClark'),        ('IsabellaLewis'),        ('NoahYoung'),        ('SophiaAllen'),        ('LoganHall'),        ('OliviaWright'),        ('AidenGreen'),        ('ChloeTurner');  -- Создание таблицы FilmRatings CREATE TABLE FilmRatings (     film_id    INT,     user_id    INT,     rating     INT,     created_at DATE,     PRIMARY KEY (film_id, user_id),     FOREIGN KEY (film_id) REFERENCES Films(id),     FOREIGN KEY (user_id) REFERENCES Users(id) );  TRUNCATE FilmRatings; INSERT INTO FilmRatings (film_id, user_id, rating, created_at) VALUES (1, 1, 4, '2023-01-12'),        (1, 2, 5, '2023-02-11'),        (1, 3, 3, '2023-02-12'),        (1, 4, 4, '2023-01-01'),        (2, 1, 5, '2023-02-17'),        (2, 2, 4, '2023-02-01'),        (2, 3, 5, '2023-03-01'),        (3, 1, 4, '2023-02-22'),        (3, 2, 5, '2023-02-25'),        (3, 3, 4, '2023-02-20'),        (4, 4, 3, '2023-01-15'),        (4, 1, 4, '2023-01-16'),        (4, 2, 4, '2023-01-18'),        (4, 3, 5, '2023-01-20'),        (5, 4, 5, '2023-01-25'),        (5, 1, 4, '2023-01-26'),        (5, 2, 4, '2023-01-28'),        (5, 3, 5, '2023-01-30'),        (6, 1, 5, '2023-02-05'),        (6, 2, 4, '2023-02-10');","Напишите запрос, извлекающий из предложенной базы данных псевдоним пользователя, который оценил наибольшее количество фильмов. Если таких пользователей несколько, в результирующую таблицу должен быть добавлен тот, чей псевдоним в лексикографическом сравнении меньше.",15,4,"select username  from FilmRatings F left join Users U on F.user_id = U.id group by user_id order by count(*) desc, username limit 1","WITH Check_table AS (SELECT U.username AS username, COUNT(*) AS checck                     FROM Users AS U JOIN FilmRatings AS FR ON U.id = FR.user_id                     GROUP BY U.username) SELECT username FROM Check_table WHERE checck = (SELECT MAX(checck)                 FROM Check_table) ORDER BY username LIMIT 1",
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS FilmRatings; DROP TABLE IF EXISTS Users; DROP TABLE IF EXISTS Films;  -- Создание таблицы Films CREATE TABLE Films (     id    INT PRIMARY KEY AUTO_INCREMENT,     title VARCHAR(150) );  INSERT INTO Films (title) VALUES ('The Matrix'),        ('Inception'),        ('Interstellar'),        ('Pulp Fiction'),        ('The Shawshank Redemption'),        ('Fight Club'),        ('Forrest Gump'),        ('The Dark Knight'),        ('Gladiator'),        ('The Godfather'),        ('The Lord of the Rings'),        ('The Avengers'),        ('Titanic'),        ('Jurassic Park'),        ('Avatar'),        ('The Silence of the Lambs'),        ('Braveheart'),        ('The Departed'),        ('Schindler''s List'),        ('The Shawshank Redemption');  -- Создание таблицы Users CREATE TABLE Users (     id       INT PRIMARY KEY AUTO_INCREMENT,     username VARCHAR(100) );  INSERT INTO Users (username) VALUES ('JohnDoe'),        ('JaneSmith'),        ('MichaelJohnson'),        ('EmilyBrown'),        ('DavidWilson'),        ('SophiaDavis'),        ('OliverMiller'),        ('EmmaAnderson'),        ('LiamMartinez'),        ('AvaGarcia'),        ('LucasLopez'),        ('MilaHarris'),        ('EthanClark'),        ('IsabellaLewis'),        ('NoahYoung'),        ('SophiaAllen'),        ('LoganHall'),        ('OliviaWright'),        ('AidenGreen'),        ('ChloeTurner');  -- Создание таблицы FilmRatings CREATE TABLE FilmRatings (     film_id    INT,     user_id    INT,     rating     INT,     created_at DATE );  TRUNCATE FilmRatings; INSERT INTO FilmRatings (film_id, user_id, rating, created_at) VALUES (1, 1, 8, '2023-01-12'),        (1, 2, 5, '2023-02-11'),        (1, 3, 7, '2023-09-12'),        (1, 4, 7, '2023-09-02'),        (2, 1, 8, '2023-09-01'),        (2, 2, 8, '2023-06-01'),        (2, 3, 3, '2023-07-03'),        (2, 7, 5, '2023-09-03'),        (2, 5, 8, '2023-09-30'),        (3, 1, 4, '2023-08-22'),        (3, 2, 3, '2023-09-25'),        (3, 3, 5, '2023-10-20'),        (4, 4, 3, '2023-11-15'),        (4, 1, 3, '2023-12-16'),        (4, 2, 4, '2024-01-18'),        (4, 3, 3, '2024-02-20'),        (5, 4, 5, '2024-03-25'),        (5, 1, 3, '2024-04-26'),        (5, 2, 4, '2024-05-28'),        (5, 3, 3, '2024-06-30'),        (6, 1, 5, '2024-09-05'),        (6, 2, 1, '2024-08-10');"," Напишите запрос, извлекающий из предложенной базы данных название фильма, который имел самый высокий средний рейтинг среди оценок за сентябрь 2023 года. Если таких фильмов несколько, в результирующую таблицу должен быть добавлен тот, чье название в лексикографическом сравнении меньше.",20,4,"with A as (select (select title from Films         where id = FilmRatings.film_id) as title, avg(rating) as a from FilmRatings where month(created_at) = 9 and year(created_at) = 2023 group by film_id) select title from A where a = (select max(a) from A) order by title limit 1","SELECT title FROM Films INNER JOIN FilmRatings ON film_id = Films.id WHERE MONTH(created_at) = 9 AND YEAR(created_at) = 2023 GROUP BY title ORDER BY AVG(rating) DESC, title LIMIT 1",
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Calls; DROP TABLE IF EXISTS Countries; DROP TABLE IF EXISTS Persons;  -- Создание таблицы Persons CREATE TABLE Persons (     id           INT PRIMARY KEY AUTO_INCREMENT,     name         VARCHAR(50),     surname      VARCHAR(50),     phone_number VARCHAR(20) );  INSERT INTO Persons (name, surname, phone_number) VALUES ('Rupert', 'Murdoch', '7-1234567'),        ('Al', 'Gore', '7-7654321'),        ('Sacha', 'Baron', '4-1234567'),        ('George', 'Clooney', '4-6523651'),        ('Paul', 'Krugman', '660-1234567'),        ('Wright', 'BrothersOrville', '784-0011100'),        ('Ernest', 'Hemingway', '660-464-4851'),        ('Roman', 'Abramovich', '28-464-4852'),        ('Tom', 'Cruise', '28-464-4853'),        ('Lech', 'Walesa', '28-464-4854'),        ('Tim', 'Berners', '8-464-4855'),        ('Aung', 'San', '8-578-3000'),        ('Lance', 'Armstrong', '8-207-2222'),        ('Shakira', 'Curie', '28-427-4791'),        ('Jon', 'Stewart', '51-426-9404'),        ('Julie', 'Andrews', '51-881-3100'),        ('Florence', 'Nightingale', '51-782-4177'),        ('Marie', 'Curie', '24-567-3611'),        ('Stephen', 'Hawking', '24-687-8992'),        ('Jimmy', 'Wales', '24-446-3501');  -- Создание таблицы Countries CREATE TABLE Countries (     name         VARCHAR(50),     country_code INT );  INSERT INTO Countries VALUES ('Russia', 7),        ('United Arab Emirates', 784),        ('Afghanistan', 4),        ('Antigua and Barbuda', 28),        ('Anguilla', 660),        ('Albania', 8),        ('Armenia', 51),        ('Angola', 24);  -- Создание таблицы Calls CREATE TABLE Calls (     caller_id INT,     callee_id INT,     duration  INT );  TRUNCATE Calls; INSERT INTO Calls VALUES (17, 6, 21),        (10, 17, 23),        (7, 8, 452),        (5, 2, 356),        (8, 10, 99),        (17, 8, 186),        (20, 14, 277),        (12, 14, 113),        (7, 19, 72),        (5, 8, 59),        (12, 6, 62),        (20, 19, 131),        (14, 11, 488),        (5, 12, 232),        (18, 16, 334),        (17, 4, 425),        (8, 2, 127),        (2, 10, 338),        (12, 3, 183),        (8, 13, 31); ","Напишите запрос, извлекающий из предложенной базы данных названия стран, средняя продолжительность звонков в которых больше средней продолжительности звонков по всем странам.    Примечание 1. Средняя продолжительность звонков по всем странам вычисляется следующим образом:  21 + 23 + 452 + . . . + 338 + 183 + 31 20 = 200.45 20 21+23+452+...+338+183+31 ​  =200.45 Например, Россия попадает в результирующую таблицу, поскольку средняя продолжительность звонков по этой стране равна: 356 + 127 + 338 3 = 273.67 3 356+127+338 ​  =273.67 Примечание 2. Если звонок осуществляется в рамках одной страны, то он должен учитываться дважды — и как входящий, и как исходящий.  Примечание 3. Записи в результирующей таблице могут быть расположены в произвольном порядке.",120,9,"with A as ( select caller_id as user_id, duration from Calls union all select callee_id, duration from Calls ),  B as (select C.name, A.duration from A left join Persons P1 on P1.id = A.user_id left join Countries C on substring_index(P1.phone_number, '-', 1) = C.country_code ) select count(*)  from B","SELECT Countries.name FROM Persons INNER JOIN Countries ON SUBSTRING_INDEX(phone_number, '-', 1) = country_code INNER JOIN Calls ON Persons.id = Calls.caller_id OR Persons.id = Calls.callee_id GROUP BY Countries.name HAVING AVG(duration) > (SELECT AVG(duration) FROM Calls)",
12.4. Задачи. Группировка,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Products; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Customers (name, surname) VALUES ('Rupert', 'Murdoch'),        ('Al', 'Gore'),        ('Sacha', 'Baron'),        ('George', 'Clooney'),        ('Paul', 'Krugman'),        ('Wright', 'BrothersOrville'),        ('Ernest', 'Hemingway'),        ('Roman', 'Abramovich'),        ('Tom', 'Cruise'),        ('Lech', 'Walesa'),        ('Tim', 'Berners'),        ('Aung', 'San'),        ('Lance', 'Armstrong'),        ('Shakira', 'Curie'),        ('Jon', 'Stewart'),        ('Julie', 'Andrews'),        ('Florence', 'Nightingale'),        ('Marie', 'Curie'),        ('Stephen', 'Hawking'),        ('Jimmy', 'Wales');  -- Создание таблицы Products CREATE TABLE Products (     id    INT PRIMARY KEY AUTO_INCREMENT,     name  VARCHAR(50),     price INT );  INSERT INTO Products VALUES (10, 'Instant Pot Duo 7-in-1', 150),        (20, 'Dyson V11 Animal Vacuum', 500),        (30, 'GoPro HERO9 Black', 400),        (40, 'Amazon Echo Dot (4th Gen)', 50),        (50, 'Xbox Series X', 500),        (60, 'PlayStation 5', 600),        (70, 'Fitbit Versa 3', 200),        (80, 'Apple AirPods Pro', 250),        (90, 'LG OLED55CXPUA TV', 1200),        (100, 'Samsung 65-inch QLED TV', 1000);  -- Создание таблицы Orders CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT,     product_id  INT,     order_date  DATE,     quantity    INT,     FOREIGN KEY (customer_id) REFERENCES Customers (id),     FOREIGN KEY (product_id) REFERENCES Products (id) );  TRUNCATE Orders; INSERT INTO Orders (customer_id, product_id, order_date, quantity) VALUES (15, 90, '2023-10-24', 1),        (7, 10, '2023-09-11', 8),        (6, 10, '2023-06-07', 10),        (9, 80, '2023-08-31', 3),        (11, 20, '2023-08-17', 8),        (14, 20, '2023-08-15', 6),        (5, 50, '2023-09-13', 2),        (4, 10, '2023-07-24', 6),        (19, 30, '2023-05-19', 3),        (18, 10, '2023-08-17', 1),        (4, 30, '2023-05-11', 1),        (18, 40, '2023-06-18', 10),        (6, 20, '2023-06-14', 8),        (2, 90, '2023-08-13', 10),        (13, 70, '2023-06-05', 9),        (14, 100, '2023-10-19', 2),        (9, 40, '2023-09-15', 1),        (17, 100, '2023-05-18', 1),        (16, 100, '2023-07-19', 2),        (5, 40, '2023-08-01', 2),        (11, 10, '2023-09-07', 1),        (8, 20, '2023-05-01', 6),        (7, 10, '2023-10-17', 1),        (7, 10, '2023-08-23', 2),        (17, 50, '2023-07-16', 8),        (18, 40, '2023-09-12', 6); ","Напишите запрос, извлекающий из предложенной базы данных имена и фамилии пользователей, которые потратили хотя бы 150 долларов в августе 2023 года и хотя бы 150 долларов в сентябре того же года.",40,7,"SELECT name, surname FROM Customers WHERE id IN (SELECT customer_id              FROM Orders INNER JOIN Products ON product_id = Products.id              WHERE order_date BETWEEN '2023-08-01' AND '2023-08-31'              GROUP BY customer_id              HAVING SUM(quantity * price) >= 150)   AND id IN (SELECT customer_id              FROM Orders INNER JOIN Products ON product_id = Products.id              WHERE order_date BETWEEN '2023-09-01' AND '2023-09-30'              GROUP BY customer_id              HAVING SUM(quantity * price) >= 150)","select name, surname  from  (select customer_id, quantity * (select price from Products                                  where id = Orders.product_id) as ta from Orders                                                         where month(order_date) = 8) as O1 join (select customer_id, quantity * (select price from Products                                       where id = Orders.product_id) as ts from Orders                                                        where month(order_date) = 9) as O2 on O1.customer_id = O2.customer_id and ta >= 150 and ts >= 150 join Customers  on id = O1.customer_id",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Teams; DROP TABLE IF EXISTS Employees;  -- Создание таблицы Employees CREATE TABLE Employees (     id               INT PRIMARY KEY AUTO_INCREMENT,     name             VARCHAR(50),     surname          VARCHAR(50),     experience_years INT );  INSERT INTO Employees (name, surname, experience_years) VALUES ('George', 'Clooney', 1),        ('Paul', 'Krugman', 1),        ('Wright', 'BrothersOrville', 1),        ('Ernest', 'Hemingway', 2),        ('Roman', 'Abramovich', 5),        ('Tom', 'Cruise', 4),        ('Lech', 'Walesa', 3),        ('Tim', 'Berners', 5),        ('Aung', 'San', 4),        ('Lance', 'Armstrong', 2),        ('Shakira', 'Curie', 5),        ('Jon', 'Stewart', 2),        ('Julie', 'Andrews', 5),        ('Florence', 'Nightingale', 2),        ('Marie', 'Curie', 4),        ('Stephen', 'Hawking', 1),        ('Jimmy', 'Wales', 2),        ('Rupert', 'Murdoch', 5),        ('Al', 'Gore', 4),        ('Sacha', 'Baron', 3);  -- Создание таблицы Teams CREATE TABLE Teams (     project_id  INT,     employee_id INT,     FOREIGN KEY (employee_id) REFERENCES Employees (id) );  TRUNCATE Teams; INSERT INTO Teams (project_id, employee_id) VALUES (1, 20),        (1, 4),        (1, 15),        (1, 9),        (1, 14),        (2, 17),        (2, 16),        (2, 11),        (2, 7),        (2, 6),        (2, 5),        (2, 8),        (3, 1),        (3, 3),        (3, 2),        (3, 10),        (3, 12),        (4, 13),        (4, 18),        (4, 19);","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех проектов, а также определяет средний опыт работы (в годах) сотрудников, работающих над каждым проектом.",10,3,"select project_id, round(avg(experience_years), 2) as average_years  from Teams join Employees on employee_id = Employees.id group by project_id","select project_id, round(avg((select experience_years from Employees                              where id = Teams.employee_id)), 2) as average_years  from Teams group by project_id",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     player_id    INT,     event_date   DATE,     games_played INT );  TRUNCATE Activity; INSERT INTO Activity VALUES (4, '2023-01-05', 3),        (4, '2023-04-10', 2),        (6, '2023-06-15', 7),        (6, '2023-02-20', 1),        (7, '2023-03-25', 4),        (7, '2023-05-02', 0),        (10, '2023-08-15', 6),        (10, '2023-01-10', 8),        (11, '2023-11-22', 2),        (10, '2023-07-03', 5),        (10, '2023-02-28', 3),        (11, '2023-07-15', 1),        (10, '2023-12-12', 0),        (11, '2023-05-20', 9),        (11, '2023-09-08', 4),        (12, '2023-11-01', 7),        (22, '2023-06-30', 2),        (22, '2023-12-18', 6),        (22, '2023-10-05', 3),        (23, '2023-07-08', 5);","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех игроков, а также определяет, когда каждый игрок впервые вошел в игру.",5,1,"select player_id, min(event_date) as first_login from Activity group by player_id",,
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Logins; CREATE TABLE Logins (     user_id    INT,     time_stamp DATETIME );  TRUNCATE Logins; INSERT INTO Logins VALUES (7, '2022-11-12 18:30:45'),        (7, '2021-08-03 09:15:20'),        (7, '2020-06-22 22:48:12'),        (2, '2022-12-15 05:34:28'),        (2, '2023-03-05 15:20:10'),        (12, '2021-05-20 14:00:00'),        (4, '2023-04-09 12:30:45'),        (12, '2020-09-10 07:15:30'),        (12, '2022-02-08 18:10:05'),        (2, '2021-10-15 16:45:20'),        (17, '2021-04-18 21:40:00'),        (17, '2022-01-02 03:30:15'),        (12, '2020-07-01 10:25:30'),        (22, '2023-06-05 19:55:12'),        (2, '2023-11-30 14:00:00'),        (22, '2020-09-22 08:12:45'),        (24, '2023-03-12 20:30:10'),        (24, '2022-12-18 13:45:20'),        (24, '2023-08-05 17:10:30'),        (17, '2021-06-10 22:20:15');","Напишите запрос, который извлекает из предложенной базы данных идентификаторы пользователей, а также определяет, когда каждый пользователь последний раз вошел в аккаунт в 2023 году. При этом в результирующую таблицу должны быть добавлены только те пользовали, которые в 2023 году входили в аккаунт хотя бы раз.",10,2,"select user_id, max(time_stamp) as last_stamp  from Logins where year(time_stamp) = 2023 group by user_id",,
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id          INT PRIMARY KEY AUTO_INCREMENT,     customer_id INT );  TRUNCATE Orders; INSERT INTO Orders (customer_id) VALUES (10),        (7),        (7),        (1),        (19),        (7),        (13),        (10),        (7),        (2),        (11),        (10),        (11),        (12),        (10),        (9),        (10),        (9),        (10),        (3); ","Напишите запрос, извлекающий из предложенной базы данных идентификатор пользователя, который совершил наибольшее количество заказов.",10,2,select customer_id  from Orders group by customer_id order by count(*) desc limit 1,,
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     emp_id    INT,     event_day DATE,     in_time   INT,     out_time  INT );  TRUNCATE Employees; INSERT INTO Employees (emp_id, event_day, in_time, out_time) VALUES (1, '2023-01-05', 18, 300),        (1, '2023-01-05', 500, 1300),        (1, '2023-01-06', 120, 1440),        (2, '2023-01-05', 60, 1250),        (2, '2023-01-06', 30, 1250),        (2, '2023-01-07', 60, 850),        (3, '2023-01-05', 43, 1302),        (3, '2023-01-06', 25, 1303),        (3, '2023-01-07', 42, 1301),        (4, '2023-01-05', 42, 850),        (4, '2023-01-06', 120, 1250),        (4, '2023-01-07', 25, 1308),        (5, '2023-01-05', 42, 439),        (5, '2023-01-05', 600, 850),        (5, '2023-01-06', 43, 1250),        (6, '2023-01-05', 25, 279),        (6, '2023-01-05', 320, 600),        (6, '2023-01-05', 801, 1440),        (6, '2023-01-06', 124, 850),        (7, '2023-01-05', 27, 1250),        (7, '2023-01-06', 125, 1300); ","Напишите запрос, который определяет общее время в минутах, затраченное каждым сотрудником в каждый день работы в офисе.",10,2,"select emp_id, event_day, sum(out_time - in_time) as total_time from Employees group by emp_id, event_day",,
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Queries; CREATE TABLE Queries (     query_name VARCHAR(50),     result     VARCHAR(50),     position   INT,     rating     INT );  TRUNCATE Queries; INSERT INTO Queries VALUES ('Elephant', 'African Elephant', 1, 4),        ('Elephant', 'Indian Elephant', 2, 4),        ('Elephant', 'Mammoth', 10, 5),        ('Elephant', 'Woolly Mammoth', 15, 5),        ('Elephant', 'Elephant Seal', 25, 1),        ('Lion', 'African Lion', 1, 5),        ('Lion', 'Asiatic Lion', 3, 4),        ('Lion', 'Mountain Lion', 6, 3),        ('Lion', 'Sea Lion', 12, 2),        ('Lion', 'Lionfish', 18, 1),        ('Bear', 'Grizzly Bear', 1, 5),        ('Bear', 'Polar Bear', 2, 2),        ('Bear', 'Brown Bear', 4, 2),        ('Bear', 'Panda Bear', 8, 2),        ('Bear', 'Koala Bear', 15, 1),        ('Tiger', 'Bengal Tiger', 1, 5),        ('Tiger', 'Siberian Tiger', 2, 5),        ('Tiger', 'White Tiger', 5, 3),        ('Tiger', 'Tiger Shark', 10, 1),        ('Tiger', 'Tiger Lily', 20, 1); ","Напишите запрос, который извлекает из предложенной базы данных все поисковые запросы, а также определяет качество каждого запроса и процент низкокачественных запросов.",15,3,"select query_name, round(avg(rating/position), 2) as quality, round((sum(if(rating < 3, 1, 0))/count(*))*100, 2) as poor_query_percentage   from Queries group by query_name","SELECT  query_name,    ROUND(SUM(rating / position) / COUNT(*), 2) quality,          ROUND(SUM(rating < 3) / COUNT(*) * 100, 2) poor_query_percentage FROM Queries GROUP BY 1",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id            INT,     department_id INT,     primary_flag  VARCHAR(3) );  TRUNCATE Employees; INSERT INTO Employees (id, department_id, primary_flag) VALUES (1, 1, 'no'),        (2, 1, 'yes'),        (2, 2, 'no'),        (3, 3, 'no'),        (4, 2, 'no'),        (4, 3, 'yes'),        (4, 4, 'no'),        (5, 1, 'no'),        (6, 2, 'no'),        (7, 3, 'no'),        (8, 4, 'no'),        (9, 1, 'no'),        (10, 2, 'no'),        (11, 3, 'no'),        (11, 4, 'yes'),        (12, 1, 'no'),        (12, 2, 'yes'),        (12, 3, 'no'),        (13, 4, 'yes'),        (13, 1, 'no'); ","Каждый сотрудник может работать как в одном отделе, так и в нескольких. Если сотрудник работает в нескольких отделах, один из его отделов считается основным. Определяется основной отдел сотрудника полем primary_flag: значение yes говорит о том, что отдел является основным для сотрудника, значение no — не основным. Если сотрудник работает лишь в одном отделе, значением поля primary_flag является no.  Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех сотрудников, а также определяет идентификатор основного отдела каждого сотрудника. Если сотрудник работает лишь в одном отделе, идентификатором его основного отдела должен быть идентификатор того отдела, в котором он работает.",20,4,"select id as employee_id, department_id as primary_department_id from Employees as E where id in (select id from Employees              where id = E.id              group by id              having count(*) = 1) union  select id, department_id from Employees  where primary_flag = 'yes'","SELECT id AS employee_id,        department_id AS primary_department_id FROM Employees AS Emp WHERE primary_flag = 'yes' OR (SELECT COUNT(*)                                 FROM Employees                                 WHERE Emp.id = Employees.id) = 1","SELECT id AS employee_id, IF(COUNT(*) = 1, MAX(department_id), MAX(IF(primary_flag = 'yes', department_id, 0))) AS primary_department_id FROM Employees GROUP BY id"
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Sales; CREATE TABLE Sales (     sale_date DATE,     fruit     VARCHAR(10),     sold_num  INT );  TRUNCATE Sales; INSERT INTO Sales VALUES ('2023-01-01', 'apple', 12),        ('2023-01-01', 'orange', 10),        ('2023-01-02', 'apple', 15),        ('2023-01-02', 'orange', 18),        ('2023-01-03', 'apple', 20),        ('2023-01-03', 'orange', 5),        ('2023-01-04', 'apple', 14),        ('2023-01-04', 'orange', 16),        ('2023-01-05', 'apple', 18),        ('2023-01-05', 'orange', 20),        ('2023-01-06', 'apple', 10),        ('2023-01-06', 'orange', 12),        ('2023-01-07', 'apple', 16),        ('2023-01-07', 'orange', 8),        ('2023-01-08', 'apple', 12),        ('2023-01-08', 'orange', 10),        ('2023-01-09', 'apple', 14),        ('2023-01-09', 'orange', 6),        ('2023-01-10', 'apple', 20),        ('2023-01-10', 'orange', 22); "," Напишите запрос, который извлекает из предложенной базы данных все даты продаж, а также для каждой даты определяет разницу между количеством проданных апельсинов и количеством проданных яблок.  Поле с разницей между количествами проданных фруктов должно иметь псевдоним diff.",30,6," select distinct S.sale_date, abs(ifnull(So.sold_num, 0) - ifnull(Sa.sold_num, 0)) as diff from Sales S left join (select sale_date, sold_num from Sales                     where fruit = 'orange') as So on S.sale_date = So.sale_date left join (select sale_date, sold_num from Sales                     where fruit = 'apple') as Sa on S.sale_date = Sa.sale_date  ","SELECT sale_date,        ABS(SUM(IF(fruit = 'orange', sold_num, -sold_num))) AS diff FROM Sales GROUP BY sale_date",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Warehouse; DROP TABLE IF EXISTS Products;  -- Создание таблицы Products CREATE TABLE Products (     id      INT PRIMARY KEY AUTO_INCREMENT,     product VARCHAR(255),     width   DECIMAL(5, 2),     length  DECIMAL(5, 2),     height  DECIMAL(5, 2) );  INSERT INTO Products (product, width, length, height) VALUES ('Laptop', 15, 10, 1),        ('Smartphone', 3, 6, 0.5),        ('Headphones', 6, 3, 2),        ('T-shirt', 18, 12, 1),        ('Sunglasses', 6, 2.5, 1.5),        ('Watch', 2, 2, 0.5),        ('Backpack', 12, 18, 6),        ('Mouse', 3, 4, 1),        ('Keyboard', 12, 6, 1),        ('Jacket', 20, 15, 2),        ('Umbrella', 5, 5, 12),        ('Sunglasses', 5.5, 2.2, 1.8),        ('Hat', 7, 7, 3),        ('Wallet', 4, 3.5, 0.8),        ('Shoes', 12, 5, 4),        ('Tablet', 10, 8, 0.5),        ('Charger', 2.5, 1.5, 1),        ('Gloves', 3, 8, 0.5),        ('Scarf', 10, 5, 0.2),        ('Belt', 4, 2, 0.1);  -- Создание таблицы Warehouse CREATE TABLE Warehouse (     name       VARCHAR(255),     product_id INT,     units      INT );  TRUNCATE Warehouse; INSERT INTO Warehouse VALUES ('Somerset Fulfillment Center', 1, 3),        ('Somerset Fulfillment Center', 2, 8),        ('Somerset Fulfillment Center', 3, 6),        ('Bowling Green Warehouse', 2, 5),        ('Bowling Green Warehouse', 4, 2),        ('Lansing Fulfillment Center', 1, 2),        ('Lansing Fulfillment Center', 3, 4),        ('Gatlinburg Warehouse', 4, 3),        ('Gatlinburg Warehouse', 5, 5),        ('Lansing Storage Warehouse', 1, 7),        ('Lansing Storage Warehouse', 2, 10),        ('Knoxville Fulfillment Center', 5, 3),        ('Knoxville Fulfillment Center', 6, 1),        ('Memphis Fulfillment Center', 1, 5),        ('Memphis Fulfillment Center', 4, 6),        ('Ann Arbor Fulfillment Center', 3, 7),        ('Ann Arbor Fulfillment Center', 6, 3),        ('Frankfort Fulfillment Center', 5, 2),        ('Frankfort Fulfillment Center', 6, 4),        ('Clarsvill Warehouse', 7, 2); ","Напишите запрос, который извлекает из предложенной базы данных названия всех складов, а также определяет суммарный объем находящихся на каждом складе товаров.  Поле с названием склада должно иметь псевдоним warehouse_name, поле с суммарным объемом находящихся на складе товаров — volume. Значения в поле volume должны быть округлены до 2 знаков после запятой.",25,5,"select name as warehouse_name, round(sum(units*width*length*height), 2) as  volume from Warehouse  join Products on Warehouse.product_id = Products.id group by warehouse_name",,
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Sales; DROP TABLE IF EXISTS Prices;  -- Создание таблицы Prices CREATE TABLE Prices (     product_id INT,     product    VARCHAR(100),     start_date DATE,     end_date   DATE,     price      DECIMAL(10, 2) );  INSERT INTO Prices VALUES (3, 'Sony WH-1000XM4 Headphones', '2023-10-24', '2023-11-03', 10),        (4, 'Nike Air Zoom Pegasus 38', '2023-09-11', '2023-09-21', 20),        (2, 'Canon EOS R6 Camera', '2023-06-07', '2023-06-17', 40),        (4, 'Nike Air Zoom Pegasus 38', '2023-08-17', '2023-08-27', 10),        (1, 'Dyson V11 Animal Vacuum', '2023-08-15', '2023-08-25', 50),        (3, 'Sony WH-1000XM4 Headphones', '2023-07-24', '2023-08-03', 10),        (3, 'Sony WH-1000XM4 Headphones', '2023-05-19', '2023-05-29', 80),        (5, 'Fitbit Versa 3', '2023-05-11', '2023-05-21', 10),        (3, 'Sony WH-1000XM4 Headphones', '2023-06-18', '2023-06-28', 50),        (1, 'Dyson V11 Animal Vacuum', '2023-06-14', '2023-06-24', 30),        (5, 'Fitbit Versa 3', '2023-08-13', '2023-08-23', 100),        (4, 'Nike Air Zoom Pegasus 38', '2023-06-05', '2023-06-15', 60),        (1, 'Dyson V11 Animal Vacuum', '2023-10-19', '2023-10-29', 60),        (2, 'Canon EOS R6 Camera', '2023-05-18', '2023-05-28', 10),        (3, 'Sony WH-1000XM4 Headphones', '2023-07-10', '2023-07-20', 300),        (6, 'Samsung 65-inch QLED TV', '2023-06-01', '2023-06-11', 70),        (1, 'Dyson V11 Animal Vacuum', '2023-10-30', '2023-11-03', 50),        (5, 'Fitbit Versa 3', '2023-08-24', '2023-09-02', 40),        (5, 'Fitbit Versa 3', '2023-07-16', '2023-07-26', 80),        (4, 'Nike Air Zoom Pegasus 38', '2023-10-12', '2023-10-22', 10);  -- Создание таблицы Sales CREATE TABLE Sales (     product_id INT,     sale_date  DATE,     amount     INT );  TRUNCATE Sales; INSERT INTO Sales VALUES (1, '2023-10-24', 4),        (1, '2023-11-01', 5),        (1, '2023-10-29', 2),        (2, '2023-06-08', 6),        (2, '2023-05-21', 1),        (2, '2023-06-16', 3),        (3, '2023-10-25', 4),        (3, '2023-07-11', 10),        (3, '2023-11-01', 2),        (4, '2023-10-12', 12),        (4, '2023-06-10', 8),        (4, '2023-08-18', 6),        (5, '2023-05-15', 4),        (5, '2023-06-10', 3),        (5, '2023-07-18', 17); ","Напишите запрос, который извлекает из предложенной базы данных названия всех товаров, а также определяет среднюю стоимость продажи каждого товара.  Поле со средней стоимостью продажи товара должно иметь псевдоним average_selling_price. Значения в поле average_selling_price должны быть округлены до 2 знаков после запятой.",25,5,"select product, ifnull(round(sum(amount*price)/sum(amount), 2), 0.00) as average_selling_price from Sales  right join Prices on Sales.product_id = Prices.product_id and Sales.sale_date between Prices.start_date  and Prices.end_date where product is not null group by product","SELECT product,        COALESCE(ROUND(SUM(price * amount) / SUM(amount), 2), 0) average_selling_price FROM Prices P LEFT JOIN Sales S ON P.product_id = S.product_id                                 AND S.sale_date BETWEEN P.start_date AND P.end_date GROUP BY product",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Registers; DROP TABLE IF EXISTS Users;  -- Создание таблицы Users CREATE TABLE Users (     id       INT PRIMARY KEY AUTO_INCREMENT,     username VARCHAR(60) );  INSERT INTO Users (username) VALUES ('John'),        ('Emma'),        ('Michael'),        ('Olivia'),        ('William'),        ('Sophia'),        ('Liam'),        ('Ava'),        ('James'),        ('Charlotte'),        ('Benjamin'),        ('Mia'),        ('Henry'),        ('Ella'),        ('Alexander'),        ('Grace'),        ('Daniel'),        ('Scarlett'),        ('Joseph'),        ('Lily');  -- Создание таблицы Registers CREATE TABLE Registers (     course_id INT,     user_id   INT );  TRUNCATE Registers; INSERT INTO Registers VALUES (101, 1),        (102, 2),        (101, 3),        (102, 4),        (101, 5),        (103, 6),        (102, 7),        (104, 8),        (101, 9),        (102, 10),        (103, 11),        (101, 12),        (103, 13),        (101, 14),        (102, 15),        (101, 16),        (103, 17),        (101, 18),        (102, 19),        (101, 20); ","Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех курсов, а также определяет процент студентов, записавшихся на каждый курс.  Поле с процентом записавшихся на курс студентов должно иметь псевдоним percentage. Значения в поле percentage должны быть округлены до 2 знаков после запятой.  Записи в результирующей таблице должны быть расположены в порядке убывания значения поля percentage, при совпадении — в порядке возрастания значения поля course_id.",15,3,"select course_id, round(count(*)/(select max(id) from Users)*100,2) as percentage from Registers group by course_id order by course_id","SELECT course_id, ROUND(COUNT(user_id) / (SELECT COUNT(*) FROM Users) * 100, 2) AS percentage FROM Users INNER JOIN Registers ON user_id = Users.id GROUP BY course_id",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Calls; CREATE TABLE Calls (     from_id  INT,     to_id    INT,     duration INT );  TRUNCATE Calls; INSERT INTO Calls VALUES (2, 1, 45),        (1, 3, 30),        (3, 2, 15),        (4, 1, 60),        (2, 4, 75),        (4, 3, 90),        (1, 2, 120),        (3, 1, 30),        (4, 2, 25),        (1, 4, 50),        (2, 3, 40),        (4, 2, 55),        (3, 1, 65),        (2, 4, 70),        (1, 3, 80),        (3, 2, 95),        (4, 1, 110),        (2, 1, 125),        (1, 2, 140),        (3, 4, 155); ","Напишите запрос, который определяет количество звонков между каждой парой пользователей с идентификаторами id1 и id2, где id1 < id2, и их суммарную продолжительность.  Поле с идентификатором первого пользователя должно иметь псевдоним person1, с идентификатором второго пользователя — person2, с количеством звонков — call_count, с суммарной продолжительностью звонков — total_duration.",30,6,"select person1, person2, count(*) as call_count, sum(duration) as total_duration  from (select from_id as person1, to_id as person2, duration from Calls union all select to_id, from_id, duration from Calls) as T where person1 < person2 group by 1, 2","WITH AllPairs AS (     SELECT LEAST(from_id, to_id) AS person1,             GREATEST(from_id, to_id) AS person2,            duration     FROM Calls ) SELECT person1, person2, COUNT(*) AS call_count, SUM(duration) AS total_duration FROM AllPairs WHERE person1 < person2 GROUP BY person1, person2","SELECT IF(from_id < to_id, from_id, to_id) AS person1,         IF(from_id < to_id, to_id, from_id) AS person2,        COUNT(*) AS call_count,        SUM(duration) AS total_duration FROM Calls GROUP BY person1, person2;"
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Activity; CREATE TABLE Activity (     player_id    INT,     event_date   DATE,     games_played INT );  TRUNCATE Activity; INSERT INTO Activity VALUES (4, '2023-01-05', 3),        (5, '2023-01-06', 2),        (5, '2023-01-07', 7),        (5, '2023-01-08', 1),        (8, '2023-01-09', 4),        (9, '2023-01-10', 0),        (10, '2023-01-11', 6),        (10, '2023-01-12', 8),        (12, '2023-01-13', 2),        (13, '2023-01-14', 5),        (14, '2023-01-15', 3),        (15, '2023-01-16', 1),        (16, '2023-01-17', 0),        (11, '2023-01-19', 4),        (10, '2023-01-20', 7),        (12, '2023-01-21', 2),        (12, '2023-01-22', 6),        (13, '2023-01-23', 3),        (13, '2023-01-24', 5),        (14, '2023-01-25', 4),        (14, '2023-01-25', 5),        (15, '2023-01-26', 2),        (15, '2023-01-26', 3),        (10, '2023-01-27', 1),        (16, '2023-01-27', 0); ","Напишите запрос, определяющий процент игроков, которые заходили в игру как минимум 2 дня подряд, и указывающий полученное значение в поле с псевдонимом players. Значение в поле players должно быть округлено до 2 знаков после запятой.",30,5,"select round(count(distinct A1.player_id)/(select count(distinct player_id) from Activity) * 100, 2) as players from Activity A1 join Activity A2 on A1.player_id = A2.player_id and A1.event_date = A2.event_date - interval 1 day","SELECT     ROUND(COUNT(DISTINCT A1.player_id) / (SELECT COUNT(DISTINCT player_id)                                            FROM Activity) * 100, 2) AS players FROM     Activity AS A1 JOIN Activity AS A2                     ON A1.player_id = A2.player_id                     AND DATEDIFF(A1.event_date, A2.event_date) = 1",
12.5. Задачи.  Агрегатные функции,"DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id                          INT PRIMARY KEY,     customer_id                 INT,     order_date                  DATE,     customer_pref_delivery_date DATE );  TRUNCATE Orders; INSERT INTO Orders VALUES (8, 5, '2023-01-15', '2023-01-15'),        (9, 6, '2023-01-20', '2023-01-20'),        (10, 5, '2023-02-02', '2023-02-03'),        (11, 7, '2023-02-10', '2023-02-12'),        (12, 8, '2023-02-20', '2023-02-20'),        (13, 6, '2023-03-05', '2023-03-07'),        (14, 9, '2023-03-12', '2023-03-12'),        (15, 10, '2023-03-18', '2023-03-20'),        (16, 7, '2023-04-01', '2023-04-01'),        (17, 10, '2023-04-05', '2023-04-05'),        (18, 8, '2023-04-10', '2023-04-11'),        (19, 11, '2023-05-02', '2023-05-02'),        (20, 11, '2023-05-10', '2023-05-10'),        (21, 9, '2023-05-15', '2023-05-15'),        (22, 12, '2023-06-01', '2023-06-03'),        (23, 13, '2023-06-08', '2023-06-09'),        (24, 12, '2023-06-15', '2023-06-16'),        (25, 14, '2023-06-20', '2023-06-20'),        (26, 15, '2023-07-05', '2023-07-05'),        (27, 13, '2023-07-10', '2023-07-12'); ","Заказ называется немедленным, если предпочтительная дата доставки совпадает с датой заказа, в противном случае заказ называется запланированным. Также каждый покупатель может иметь несколько заказов, и заказ с самой ранней датой называется первым заказом покупателя.  Напишите запрос, который определяет процент немедленных заказов среди всех первых заказов покупателей и указывает полученное значение в поле с псевдонимом immediate_percentage. Значение в поле immediate_percentage должно быть округлено до 2 знаков после запятой.",40,6,"select round(count(customer_id)/(select count(distinct customer_id) from Orders)*100, 2) as immediate_percentage from Orders where (customer_id, order_date) in (select customer_id, min(order_date) as first from Orders group by customer_id) and customer_pref_delivery_date = order_date","WITH FirstOrders AS (     SELECT customer_id, MIN(order_date) AS first_order_date     FROM Orders     GROUP BY customer_id )  SELECT ROUND(SUM(order_date = customer_pref_delivery_date) /               COUNT(*) * 100, 2) AS immediate_percentage FROM FirstOrders INNER JOIN Orders ON FirstOrders.customer_id = Orders.customer_id        AND first_order_date = order_date",
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Numbers; CREATE TABLE Numbers (     id  INT AUTO_INCREMENT PRIMARY KEY,     num INT );  TRUNCATE Numbers; INSERT INTO Numbers (num) VALUES (1),        (3),        (2),        (2),        (1),        (4),        (4),        (3),        (2),        (5),        (5),        (5),        (5),        (1),        (1),        (1),        (2),        (8),        (2),        (2);","Напишите запрос, извлекающий из предложенной базы данных числа, которые встречаются хотя бы 3 раза подряд.  ",10,3,select distinct N3.num from Numbers N1 join Numbers N2 on N1.id = N2.id - 1 and N1.num = N2.num join Numbers N3 on N2.id = N3.id - 1 and N1.num = N3.num,SELECT DISTINCT n1.num FROM Numbers n1 JOIN Numbers n2 JOIN Numbers n3 ON n1.id + 1 = n2.id AND n2.id + 1 = n3.id     AND n1.num = n2.num AND n2.num = n3.num,
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Cinema; CREATE TABLE Cinema (     seat_id INT PRIMARY KEY AUTO_INCREMENT,     free    INT );  TRUNCATE Cinema; INSERT INTO Cinema (free) VALUES     (0),     (0),     (1),     (0),     (1),     (1),     (0),     (1),     (0),     (0),     (0),     (1),     (1),     (1),     (0),     (0),     (0),     (0),     (1),     (1);","Напишите запрос, извлекающий из предложенной базы данных идентификаторы мест, которые свободны подряд.  Записи в результирующей таблице должны быть расположены в порядке возрастания значения поля seat_id.",30,5,select C1.seat_id from Cinema C1 join Cinema C2 on C1.seat_id + 1 = C2.seat_id and C1.free = 0 and C2.free = 0 union  select C1.seat_id from Cinema C1 join Cinema C2 on C1.seat_id = C2.seat_id + 1 and C1.free = 0 and C2.free = 0 order by seat_id,SELECT DISTINCT FreeSeats.seat_id FROM Cinema AS FreeSeats INNER JOIN Cinema ON ABS(FreeSeats.seat_id - Cinema.seat_id) = 1 WHERE FreeSeats.free = 0 AND Cinema.free = 0 ORDER BY FreeSeats.seat_id,
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Points; CREATE TABLE Points (     x INT );  TRUNCATE Points; INSERT INTO Points (x) VALUES (-1),        (0),        (2),        (4),        (7),        (9),        (-3),        (6),        (1),        (5),        (3),        (8),        (-2),        (10),        (-5),        (11),        (-4),        (12),        (13),        (-6);","Напишите запрос, который определяет наименьшее расстояние между двумя любыми точками и указывает полученное значение в поле с псевдонимом shortest.",10,4,select min(abs(P1.x - P2.x)) as shortest from Points P1 cross join Points P2 on P1.x != P2.x,"SELECT MIN(ABS(a.x - b.x)) AS shortest FROM Points AS a, Points AS b WHERE a.X != b.x",
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS LogInfo; CREATE TABLE LogInfo (     account_id INT,     ip_address INT,     login      DATETIME,     logout     DATETIME );  TRUNCATE LogInfo; INSERT INTO LogInfo (account_id, ip_address, login, logout) VALUES (1, 1, '2023-09-13 08:00:00', '2023-09-13 10:00:00'),        (1, 2, '2023-09-13 09:30:00', '2023-09-13 10:30:00'),        (2, 3, '2023-09-13 08:15:00', '2023-09-13 09:45:00'),        (2, 4, '2023-09-13 10:00:00', '2023-09-13 11:00:00'),        (3, 5, '2023-09-13 08:30:00', '2023-09-13 10:30:00'),        (3, 6, '2023-09-14 10:15:00', '2023-09-14 11:45:00'),        (4, 7, '2023-09-14 10:45:00', '2023-09-14 11:00:00'),        (4, 8, '2023-09-14 10:20:00', '2023-09-14 11:30:00'),        (5, 9, '2023-09-15 08:10:00', '2023-09-15 09:20:00'),        (5, 10, '2023-09-15 10:45:00', '2023-09-15 11:15:00'),        (6, 11, '2023-09-15 08:25:00', '2023-09-15 09:35:00'),        (6, 12, '2023-09-16 09:20:00', '2023-09-16 11:25:00'),        (7, 13, '2023-09-16 08:40:00', '2023-09-16 09:10:00'),        (7, 14, '2023-09-16 09:05:00', '2023-09-16 09:10:00'),        (8, 15, '2023-09-16 08:05:00', '2023-09-16 09:05:00'),        (8, 16, '2023-09-16 10:10:00', '2023-09-16 11:35:00'),        (9, 17, '2023-09-17 08:20:00', '2023-09-17 09:30:00'),        (9, 18, '2023-09-17 10:40:00', '2023-09-17 11:20:00'),        (10, 19, '2023-09-18 08:35:00', '2023-09-18 09:50:00'),        (10, 20, '2023-09-18 08:35:00', '2023-09-18 11:25:00'),        (11, 21, '2023-09-18 08:50:00', '2023-09-18 10:15:00'),        (11, 22, '2023-09-19 10:30:00', '2023-09-19 11:40:00'),        (12, 23, '2023-09-20 08:15:00', '2023-09-20 09:30:00'),        (12, 24, '2023-09-20 10:45:00', '2023-09-20 11:05:00'),        (13, 25, '2023-09-20 08:30:00', '2023-09-20 09:45:00'); ","Напишите запрос, извлекающий из предложенной базы данных идентификаторы аккаунтов, в которые в определенный момент времени был выполнен вход с разных IP-адресов.",10,3,select L1.account_id  from LogInfo L1 join LogInfo L2 on L1.account_id = L2.account_id  and L1.ip_address < L2.ip_address and L1.logout > L2.login,SELECT DISTINCT FirstLogin.account_id FROM LogInfo AS FirstLogin INNER JOIN LogInfo AS SecondLogin ON FirstLogin.account_id = SecondLogin.account_id         AND FirstLogin.ip_address != SecondLogin.ip_address WHERE FirstLogin.login BETWEEN SecondLogin.login AND SecondLogin.logout,
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Employees; CREATE TABLE Employees (     id         INT PRIMARY KEY AUTO_INCREMENT,     name       VARCHAR(255),     surname    VARCHAR(255),     age        INT,     manager_id INT );  INSERT INTO Employees (name, surname, age, manager_id) VALUES ('John', 'Doe', 35, NULL),        ('Jane', 'Smith', 28, NULL),        ('Michael', 'Johnson', 40, NULL),        ('Emily', 'Williams', 32, 1),        ('David', 'Brown', 45, 1),        ('Linda', 'Jones', 38, 1),        ('Robert', 'Miller', 33, 1),        ('Sarah', 'Davis', 29, 3),        ('James', 'Wilson', 41, 3),        ('Susan', 'Taylor', 34, 4),        ('William', 'Anderson', 39, 4),        ('Karen', 'Martinez', 30, 2),        ('Joseph', 'Hernandez', 36, 5),        ('Nancy', 'Garcia', 31, 2),        ('Daniel', 'Rodriguez', 37, 6),        ('Lisa', 'Lopez', 42, 2),        ('Charles', 'Perez', 27, 5),        ('Jessica', 'Moore', 43, 2),        ('Matthew', 'Jackson', 26, 8),        ('Patricia', 'White', 44, 9); "," Напишите запрос, который извлекает из предложенной базы данных имена и фамилии всех руководителей, а также определяет количество подчиненных у каждого руководителя и их средний возраст.",15,4,"select E1.name, E1.surname, count(*) as subordinates, round(avg(E2.age), 0) as average_age from Employees E1 inner join Employees E2 on E2.manager_id = E1.id group by E1.name, E1.surname",,
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Salaries; DROP TABLE IF EXISTS Employees;  -- Создание таблицы Employees CREATE TABLE Employees (     id      INT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Employees (id, name, surname) VALUES (2, 'Alice', 'Smith'),        (3, 'Bob', 'Johnson'),        (4, 'Eva', 'Williams'),        (5, 'Daniel', 'Brown'),        (6, 'Sophia', 'Jones'),        (7, 'Michael', 'Davis'),        (9, 'William', 'Lee'),        (10, 'Ava', 'Hall'),        (11, 'James', 'Miller'),        (13, 'Benjamin', 'Taylor'),        (14, 'Mia', 'Anderson'),        (15, 'Walter', 'White'),        (16, 'David', 'Dou'),        (17, 'JoJo', 'Referens'),        (18, 'Ethan', 'Harris'),        (19, 'Emma', 'Martin');  -- Создание таблицы Salaries CREATE TABLE Salaries (     employee_id INT,     salary      DECIMAL(10, 2) );  TRUNCATE Salaries; INSERT INTO Salaries (employee_id, salary) VALUES (1, 22517.00),        (2, 30500.50),        (5, 76071.00),        (8, 62000.00),        (9, 48000.50),        (10, 69000.75),        (11, 58000.00),        (12, 71000.25),        (13, 63000.50),        (14, 54000.75),        (18, 61000.25),        (20, 75000.75);","Напишите запрос, извлекающий из предложенной базы данных идентификаторы сотрудников, у которых либо неизвестны имя и фамилия, либо неизвестна зарплата.",20,5,select id as employee_id from Employees E left join Salaries S on id = employee_id where salary is null union select employee_id from Employees E right join Salaries S on id = employee_id where name is null order by employee_id,select id as employee_id from Employees where id not in (     select employee_id from Salaries ) union select employee_id  from Salaries where employee_id not in (     select id from Employees ) order by employee_id,
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Likes; DROP TABLE IF EXISTS Friendship;  -- Создание таблицы Friendship CREATE TABLE Friendship (     user1_id INT,     user2_id INT );  INSERT INTO Friendship (user1_id, user2_id) VALUES (1, 2),        (1, 3),        (1, 4),        (2, 3),        (2, 4),        (2, 5),        (6, 1),        (3, 6),        (4, 6),        (5, 6),        (7, 1),        (8, 1),        (9, 2),        (10, 3),        (11, 4),        (12, 5),        (13, 6),        (14, 7),        (15, 8),        (16, 9);  -- Создание таблицы Likes CREATE TABLE Likes (     user_id INT,     page_id INT );  TRUNCATE Likes; INSERT INTO Likes (user_id, page_id) VALUES (1, 88),        (2, 23),        (3, 24),        (4, 56),        (5, 11),        (2, 88),        (4, 88),        (6, 33),        (3, 88),        (4, 23),        (4, 85),        (2, 77),        (3, 23),        (3, 77),        (1, 85),        (6, 88),        (7, 23),        (8, 24),        (2, 77),        (9, 56),        (10, 11),        (11, 33),        (12, 77),        (13, 88),        (14, 23),        (15, 24),        (16, 56); "," Напишите запрос, извлекающий из предложенной базы данных идентификаторы постов, которые оценили друзья пользователя с идентификатором 1, но не оценил сам пользователь с идентификатором 1.",25,6,"select distinct page_id as recommended_page from (select user1_id, user2_id from Friendship union select user2_id, user1_id from Friendship) as F right join Likes on user2_id = user_id where user1_id = 1  and page_id not in ( select page_id from Likes where user_id = 1)",SELECT DISTINCT page_id AS recommended_page FROM Likes INNER JOIN Friendship ON user_id = user2_id OR user_id = user1_id WHERE (user1_id = 1 OR user2_id = 1)    AND page_id NOT IN (SELECT page_id                        FROM Likes                        WHERE user_id = 1),
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers;  -- Создание таблицы Customers CREATE TABLE Customers (     id      INT PRIMARY KEY AUTO_INCREMENT,     name    VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Customers (name, surname) VALUES ('Lech', 'Walesa'),        ('Julie', 'Andrews'),        ('Florence', 'Nightingale'),        ('Marie', 'Curie'),        ('Stephen', 'Hawking'),        ('Tim', 'Berners'),        ('Aung', 'San'),        ('Lance', 'Armstrong'),        ('Shakira', 'Curie'),        ('Jon', 'Stewart'),        ('Wright', 'BrothersOrville'),        ('Ernest', 'Hemingway'),        ('Roman', 'Abramovich'),        ('Tom', 'Cruise'),        ('Rupert', 'Murdoch'),        ('Al', 'Gore'),        ('Sacha', 'Baron'),        ('George', 'Clooney'),        ('Paul', 'Krugman'),        ('Jimmy', 'Wales');  -- Создание таблицы Orders CREATE TABLE Orders (     id           INT PRIMARY KEY AUTO_INCREMENT,     customer_id  INT,     product_code ENUM('A', 'B', 'C', 'D'),     FOREIGN KEY (customer_id)      REFERENCES Customers(id) );  TRUNCATE Orders; INSERT INTO Orders (customer_id, product_code) VALUES (16, 'A'),        (20, 'B'),        (7, 'A'),        (15, 'C'),        (16, 'B'),        (1, 'B'),        (3, 'C'),        (12, 'A'),        (15, 'B'),        (18, 'A'),        (14, 'A'),        (18, 'A'),        (7, 'B'),        (20, 'D'),        (19, 'A'),        (15, 'D'),        (19, 'B'),        (14, 'C'),        (20, 'A'),        (15, 'A');","Напишите запрос, извлекающий из предложенной базы данных информацию о пользователях (идентификатор, имя, фамилия), которые приобрели товары с кодами A и B, но не приобрели товар с кодом C.",30,7,"select distinct O.customer_id as id, name, surname from Orders O left join (select customer_id, product_code from Orders            where product_code = 'A') as A  on O.customer_id = A.customer_id left join (select customer_id, product_code from Orders            where product_code = 'B') as B on O.customer_id = B.customer_id left join (select customer_id, product_code from Orders            where product_code = 'C') as C on O.customer_id = C.customer_id join Customers on O.customer_id = Customers.id where A.product_code = 'A' and B.product_code = 'B' and C.product_code is null","SELECT Customers.id, Customers.name, Customers.surname FROM Customers CROSS JOIN Orders ON Orders.customer_id = Customers.id GROUP BY customer_id HAVING GROUP_CONCAT(Orders.product_code ORDER BY product_code) NOT LIKE '%C%' AND         GROUP_CONCAT(Orders.product_code ORDER BY product_code) LIKE 'A,B%'",
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS Championships; DROP TABLE IF EXISTS Teams;  -- Создание таблицы Teams CREATE TABLE Teams (     id        INT PRIMARY KEY AUTO_INCREMENT,     team_name VARCHAR(30) );  INSERT INTO Teams (id, team_name) VALUES (10, 'Manchester United'),        (20, 'Liverpool FC'),        (30, 'Chelsea FC'),        (40, 'Arsenal FC'),        (50, 'Manchester City'),        (60, 'Tottenham Hotspur'),        (70, 'Everton FC'),        (80, 'Leicester City'),        (90, 'West Ham United'),        (100, 'Aston Villa FC');  -- Создание таблицы Championships CREATE TABLE Championships (     year                         YEAR,     `FIFA World Cup`             INT,     `UEFA European Championship` INT,     `Copa America`               INT,     `African Cup of Nations`     INT );  TRUNCATE Championships; INSERT INTO Championships (year, `FIFA World Cup`, `UEFA European Championship`, `Copa America`, `African Cup of Nations`) VALUES (1999, 70, 70, 80, 60),        (2000, 10, 10, 60, 100),        (2001, 50, 90, 40, 20),        (2002, 70, 10, 30, 90),        (2003, 60, 90, 10, 100),        (2004, 100, 20, 20, 90),        (2005, 90, 50, 60, 40),        (2006, 70, 60, 20, 60),        (2007, 40, 80, 50, 50),        (2008, 10, 70, 70, 10),        (2009, 40, 60, 50, 80),        (2010, 30, 60, 50, 20),        (2011, 100, 60, 40, 90),        (2012, 80, 90, 80, 70),        (2013, 30, 30, 40, 50),        (2014, 90, 50, 90, 60),        (2015, 80, 60, 30, 20),        (2016, 40, 10, 70, 20),        (2017, 70, 20, 30, 20),        (2018, 20, 70, 90, 50),        (2019, 50, 10, 20, 50),        (2020, 80, 10, 90, 100),        (2021, 100, 80, 60, 70),        (2022, 40, 30, 100, 40),        (2023, 30, 40, 70, 40);","Напишите запрос, который извлекает из предложенной базы названия футбольных команд, а также определяет количество выигранных турниров каждой командой.",25,5,"select Teams.team_name, count(*) as tournaments_won  from Teams join (  select `FIFA World Cup` as team_name from Championships union all select `UEFA European Championship`from Championships union all select `Copa America`from Championships union all select `African Cup of Nations`from Championships  ) as C on Teams.id = C.team_name group by Teams.team_name","SELECT team_name,        (SUM(id = `FIFA World Cup`)) +        (SUM(id = `UEFA European Championship`)) +        (SUM(id = `Copa America`)) +        (SUM(id = `African Cup of Nations`)) AS tournaments_won FROM Teams T JOIN Championships C ON T.id IN (`FIFA World Cup`, `UEFA European Championship`, `Copa America`, `African Cup of Nations`) GROUP BY team_name",
12.6. Задачи. Продвинутые соединения ,"DROP TABLE IF EXISTS PriceChanges; CREATE TABLE PriceChanges (     product_id  INT,     new_price   DECIMAL(10, 2),     change_date DATE );  TRUNCATE PriceChanges; INSERT INTO PriceChanges (product_id, new_price, change_date) VALUES (1, 20.00, '2023-08-09'),        (2, 25.00, '2023-08-02'),        (3, 5.00, '2023-08-09'),        (1, 22.00, '2023-08-04'),        (4, 10.00, '2023-08-09'),        (2, 28.00, '2023-08-06'),        (1, 25.00, '2023-08-07'),        (3, 18.00, '2023-08-12'),        (5, 40.00, '2023-08-05'),        (4, 7.00, '2023-08-02'),        (2, 30.00, '2023-08-10'),        (6, 35.00, '2023-08-16'),        (1, 28.00, '2023-08-13'),        (3, 20.00, '2023-08-14'),        (5, 45.00, '2023-08-02'),        (4, 6.00, '2023-08-16'),        (2, 32.00, '2023-08-17'),        (6, 38.00, '2023-08-28'),        (1, 30.00, '2023-08-19'),        (3, 47.00, '2023-08-22'); ","Все товары, доступные в магазине, по умолчанию продаются по цене в 10 долларов.  Напишите запрос, который извлекает из предложенной базы данных идентификаторы всех товаров, а также определяет актуальную цену каждого товара на 2023-08-09.",25,6,"select P3.product_id, ifnull(new_price, 10.00) as current_price from PriceChanges as P1 join ( select product_id, max(change_date) as d from PriceChanges where change_date <= '2023-08-09' group by product_id order by product_id) as P2 on P1.product_id = P2.product_id  and P1.change_date = P2.d right join (select distinct product_id from PriceChanges) as P3 on P1.product_id = P3.product_id ","with AllProducts as (     select distinct product_id from PriceChanges ) select     p.product_id,     ifnull(curr.new_price, 10) as current_price from     AllProducts as p     left join PriceChanges as curr on          curr.product_id = p.product_id         and curr.change_date = (             select max(chng.change_date)             from PriceChanges as chng             where                  change_date <= '2023-08-09'                 and chng.product_id = p.product_id         )",
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Customers; CREATE TABLE Customers (     id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Customers (name, surname) VALUES ('Ryan', 'Gosling'),        ('Margot', 'Robbie'),        ('Jennifer', 'Aniston'),        ('Alain', 'Delon'),        ('Jake', 'Gyllenhaal');  DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id INT PRIMARY KEY AUTO_INCREMENT,     store VARCHAR(50),     customer_id INT,     amount INT,     purchased_on DATETIME );  INSERT INTO Orders (store, customer_id, amount, purchased_on) VALUES ('Two Cardinals', 1, 100, '2024-02-01 09:00:00'),        ('Lego World', 2, 200, '2024-01-15 07:30:00'),        ('POP SHOP', 4, 50, '2024-02-10 12:10:00'),        ('POP SHOP', 1, 90, '2024-01-20 10:00:00'),        ('Two Cardinals', 5, 210, '2024-01-15 08:00:00'),        ('POP SHOP', 3, 180, '2024-02-10 19:00:00'),        ('Two Cardinals', 1, 100, '2024-03-01 05:50:00'),        ('Lego World', 5, 1200, '2024-02-08 12:00:00'),        ('POP SHOP', 3, 90, '2024-02-11 09:00:00'),        ('Lego World', 2, 900, '2024-02-20 17:00:00'); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех заказах (название магазина, имя покупателя, фамилия покупателя, сумма заказа), а также пронумеровывает их, начиная с 1, в рамках магазина в порядке убывания суммы. При этом если два заказа из одного магазина имеют равные суммы, то их номера также должны совпадать.",10,2,"select  dense_rank() over (partition by store order by amount desc) as rank_within_store_by_price, store, name, surname, amount from Orders join Customers on Orders.customer_id = Customers.id",,
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Customers; CREATE TABLE Customers (     id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Customers (name, surname) VALUES ('Ryan', 'Gosling'),        ('Margot', 'Robbie'),        ('Jennifer', 'Aniston'),        ('Alain', 'Delon'),        ('Jake', 'Gyllenhaal');  DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id INT PRIMARY KEY AUTO_INCREMENT,     store VARCHAR(50),     customer_id INT,     amount INT,     purchased_on DATETIME );  INSERT INTO Orders (store, customer_id, amount, purchased_on) VALUES ('Two Cardinals', 1, 100, '2024-02-01 09:00:00'),        ('Lego World', 2, 200, '2024-01-15 07:30:00'),        ('POP SHOP', 4, 50, '2024-02-10 12:10:00'),        ('POP SHOP', 1, 90, '2024-01-20 10:00:00'),        ('Two Cardinals', 5, 210, '2024-01-15 08:00:00'),        ('POP SHOP', 3, 180, '2024-02-10 19:00:00'),        ('Two Cardinals', 1, 100, '2024-03-01 05:50:00'),        ('Lego World', 5, 1200, '2024-02-08 12:00:00'),        ('POP SHOP', 3, 90, '2024-02-11 09:00:00'),        ('Lego World', 2, 900, '2024-02-20 17:00:00'); ","Напишите запрос, который извлекает из предложенной базы данных следующую информацию о втором по времени заказе, совершенном в магазине POP SHOP: идентификатор заказа, имя покупателя, фамилия покупателя, сумма заказа, дата и время заказа.",15,3,"with A as ( select O.id, name, surname, amount, purchased_on, rank() over (partition by store order by purchased_on) as n from Orders O join Customers C on O.customer_id = C.id where store = 'POP SHOP') select id, name, surname, amount, purchased_on from A where n = 2",,
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Customers; CREATE TABLE Customers (     id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Customers (name, surname) VALUES ('Ryan', 'Gosling'),        ('Margot', 'Robbie'),        ('Jennifer', 'Aniston'),        ('Alain', 'Delon'),        ('Jake', 'Gyllenhaal');  DROP TABLE IF EXISTS Orders; CREATE TABLE Orders (     id INT PRIMARY KEY AUTO_INCREMENT,     store VARCHAR(50),     customer_id INT,     amount INT,     purchased_on DATETIME );  INSERT INTO Orders (store, customer_id, amount, purchased_on) VALUES ('Two Cardinals', 1, 100, '2024-02-01 09:00:00'),        ('Lego World', 2, 200, '2024-01-15 07:30:00'),        ('POP SHOP', 4, 50, '2024-02-10 12:10:00'),        ('POP SHOP', 1, 90, '2024-01-20 10:00:00'),        ('Two Cardinals', 5, 210, '2024-01-15 08:00:00'),        ('POP SHOP', 3, 180, '2024-02-10 19:00:00'),        ('Two Cardinals', 1, 100, '2024-03-01 05:50:00'),        ('Lego World', 5, 1200, '2024-02-08 12:00:00'),        ('POP SHOP', 3, 90, '2024-02-11 09:00:00'),        ('Lego World', 2, 900, '2024-02-20 17:00:00'); "," Напишите запрос, который извлекает из предложенной базы данных информацию обо всех заказах (имя покупателя, фамилия покупателя, сумма заказа, дата и время заказа), а также указывает для каждого заказа суммарную стоимость всех заказов, учитывая лишь текущий заказ, а также те заказы, что были совершены раньше по времени.",15,3,"select name, surname, amount, purchased_on, sum(amount) over (order by purchased_on rows between unbounded preceding  and current row) as increasing_amount from Customers C join Orders O on C.id = O.customer_id","SELECT name, surname, amount, purchased_on,        SUM(amount) OVER (ORDER BY purchased_on) AS increasing_amount FROM Orders INNER JOIN Customers ON customer_id = Customers.id;",
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS DailyTemperature; CREATE TABLE DailyTemperature (     day DATE PRIMARY KEY,     avg_temperature DECIMAL(5, 2) );  INSERT INTO DailyTemperature (day, avg_temperature) VALUES ('2024-02-01', -5.6),        ('2024-02-02', -4.3),        ('2024-02-03', -3.9),        ('2024-02-04', -2.7),        ('2024-02-05', -1.2),        ('2024-02-06', -0.5),        ('2024-02-07', 0.3),        ('2024-02-08', -2.1),        ('2024-02-09', -3.8),        ('2024-02-10', -4.5),        ('2024-02-11', -6.2),        ('2024-02-12', -6.8),        ('2024-02-13', -7.4),        ('2024-02-14', -7.9),        ('2024-02-15', -6.3),        ('2024-02-16', -5.7),        ('2024-02-17', -4.2),        ('2024-02-18', -3.6),        ('2024-02-19', -2.9),        ('2024-02-20', -1.4),        ('2024-02-21', -0.6),        ('2024-02-22', 0.4),        ('2024-02-23', -1.9),        ('2024-02-24', -3.7),        ('2024-02-25', -4.4),        ('2024-02-26', -6.1),        ('2024-02-27', -6.7),        ('2024-02-28', -7.2); ","Напишите запрос, который извлекает из предложенной базы данных все дни с 10 февраля по 25 февраля включительно, а также указывает для каждого дня среднюю дневную температуру в этот день и среднюю дневную температуру 3 дня назад.  ",15,3,"with A as ( select day, avg_temperature, lag(avg_temperature, 3) over (order by day) as avg_temperature_3_days_ago from DailyTemperature) select * from A where day(day) between 10 and 25","SELECT         day,         avg_temperature,        LAG(avg_temperature, 3) OVER(ORDER BY day) AS avg_temperature_3_days_ago  FROM DailyTemperature LIMIT 16 OFFSET 9",
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS DailyTemperature; CREATE TABLE DailyTemperature (     day DATE PRIMARY KEY,     avg_temperature DECIMAL(5, 2) );  INSERT INTO DailyTemperature (day, avg_temperature) VALUES ('2024-02-01', -5.6),        ('2024-02-02', -4.3),        ('2024-02-03', -3.9),        ('2024-02-04', -2.7),        ('2024-02-05', -1.2),        ('2024-02-06', -0.5),        ('2024-02-07', 0.3),        ('2024-02-08', -2.1),        ('2024-02-09', -3.8),        ('2024-02-10', -4.5),        ('2024-02-11', -6.2),        ('2024-02-12', -6.8),        ('2024-02-13', -7.4),        ('2024-02-14', -7.9),        ('2024-02-15', -6.3),        ('2024-02-16', -5.7),        ('2024-02-17', -4.2),        ('2024-02-18', -3.6),        ('2024-02-19', -2.9),        ('2024-02-20', -1.4),        ('2024-02-21', -0.6),        ('2024-02-22', 0.4),        ('2024-02-23', -1.9),        ('2024-02-24', -3.7),        ('2024-02-25', -4.4),        ('2024-02-26', -6.1),        ('2024-02-27', -6.7),        ('2024-02-28', -7.2); ","Напишите запрос, который извлекает из предложенной базы данных все дни с 1 февраля по 14 февраля включительно, а также указывает для каждого дня среднюю дневную температуру в этот день и среднюю дневную температуру через 7 дней.",10,3,"select day, avg_temperature, lead(avg_temperature, 7) over (order by day) as avg_temperature_after_7_days from DailyTemperature limit 14",,
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS DailyTemperature; CREATE TABLE DailyTemperature (     day DATE PRIMARY KEY,     avg_temperature DECIMAL(5, 2) );  INSERT INTO DailyTemperature (day, avg_temperature) VALUES ('2024-02-01', -5.6),        ('2024-02-02', -4.3),        ('2024-02-03', -3.9),        ('2024-02-04', -2.7),        ('2024-02-05', -1.2),        ('2024-02-06', -0.5),        ('2024-02-07', 0.3),        ('2024-02-08', -2.1),        ('2024-02-09', -3.8),        ('2024-02-10', -4.5),        ('2024-02-11', -6.2),        ('2024-02-12', -6.8),        ('2024-02-13', -7.4),        ('2024-02-14', -7.9),        ('2024-02-15', -6.3),        ('2024-02-16', -5.7),        ('2024-02-17', -4.2),        ('2024-02-18', -3.6),        ('2024-02-19', -2.9),        ('2024-02-20', -1.4),        ('2024-02-21', -0.6),        ('2024-02-22', 0.4),        ('2024-02-23', -1.9),        ('2024-02-24', -3.7),        ('2024-02-25', -4.4),        ('2024-02-26', -6.1),        ('2024-02-27', -6.7),        ('2024-02-28', -7.2); ","Напишите запрос, извлекающий из предложенной базы данных информацию о средней температуре в каждый из дней, а также указывающий для каждого дня количество других дней, в которые средняя температура отличалась от средней температуры в этот день не больше чем на 1 градус.",20,4,"select day, avg_temperature, count(*) over (order by avg_temperature range between 1 preceding and 1 following) - 1 as number_of_days_with_similar_temperature from DailyTemperature order by day","select day, avg_temperature,     (select sum(if(abs(DailyTemperature.avg_temperature - DT.avg_temperature) <= 1, 1, 0)) - 1        from DailyTemperature as DT) as number_of_days_with_similar_temperature from DailyTemperature order by day;",
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Procedures; CREATE TABLE Procedures (     id INT PRIMARY KEY AUTO_INCREMENT,     provided_on DATETIME,      doctor_id INT,     patient_id INT,     category VARCHAR(50),     price INT,     score INT );  INSERT INTO Procedures (provided_on, doctor_id, patient_id, category, price, score) VALUES ('2024-01-01 12:00:00', 1, 21, 'X-Ray', 150, 5),        ('2024-02-01 14:00:00', 2, 13, 'Blood Test', 100, 4),        ('2024-03-01 09:00:00', 1, 1, 'Vaccination', 200, 4),        ('2024-01-01 13:00:00', 4, 25, 'X-Ray', 80, 3),        ('2024-02-01 10:00:00', 2, 16, 'X-Ray', 250, 5),        ('2024-02-01 09:00:00', 3, 16, 'Vaccination', 120, 4),        ('2024-01-10 12:00:00', 1, 10, 'Vaccination', 300, 2),        ('2024-01-10 16:00:00', 4, 9, 'X-Ray', 500, 5),        ('2024-02-20 07:00:00', 5, 25, 'Vaccination', 180, 5),        ('2024-02-01 13:00:00', 5, 9, 'Blood Test', 150, 3);","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех услугах (дата оказания, категория, оценка), а также указывает для каждой услуги среднюю оценку всех услуг, учитывая лишь текущую услугу, а также предыдущую и следующую по времени услуги в той же категории.",10,2,"select provided_on, category, score, avg(score) over (partition by category order by provided_on rows between 1 preceding and 1 following) as moving_avg_score from Procedures",,
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Procedures; CREATE TABLE Procedures (     id INT PRIMARY KEY AUTO_INCREMENT,     provided_on DATETIME,      doctor_id INT,     patient_id INT,     category VARCHAR(50),     price INT,     score INT );  INSERT INTO Procedures (provided_on, doctor_id, patient_id, category, price, score) VALUES ('2024-01-01 12:00:00', 1, 21, 'X-Ray', 150, 5),        ('2024-02-01 14:00:00', 2, 13, 'Blood Test', 100, 4),        ('2024-03-01 09:00:00', 1, 1, 'Vaccination', 200, 4),        ('2024-01-01 13:00:00', 4, 25, 'X-Ray', 80, 3),        ('2024-02-01 10:00:00', 2, 16, 'X-Ray', 250, 5),        ('2024-02-01 09:00:00', 3, 16, 'Vaccination', 120, 4),        ('2024-01-10 12:00:00', 1, 10, 'Vaccination', 300, 2),        ('2024-01-10 16:00:00', 4, 9, 'X-Ray', 500, 5),        ('2024-02-20 07:00:00', 5, 25, 'Vaccination', 180, 5),        ('2024-02-01 13:00:00', 5, 9, 'Blood Test', 150, 3); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех услугах (дата оказания, категория, стоимость), а также указывает для каждой услуги стоимость предыдущей по времени услуги и разницу между стоимостями этих услуг.",10,3,"select provided_on, category, price, ifnull(lag(price, 1) over (order by provided_on), 0) as prev_procedure_price, abs(ifnull(lag(price, 1) over (order by provided_on), 0) - price) as prev_procedure_price_difference from Procedures",,
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Procedures; CREATE TABLE Procedures (     id INT PRIMARY KEY AUTO_INCREMENT,     provided_on DATETIME,      doctor_id INT,     patient_id INT,     category VARCHAR(50),     price INT,     score INT );  INSERT INTO Procedures (provided_on, doctor_id, patient_id, category, price, score) VALUES ('2024-01-01 12:00:00', 1, 21, 'X-Ray', 150, 5),        ('2024-02-01 14:00:00', 2, 13, 'Blood Test', 100, 4),        ('2024-03-01 09:00:00', 1, 1, 'Vaccination', 200, 4),        ('2024-01-01 13:00:00', 4, 25, 'X-Ray', 80, 3),        ('2024-02-01 10:00:00', 2, 16, 'X-Ray', 250, 5),        ('2024-02-01 09:00:00', 3, 16, 'Vaccination', 120, 4),        ('2024-01-10 12:00:00', 1, 10, 'Vaccination', 300, 2),        ('2024-01-10 16:00:00', 4, 9, 'X-Ray', 500, 5),        ('2024-02-20 07:00:00', 5, 25, 'Vaccination', 180, 5),        ('2024-02-01 13:00:00', 5, 9, 'Blood Test', 150, 3); ","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех услугах (дата оказания, категория, стоимость, оценка), а также указывает для каждой услуги стоимость услуги с самой высокой оценкой в той же категории и разницу между стоимостями этих услуг. Если услуг с наибольшей оценкой несколько, то выбрана должна быть та услуга, что была оказана раньше всех остальных.",15,4,"select provided_on, category, price, score, last_value(price) over (partition by category order by score, provided_on desc rows between unbounded preceding and unbounded following) as best_procedure_price, abs(price - last_value(price) over (partition by category order by score, provided_on desc rows between unbounded preceding and unbounded following)) as best_procedure_price_difference from Procedures",,
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Procedures; CREATE TABLE Procedures (     id INT PRIMARY KEY AUTO_INCREMENT,     provided_on DATETIME,      doctor_id INT,     patient_id INT,     category VARCHAR(50),     price INT,     score INT );  INSERT INTO Procedures (provided_on, doctor_id, patient_id, category, price, score) VALUES ('2024-01-01 12:00:00', 1, 21, 'X-Ray', 150, 5),        ('2024-01-02 14:00:00', 2, 13, 'Blood Test', 100, 4),        ('2024-01-07 07:00:00', 5, 25, 'Vaccination', 180, 5),        ('2024-01-08 13:00:00', 5, 9, 'Blood Test', 150, 3),        ('2024-01-04 13:00:00', 4, 25, 'X-Ray', 80, 3),        ('2024-01-04 10:00:00', 2, 16, 'X-Ray', 250, 5),        ('2024-01-05 09:00:00', 3, 16, 'Vaccination', 120, 4),        ('2024-01-02 09:00:00', 1, 1, 'Vaccination', 200, 4),        ('2024-01-07 12:00:00', 1, 10, 'Vaccination', 300, 2),        ('2024-01-07 16:00:00', 4, 9, 'X-Ray', 500, 5);","Напишите запрос, который извлекает из предложенной базы данных информацию обо всех услугах (дата оказания, категория, стоимость), а также указывает для каждой услуги максимальную стоимость услуги, оказанной в этот же день или предыдущий.  ",25,6,"with A as ( select provided_on, category, price, max(price) over (partition by day(provided_on) order by provided_on rows between unbounded preceding and unbounded following) as y from Procedures )  select provided_on, category, price, max(y) over (order by provided_on range between interval 1 day preceding and current row) as yesterday_today_max_price from A","SELECT provided_on, category, price,        MAX(price) OVER (ORDER BY DATE(provided_on)                         RANGE BETWEEN INTERVAL 1 DAY PRECEDING AND CURRENT ROW)AS yesterday_today_max_price FROM Procedures;",
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Procedures; CREATE TABLE Procedures (     id INT PRIMARY KEY AUTO_INCREMENT,     provided_on DATETIME,      doctor_id INT,     patient_id INT,     category VARCHAR(50),     price INT,     score INT );  INSERT INTO Procedures (provided_on, doctor_id, patient_id, category, price, score) VALUES ('2024-01-01 12:00:00', 1, 21, 'X-Ray', 150, 5),        ('2024-02-01 14:00:00', 2, 13, 'Blood Test', 100, 4),        ('2024-03-01 09:00:00', 1, 1, 'Vaccination', 200, 4),        ('2024-01-01 13:00:00', 4, 25, 'X-Ray', 80, 3),        ('2024-02-01 10:00:00', 2, 16, 'X-Ray', 250, 5),        ('2024-02-01 09:00:00', 3, 16, 'Vaccination', 120, 4),        ('2024-01-10 12:00:00', 1, 10, 'Vaccination', 300, 2),        ('2024-01-10 16:00:00', 4, 9, 'X-Ray', 500, 5),        ('2024-02-20 07:00:00', 5, 25, 'Vaccination', 180, 5),        ('2024-02-01 13:00:00', 5, 9, 'Blood Test', 150, 3); ","Напишите запрос, который разбивает процедуры на группы в зависимости от даты, в которую они были оказаны, вычисляет в рамках каждой группы количество оказанных услуг, и отображает полученный результат в виде таблицы из трех полей:",15,5,"with A as ( select distinct date(provided_on) as procedure_date, count(*) over (partition by date(provided_on)) as number_of_procedures from Procedures ) select procedure_date, number_of_procedures, abs(number_of_procedures - lag(number_of_procedures, 1) over (order by procedure_date rows between 1 preceding and current row)) as prev_date_number_of_procedures_difference from A","SELECT DATE(provided_on) AS procedure_date,        COUNT(*) AS number_of_procedures,        ABS(COUNT(*) - LAG(COUNT(*)) OVER (ORDER BY DATE(provided_on))) AS prev_date_number_of_procedures_difference FROM Procedures GROUP BY DATE(provided_on);",
12.7. Задачи. Оконные функции ,"DROP TABLE IF EXISTS Doctors; CREATE TABLE Doctors (     id INT PRIMARY KEY AUTO_INCREMENT,     name VARCHAR(50),     surname VARCHAR(50) );  INSERT INTO Doctors (name, surname) VALUES ('Stephen', 'Strange'),        ('John', 'Zoidberg'),        ('Victor', 'Frankenstein'),        ('Gregory', 'House'),        ('John', 'Doolittle');  DROP TABLE IF EXISTS Procedures; CREATE TABLE Procedures (     id INT PRIMARY KEY AUTO_INCREMENT,     provided_on DATETIME,      doctor_id INT,     patient_id INT,     category VARCHAR(50),     price INT,     score INT );  INSERT INTO Procedures (provided_on, doctor_id, patient_id, category, price, score) VALUES ('2024-01-01 12:00:00', 1, 21, 'X-Ray', 150, 5),        ('2024-02-01 14:00:00', 2, 13, 'Blood Test', 100, 5),        ('2024-02-15 14:00:00', 1, 11, 'X-Ray', 450, 5),        ('2024-03-02 05:00:00', 1, 9, 'Vaccination', 100, 4),        ('2024-02-01 13:00:00', 5, 9, 'Blood Test', 150, 5),        ('2024-03-01 09:00:00', 3, 1, 'Vaccination', 200, 4),        ('2024-01-01 13:00:00', 4, 25, 'X-Ray', 80, 5),        ('2024-02-22 19:00:00', 3, 11, 'Vaccination', 300, 4),        ('2024-02-01 10:00:00', 2, 16, 'X-Ray', 250, 5),        ('2024-02-01 09:00:00', 1, 16, 'Vaccination', 120, 4),        ('2024-01-10 12:00:00', 1, 10, 'Vaccination', 300, 3),        ('2024-01-16 08:00:00', 4, 2, 'X-Ray', 450, 5),        ('2024-02-20 07:00:00', 5, 25, 'Vaccination', 180, 5),        ('2024-01-10 16:00:00', 4, 9, 'X-Ray', 500, 5),        ('2024-02-02 12:00:00', 2, 10, 'Blood Test', 110, 5);"," Напишите запрос, который в рамках каждой категории услуг определяет врача, оказавшего наибольшее количество услуг с оценкой 5, и отображает полученный результат в виде таблицы из трех полей:  category — категория услуг doctor — имя и фамилия врача, оказавшего наибольшее количество услуг с оценкой 5 в этой категории number_of_high_score_procedures — количество оказанных врачом услуг с оценкой 5 в этой категории",30,7,"with A as ( select distinct category, doctor_id, count(*) as a from Procedures where score = 5 group by doctor_id, category     ), B as (     select distinct category, doctor_id, a, max(a) over (partition by category) as b from A) select category, (select concat(name, ' ', surname) from Doctors                   where id = B.doctor_id) as doctor, a as number_of_high_score_procedures  from B                  where a = b","WITH PreResult AS (     SELECT doctor_id, name, surname, category,            COUNT(*) AS number_of_high_score_procedures,            ROW_NUMBER() OVER (PARTITION BY category ORDER BY COUNT(*) DESC) AS cnt     FROM Procedures     INNER JOIN Doctors ON doctor_id = Doctors.id     WHERE score = 5     GROUP BY doctor_id, name, surname, category ) SELECT category,        CONCAT_WS(' ', name, surname) AS doctor,        number_of_high_score_procedures FROM PreResult WHERE cnt = 1;",
